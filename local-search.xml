<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>日期格式化YYYY可能出现的问题</title>
    <link href="/2023/08/23/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96YYYY%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/23/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96YYYY%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在公司恰巧与同事聊到了日期格式化的问题，被提醒使用SimpleDateFormat格式化信息的时候，一定别手误写成“YYYY-MM-dd”,小写大写区别很大，听说之前公司有员工可能手误写错了这个，后面导致了很多问题。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>于是自己写了个测试验证一下该问题。</p><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>( pattern: <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);    <span class="hljs-type">string</span> <span class="hljs-variable">datestr</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;2023-12-31 23:59:59&quot;</span>;    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(datestr);        <span class="hljs-type">string</span> <span class="hljs-variable">yearLowercase</span> <span class="hljs-operator">=</span> sdf.format(date); <span class="hljs-comment">// 使用小写的yyyy格式获取当前年份</span>    System.err.println(<span class="hljs-string">&quot;Lowercase: &quot;</span> + yearLowercase);        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>( pattern: <span class="hljs-string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);    <span class="hljs-type">string</span> <span class="hljs-variable">yearUppercase</span> <span class="hljs-operator">=</span> sdf2.format(date); <span class="hljs-comment">// 使用大写的YYYY格式获取当前基于周的年份</span>    System.err.println(<span class="hljs-string">&quot;Uppercase: &quot;</span> + yearUppercase);&#125;</code></pre></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>out:</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Lowercase</span>: <span class="hljs-number">2023</span>-<span class="hljs-number">12</span>-<span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span><span class="hljs-attribute">Uppercase</span>: <span class="hljs-number">2024</span>-<span class="hljs-number">12</span>-<span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span></code></pre></div><blockquote><p>很明显，使用YYYY时，2023年变成了2024年，在正常情况下可能没问题，但是在跨年的时候大概率就会有问题了。</p></blockquote><blockquote><p><strong>查找了一下资料，原因比较简单，与小写的yyyy不同，大写的YYYY表示一个基于周的年份。它是根据周计算的年份，而不是基于日历的年份。通常情况下，两者的结果是相同的，但在跨年的第一周或最后一周可能会有差异。</strong></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><ol><li>日期时间格式统一使用yyyy小写；</li><li>日期格式要规定大家都引用定义好的工具类，避免有人手误打错。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle-HWM高水位解读</title>
    <link href="/2023/08/05/Oracle-HWM%E9%AB%98%E6%B0%B4%E4%BD%8D%E8%A7%A3%E8%AF%BB/"/>
    <url>/2023/08/05/Oracle-HWM%E9%AB%98%E6%B0%B4%E4%BD%8D%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在工作中遇到一个数据不算多但是查询很慢的表，导致了其他关联业务出错，一开始很疑惑，查找了资料以及询问了同事，确定了应该是表高水平位的问题。</p><p>在此之前并没有学习了解过该问题，于是搜索了许多资料，看见了这篇解读很不错，故转载记录下来</p><h2 id="Oracle-HWM-High-Water-Mark-高水位解读"><a href="#Oracle-HWM-High-Water-Mark-高水位解读" class="headerlink" title="Oracle-HWM(High Water Mark) 高水位解读"></a>Oracle-HWM(High Water Mark) 高水位解读</h2><h1 id="读前须知：Oracle的逻辑存储管理"><a href="#读前须知：Oracle的逻辑存储管理" class="headerlink" title="读前须知：Oracle的逻辑存储管理"></a>读前须知：Oracle的逻辑存储管理</h1><hr><p> ORACLE在逻辑存储上分4个粒度 ，由大到小为: 表空间, 段, 区 和 块. </p><hr><h2 id="块Block"><a href="#块Block" class="headerlink" title="块Block"></a>块Block</h2><p> 块:是粒度最小的存储单位,现在标准的块大小是8K,ORACLE每一次I&#x2F;O操作也是按块来操作的,也就是说当ORACLE从数据文件读数据时,是读取多少个块,而不是多少行. 每一个Block里可以包含多个row. </p><p>数据块的大小是通过kb字节个数来指定的，默认为8KB。相关参数为db_block_size</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SQL</span>&gt; show parameter db_block_size<span class="hljs-variable constant_">NAME</span>                                 <span class="hljs-variable constant_">TYPE</span>        <span class="hljs-variable constant_">VALUE</span>----------------------- --------------------- ---------db_block_size                        integer     <span class="hljs-number">8192</span></code></pre></div><p>复制</p><hr><h2 id="区Extent"><a href="#区Extent" class="headerlink" title="区Extent"></a>区Extent</h2><p>由一系列相邻的块而组成,这也是ORACLE空间分配的基本单位.</p><p>区extent是比数据块大一级的存储结构，表示的是一连串连续的数据块集合。</p><p>在进行存储数据信息的时候，Oracle将分配数据块进行存储，但是不能保证所有分配的数据块都是连续的结构。</p><p>所以，出现分区extent的概念，表示一系列连续的数据块集合。</p><p>举个例子来说,当我们创建一个表时,首先ORACLE会分配一区的空间给这个表,随着数据不断地增长,原来的这个区容不下插入的数据时,ORACLE是以区为单位进行扩展的,也就是说再分配多少个区给这个表,而不是多少个块.</p><p>视图dba_extents（或者all_extents、user_extents）是我们研究分区结构和存储构成的重要手段。</p><hr><h2 id="段Segment"><a href="#段Segment" class="headerlink" title="段Segment"></a>段Segment</h2><p>段: 是由一系列的区extent所组成</p><p>数据段是与<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>对象相对应，一般一个数据库对象对应一个数据段。</p><p>多个extent是对应一个数据段，每个数据段实际上就是数据库一个对象的代表。</p><p>一般来说, 当创建一个对象时(表,索引),就会分配一个段给这个对象.</p><p>从dba_segments、user_segments视图中，可以比较清楚看清数据段的结构。</p><hr><h2 id="表空间Tablespace"><a href="#表空间Tablespace" class="headerlink" title="表空间Tablespace"></a>表空间Tablespace</h2><p>TableSpace是存储结构中的最高层结构。建立一个表空间的时候，是需要指定存储的文件。一个表空间可以指定多个数据文件，多个文件可以在不同的物理存储上。也就是说，表空间是可以跨物理存储的。</p><p>但是有一点就是，表空间下一级对象数据段的存储，是不能指定存储在那个文件里的。所以，要想让数据对象访问IO<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>，需要指定不同的数据对象在不同的表空间里。这也就是为什么将数据表和索引建立在不同的表空间的原因。</p><p>表空间通过v$tablespace进行访问 </p><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D1.jpg" alt="这里写图片描述"></p><p>其中两个参数需要注意一下。</p><p>一个是bigfile，是一个标志位，标志表空间是不是所谓的大文件表空间。</p><blockquote><p> 大文件表空间是在10g中推出的一个新特性，处于性能考虑，可以设置表空间为大文件表空间，存储超过百T的数据，但是要求数据文件只能有一个。 </p></blockquote><p>另一个是flashback_on，表示表空间的闪回特性是否开启。</p><p>还有 dba_tablespaces 、 user_tablespaces。</p><hr><h1 id="Oracle表段中的高水位线HWM"><a href="#Oracle表段中的高水位线HWM" class="headerlink" title="Oracle表段中的高水位线HWM"></a>Oracle表段中的高水位线HWM</h1><p>在数据库表刚建立的时候，由于没有任何数据，所以这个时候水位线是空的，也就是说HWM为最低值。</p><p>当插入了数据以后，高水位线就会上涨，但如果你采用delete语句删除数据的话，数据虽然被删除了，但是高水位线却没有降低，还是你刚才删除数据以前那么高的水位。</p><p>也就是说，这条高水位线在日常的增删操作中只会上涨，不会下跌。</p><p>HWM通常增长的幅度为一次5个数据块.</p><p>Select语句会对表中的数据进行一次扫描，但是究竟扫描多少<a href="https://cloud.tencent.com/product/cdcs?from_column=20065&from=20065">数据存储</a>块呢，这个并不是说数据库中有多少数据，Oracle就扫描这么大的数据块，而是Oracle会扫描高水位线以下的数据块。</p><p>试想一下，新建的一个空表，Select一下，由于高水位线HWM在最低的0位置上，所以没有数据块需要被扫描，扫描时间会极短。</p><p>如果这个时候你首先插入了一千万条数据，然后再用delete语句删除这一千万条数据。由于插入了一千万条数据，所以这个时候的高水位线就在一千万条数据这里。后来删除这一千万条数据的时候，由于delete语句不影响高水位线，所以高水位线依然在一千万条数据这里。</p><p>这个时候再一次用select语句进行扫描，虽然这个时候表中没有数据，但是由于扫描是按照高水位线来的，所以需要把一千万条数据的存储空间都要扫描一次，也就是说这次扫描所需要的时间和扫描一千万条数据所需要的时间是一样多的。所以有时候有人总是经常说，怎么我的表中没有几条数据，但是还是这么慢呢，这个时候其实奥秘就是这里的高水位线了。</p><p>那有没有办法让高水位线下降呢 ? 采用TRUNCATE语句删除一个表的数据的时候，类似于重新建立了表，不仅把数据都删除了，还把HWM给清空恢复为0。</p><p>所以如果需要把表清空，在有可能利用TRUNCATE语句来删除数据的时候就利用TRUNCATE语句来删除表，特别是那种数据量有可能很大的临时存储表。</p><hr><p>在手动段空间管理（Manual Segment Space Management）中，段中只有一个HWM，</p><p>但是在Oracle 9i Release1才添加的自动段空间管理（Automatic Segment Space Management）中，又有了一个低HWM的概念出来。</p><p>为什么有了HWM还又有一个低HWM呢，这个是因为自动段空间管理的特性造成的。在手段段空间管理中，当数据插入以后，如果是插入到新的数据块中，数据块就会被自动格式化等待数据访问。</p><p>而在自动段空间管理中，数据插入到新的数据块以后，数据块并没有被格式化，而是在第一次访问这个数据块的时候才格式化这个块。</p><p>所以我们又需要一条水位线，用来标示已经被格式化的块。这条水位线就叫做低HWM。一般来说，低HWM肯定是低于等于HWM的。</p><hr><h1 id="降低ORACLE表的高水位线"><a href="#降低ORACLE表的高水位线" class="headerlink" title="降低ORACLE表的高水位线"></a>降低ORACLE表的高水位线</h1><p>在ORACLE中，执行对表的删除操作不会降低该表的高水位线。而全表扫描将始终读取一个段(extent)中所有低于高水位线标记的块。如果在执行删除操作后不降低高水位线标记，则将导致查询语句的性能低下。</p><p>rebuild, truncate, shrink,move 等操作会降低高水位。</p><h2 id="执行表重建指令-alter-table-table-name-move"><a href="#执行表重建指令-alter-table-table-name-move" class="headerlink" title="执行表重建指令 alter table table_name move"></a>执行表重建指令 alter table table_name move</h2><p>在线转移表空间ALTER TABLE … MOVE TABLESPACE ..</p><p>当你创建了一个对象如表以后,不管你有没有插入数据,它都会占用一些块,ORACLE也会给它分配必要的空间.</p><p>同样,用ALTER TABLE MOVE释放自由空间后,还是保留了一些空间给这个表. </p><p>ALTER TABLE … MOVE 后面不跟参数也行，不跟参数表还是在原来的表空间，Move后记住重建索引.</p><p> 如果以后还要继续向这个表增加数据，没有必要move， 只是释放出来的空间，只能这个表用，其他的表或者segment无法使用该空间。</p><hr><h2 id="执行alter-table-table-name-shrink-space-10g新功能"><a href="#执行alter-table-table-name-shrink-space-10g新功能" class="headerlink" title="执行alter table table_name shrink space-10g新功能"></a>执行alter table table_name shrink space-10g新功能</h2><p>此命令为Oracle 10g新增功能，再执行该指令之前必须允许行移动 alter table table_name enable row movement;</p><p>如果要同时压缩表的索引,可以发布:alter table test_tab shrink space cascade</p><hr><h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>复制要保留的数据到临时表t，drop原表，然后rename临时表t为原表</p><hr><h2 id="用逻辑导入导出-Emp-Imp"><a href="#用逻辑导入导出-Emp-Imp" class="headerlink" title="用逻辑导入导出: Emp&#x2F;Imp"></a>用逻辑导入导出: Emp&#x2F;Imp</h2><hr><h2 id="Alter-table-table-name-deallocate-unused"><a href="#Alter-table-table-name-deallocate-unused" class="headerlink" title="Alter table table_name deallocate unused"></a>Alter table table_name deallocate unused</h2><p>DEALLOCATE UNUSED会释放HWM上面的未使用空间,但是并不会释放HWM下面的自由空间,也不会移动HWM的位置.</p><hr><h2 id="truncate-推荐使用"><a href="#truncate-推荐使用" class="headerlink" title="truncate(推荐使用)"></a>truncate(推荐使用)</h2><p>truncate table xxx</p><hr><h1 id="HWM的特征"><a href="#HWM的特征" class="headerlink" title="HWM的特征"></a>HWM的特征</h1><h2 id="ORACLE用HWM来界定一个段中使用的块和未使用的块"><a href="#ORACLE用HWM来界定一个段中使用的块和未使用的块" class="headerlink" title="ORACLE用HWM来界定一个段中使用的块和未使用的块"></a>ORACLE用HWM来界定一个段中使用的块和未使用的块</h2><p>当我们创建一个表时,ORACLE就会为这个对象分配一个段.在这个段中,即使我们未插入任何记录,也至少有一个区被分配,第一个区的第一个块就称为段头(SEGMENT HEADE),段头中就储存了一些信息,HWM的信息就存储在此.</p><p>我们不断插入数据时,HWM会往不断上移,这样,在HWM之下的,就表示使用过的块,HWM之上的就表示已分配但从未使用过的块.</p><hr><h2 id="HWM在插入数据时-当现有空间不足而进行空间的扩展时会向上移-但删除数据时不会往下移"><a href="#HWM在插入数据时-当现有空间不足而进行空间的扩展时会向上移-但删除数据时不会往下移" class="headerlink" title="HWM在插入数据时,当现有空间不足而进行空间的扩展时会向上移,但删除数据时不会往下移."></a>HWM在插入数据时,当现有空间不足而进行空间的扩展时会向上移,但删除数据时不会往下移.</h2><p>ORACLE 不会释放空间以供其他对象使用，有一条简单的理由：由于空间是为新插入的行保留的，并且要适应现有行的增长。被占用的最高空间称为最高使用标记 (HWM).</p><hr><h2 id="HWM的信息存储在段头当中"><a href="#HWM的信息存储在段头当中" class="headerlink" title="HWM的信息存储在段头当中."></a>HWM的信息存储在段头当中.</h2><p>HWM本身的信息是储存在段头.</p><p>在段空间是手工管理方式时,ORACLE是通过FREELIST(一个单向链表)来管理段内的空间分配.</p><p>在段空间是自动管理方式时(ASSM),ORACLE是通过BITMAP来管理段内的空间分配.</p><hr><h2 id="ORACLE的全表扫描是读取高水位标记-HWM-以下的所有块"><a href="#ORACLE的全表扫描是读取高水位标记-HWM-以下的所有块" class="headerlink" title="ORACLE的全表扫描是读取高水位标记(HWM)以下的所有块."></a>ORACLE的全表扫描是读取高水位标记(HWM)以下的所有块.</h2><p>所以问题就产生了.当用户发出一个全表扫描时，ORACLE 始终必须从段一直扫描到 HWM，即使它什么也没有发现。</p><p>该任务延长了全表扫描的时间。</p><hr><h2 id="当用直接路径插入行时，即使HWM以下有空闲的数据库块，键入在插入数据时使用了append关键字，则在插入时使用HWM以上的数据块，此时HWM会自动增大。"><a href="#当用直接路径插入行时，即使HWM以下有空闲的数据库块，键入在插入数据时使用了append关键字，则在插入时使用HWM以上的数据块，此时HWM会自动增大。" class="headerlink" title="当用直接路径插入行时，即使HWM以下有空闲的数据库块，键入在插入数据时使用了append关键字，则在插入时使用HWM以上的数据块，此时HWM会自动增大。"></a>当用直接路径插入行时，即使HWM以下有空闲的数据库块，键入在插入数据时使用了append关键字，则在插入时使用HWM以上的数据块，此时HWM会自动增大。</h2><p>例如，通过直接加载插入（用 APPEND 提示插入）或通过 SQL*LOADER 直接路径 数据块直接置于 HWM 之上。它下面的空间就浪费掉了。</p><hr><h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><p>数据库版本 Connected to Oracle Database 11g Enterprise Edition Release <strong>11.2.0.4.0</strong> </p><h2 id="创建测试表"><a href="#创建测试表" class="headerlink" title="创建测试表"></a>创建测试表</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SQL</span>&gt; create table <span class="hljs-title function_">tt</span>(id number);<span class="hljs-title class_">Table</span> created</code></pre></div><p>复制</p><p>此时表没有分析，是原始的数据，即8个数据块。</p><div class="code-wrapper"><pre><code class="hljs javascript">--空的<span class="hljs-variable constant_">SQL</span>&gt; <span class="hljs-variable constant_">SELECT</span> segment_name,segment_type,blocks <span class="hljs-variable constant_">FROM</span> dba_segments  a  <span class="hljs-variable constant_">WHERE</span> a.<span class="hljs-property">segment_name</span> = <span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">SEGMENT_NAME</span>                                                  <span class="hljs-variable constant_">SEGMENT_TYPE</span>     <span class="hljs-variable constant_">BLOCKS</span>-------------------------------------------------------------------------------- ------------------ ---------- --空的<span class="hljs-variable constant_">SQL</span>&gt; <span class="hljs-variable constant_">SELECT</span> table_name,num_rows,blocks,empty_blocks <span class="hljs-variable constant_">FROM</span> user_tables  <span class="hljs-variable constant_">WHERE</span> table_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">TABLE_NAME</span>         <span class="hljs-variable constant_">NUM_ROWS</span>     <span class="hljs-variable constant_">BLOCKS</span> <span class="hljs-variable constant_">EMPTY_BLOCKS</span>------------------------------ ---------- ---------- ------------<span class="hljs-variable constant_">TT</span></code></pre></div><p>复制</p><h2 id="向表中插入一些测试数据"><a href="#向表中插入一些测试数据" class="headerlink" title="向表中插入一些测试数据"></a>向表中插入一些测试数据</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SQL</span>&gt; declare  <span class="hljs-number">2</span>    i number;  <span class="hljs-number">3</span>  begin  <span class="hljs-number">4</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">10000</span> loop  <span class="hljs-number">5</span>      insert into tt values (i);  <span class="hljs-number">6</span>    end loop;  <span class="hljs-number">7</span>    commit;  <span class="hljs-number">8</span>  end;  <span class="hljs-number">9</span>  /<span class="hljs-variable constant_">PL</span>/<span class="hljs-variable constant_">SQL</span> procedure successfully completed</code></pre></div><p>复制</p><h2 id="重新查询表的信息"><a href="#重新查询表的信息" class="headerlink" title="重新查询表的信息"></a>重新查询表的信息</h2><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D2.jpg" alt="这里写图片描述"></p><p>此时表TT 占用的块已经是24个了.</p><p>但是user_tables 显示的信息还是为空。 因为没有做统计分析。</p><h2 id="收集统计信息"><a href="#收集统计信息" class="headerlink" title="收集统计信息"></a>收集统计信息</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SQL</span>&gt;  exec <span class="hljs-variable constant_">DBMS_STATS</span>.<span class="hljs-title function_">GATHER_TABLE_STATS</span>(user,<span class="hljs-string">&#x27;TT&#x27;</span>);<span class="hljs-variable constant_">PL</span>/<span class="hljs-variable constant_">SQL</span> procedure successfully completed</code></pre></div><p>复制</p><p>再此查询一下</p><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D3.jpg" alt="这里写图片描述"></p><p>此时user_tables 已经有了数据，显示的使用了20个数据块。 但是empty_blocks 还是为空。 这里要注意的地方。 empty_blocks 这个字段只有使用analyze 收集统计信息之后才会有数据。</p><hr><h2 id="使用analyze搜集统计信息"><a href="#使用analyze搜集统计信息" class="headerlink" title="使用analyze搜集统计信息"></a>使用analyze搜集统计信息</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SQL</span>&gt; analyze table tt compute statistics;<span class="hljs-title class_">Table</span> analyzed</code></pre></div><p>复制</p><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D4.jpg" alt="这里写图片描述"></p><h2 id="delete-数据，不会降低高水位"><a href="#delete-数据，不会降低高水位" class="headerlink" title="delete 数据，不会降低高水位"></a>delete 数据，不会降低高水位</h2><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D5.jpg" alt="这里写图片描述"></p><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D6.jpg" alt="这里写图片描述"></p><p>可以发现 分析前后，blocks 和 empty_blocks 都没有发生变化。</p><hr><h2 id="truncate-表，可以降低高水位"><a href="#truncate-表，可以降低高水位" class="headerlink" title="truncate 表，可以降低高水位"></a>truncate 表，可以降低高水位</h2><div class="code-wrapper"><pre><code class="hljs javascript">--truncate 表<span class="hljs-variable constant_">SQL</span>&gt; truncate table tt;<span class="hljs-title class_">Table</span> truncated--查询段信息，blocks由<span class="hljs-number">24</span>降到了<span class="hljs-number">8</span><span class="hljs-variable constant_">SQL</span>&gt;  <span class="hljs-variable constant_">SELECT</span> segment_name,segment_type,blocks <span class="hljs-variable constant_">FROM</span> dba_segments  <span class="hljs-variable constant_">WHERE</span> segment_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">SEGMENT_NAME</span>       <span class="hljs-variable constant_">SEGMENT_TYPE</span>     <span class="hljs-variable constant_">BLOCKS</span>---------         ----------       ----------<span class="hljs-variable constant_">TT</span>                  <span class="hljs-variable constant_">TABLE</span>            <span class="hljs-number">8</span>--查询表信息，没有改变<span class="hljs-variable constant_">SQL</span>&gt;   <span class="hljs-variable constant_">SELECT</span> table_name,num_rows,blocks,empty_blocks <span class="hljs-variable constant_">FROM</span> user_tables  <span class="hljs-variable constant_">WHERE</span> table_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">TABLE_NAME</span>    <span class="hljs-variable constant_">NUM_ROWS</span>    <span class="hljs-variable constant_">BLOCKS</span>    <span class="hljs-variable constant_">EMPTY_BLOCKS</span>--------     ----------    ------     ------<span class="hljs-variable constant_">TT</span>                 <span class="hljs-number">0</span>         <span class="hljs-number">20</span>         <span class="hljs-number">4</span>------------------------------------------------------------------------------------------------------------------------ --收集下表信息<span class="hljs-variable constant_">SQL</span>&gt;  exec dbms_stats.<span class="hljs-title function_">gather_table_stats</span>(user,<span class="hljs-string">&#x27;TT&#x27;</span>);<span class="hljs-variable constant_">PL</span>/<span class="hljs-variable constant_">SQL</span> procedure successfully completed--重新统计下段信息，一样<span class="hljs-variable constant_">SQL</span>&gt; <span class="hljs-variable constant_">SELECT</span> segment_name,segment_type,blocks <span class="hljs-variable constant_">FROM</span> dba_segments  <span class="hljs-variable constant_">WHERE</span> segment_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">SEGMENT_NAME</span>       <span class="hljs-variable constant_">SEGMENT_TYPE</span>     <span class="hljs-variable constant_">BLOCKS</span>---------         ----------       ----------<span class="hljs-variable constant_">TT</span>                  <span class="hljs-variable constant_">TABLE</span>            <span class="hljs-number">8</span>--重新查询表信息 <span class="hljs-variable constant_">BLOCKS</span> 由<span class="hljs-number">20</span>降为<span class="hljs-number">0</span>， 但是empyt_blocks 还是<span class="hljs-number">4</span>个<span class="hljs-variable constant_">SQL</span>&gt;  <span class="hljs-variable constant_">SELECT</span> table_name,num_rows,blocks,empty_blocks <span class="hljs-variable constant_">FROM</span> user_tables  <span class="hljs-variable constant_">WHERE</span> table_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">TABLE_NAME</span>  <span class="hljs-variable constant_">NUM_ROWS</span>     <span class="hljs-variable constant_">BLOCKS</span>       <span class="hljs-variable constant_">EMPTY_BLOCKS</span>---------- -----       ----------   ------------<span class="hljs-variable constant_">TT</span>           <span class="hljs-number">0</span>             <span class="hljs-number">0</span>            <span class="hljs-number">4</span>--analyze 分析下 更改<span class="hljs-variable constant_">EMPTY_BLOCKS</span>的值<span class="hljs-variable constant_">SQL</span>&gt; analyze table tt compute statistics;<span class="hljs-title class_">Table</span> analyzed --重新查询段信息，<span class="hljs-variable constant_">SQL</span>&gt;  <span class="hljs-variable constant_">SELECT</span> segment_name,segment_type,blocks <span class="hljs-variable constant_">FROM</span> dba_segments  <span class="hljs-variable constant_">WHERE</span> segment_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">SEGMENT_NAME</span>       <span class="hljs-variable constant_">SEGMENT_TYPE</span>     <span class="hljs-variable constant_">BLOCKS</span>---------         ----------       ----------<span class="hljs-variable constant_">TT</span>                  <span class="hljs-variable constant_">TABLE</span>            <span class="hljs-number">8</span> --重新查询表信息<span class="hljs-variable constant_">SQL</span>&gt; <span class="hljs-variable constant_">SELECT</span> table_name,num_rows,blocks,empty_blocks <span class="hljs-variable constant_">FROM</span> user_tables  <span class="hljs-variable constant_">WHERE</span> table_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">TABLE_NAME</span>  <span class="hljs-variable constant_">NUM_ROWS</span>     <span class="hljs-variable constant_">BLOCKS</span>       <span class="hljs-variable constant_">EMPTY_BLOCKS</span>---------- -----       ----------   ------------<span class="hljs-variable constant_">TT</span>           <span class="hljs-number">0</span>             <span class="hljs-number">0</span>            <span class="hljs-number">8</span><span class="hljs-variable constant_">SQL</span>&gt;</code></pre></div><p>复制</p><p>总共8个数据块，8个为空</p><hr><h1 id="Alter-table-move-和Shrink的区别"><a href="#Alter-table-move-和Shrink的区别" class="headerlink" title="Alter table move 和Shrink的区别"></a>Alter table move 和Shrink的区别</h1><h2 id="Shrink"><a href="#Shrink" class="headerlink" title="Shrink"></a>Shrink</h2><p>在10g之后，整理碎片消除行迁移的新增功能shrink space</p><p>语法</p><div class="code-wrapper"><pre><code class="hljs javascript">alter table  shrink space [ &lt;<span class="hljs-literal">null</span>&gt; | compact | cascade ];</code></pre></div><p>复制</p><ul><li>compact: 这个参数当系统的负载比较大时可以用，不降低HWM。如果系统负载较低时，直接用alter table table_name shrink space就一步到位了</li><li>cascade：这个参数是在shrink table的时候自动级联索引，相当于rebulid index。</li></ul><p>基于普通表</p><div class="code-wrapper"><pre><code class="hljs javascript">--shrink必须开启行迁移功能。alter table table_name enable row movement ;--保持<span class="hljs-variable constant_">HWM</span>，相当于把块中数据打结实了alter table table_name shrink space compact;--回缩表与降低<span class="hljs-variable constant_">HWM</span>alter table table_name shrink space;--回缩表与相关索引，降低<span class="hljs-variable constant_">HWM</span>alter table table_name shrink space cascade;--回缩索引与降低<span class="hljs-variable constant_">HWM</span>alter index index_name shrink space</code></pre></div><p>复制</p><p>虽然在10g中可以用shrink ，但也有些限制：</p><ul><li>1). 对cluster，cluster table，或具有Long，lob类型列的对象 不起作用。</li><li>2). 不支持具有function-based indexes 或 bitmap join indexes的表</li><li>3). 不支持mapping 表或index-organized表。</li><li>4). 不支持compressed 表</li></ul><hr><h2 id="shrink栗子"><a href="#shrink栗子" class="headerlink" title="shrink栗子"></a>shrink栗子</h2><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SQL</span>&gt; create table <span class="hljs-title function_">tt</span>(id number);<span class="hljs-variable constant_">SQL</span>&gt; declare  i number;begin  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">10000</span> loop    insert into tt values (i);  end loop;  commit;end;<span class="hljs-variable constant_">SQL</span>&gt; exec  <span class="hljs-variable constant_">DBMS_STATS</span>.<span class="hljs-title function_">GATHER_TABLE_STATS</span>(user,<span class="hljs-string">&#x27;TT&#x27;</span>);<span class="hljs-variable constant_">SQL</span>&gt;  analyze table tt compute statistics; <span class="hljs-variable constant_">SQL</span>&gt; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tt; <span class="hljs-variable constant_">SQL</span>&gt; commit ;<span class="hljs-variable constant_">SQL</span>&gt; alter table tt enable row movement ;<span class="hljs-variable constant_">SQL</span>&gt; alter table tt  shrink space;<span class="hljs-variable constant_">SQL</span>&gt; analyze table tt compute statistics;<span class="hljs-variable constant_">SQL</span>&gt; <span class="hljs-variable constant_">SELECT</span> segment_name,segment_type,blocks <span class="hljs-variable constant_">FROM</span> dba_segments  <span class="hljs-variable constant_">WHERE</span> segment_name=<span class="hljs-string">&#x27;TT&#x27;</span>;<span class="hljs-variable constant_">SQL</span>&gt; <span class="hljs-variable constant_">SELECT</span> table_name,num_rows,blocks,empty_blocks <span class="hljs-variable constant_">FROM</span> user_tables  <span class="hljs-variable constant_">WHERE</span> table_name=<span class="hljs-string">&#x27;TT&#x27;</span>;</code></pre></div><p>复制</p><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D8.jpg" alt="这里写图片描述"></p><p><img src="/../images/oracle%E9%AB%98%E6%B0%B4%E4%BD%8D7.jpg" alt="这里写图片描述"></p><hr><h2 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h2><p>通过desc table_name 来检查表中是否有LOB 字段，</p><h3 id="表中没有lob字段"><a href="#表中没有lob字段" class="headerlink" title="表中没有lob字段"></a>表中没有lob字段</h3><p>如果表没有LOB字段， 直接 alter table move; 然后 rebuild index</p><h3 id="表中包含了LOB字段"><a href="#表中包含了LOB字段" class="headerlink" title="表中包含了LOB字段"></a>表中包含了LOB字段</h3><div class="code-wrapper"><pre><code class="hljs javascript">alter table owner.<span class="hljs-property">table_name</span> move tablespace tablespace_name lob (lob_column) store <span class="hljs-keyword">as</span> lobsegment tablespace tablespace_name;</code></pre></div><p>复制</p><p>也可以单独move lob，但是表上的index 同样会失效. 所以在操作结束，需要对索引进行rebuild。</p><div class="code-wrapper"><pre><code class="hljs javascript">alter table owner.<span class="hljs-property">table_name</span> move <span class="hljs-title function_">lob</span>(lob_column) store <span class="hljs-keyword">as</span> lobsegment tablespace tablespace_name ;</code></pre></div><p>复制</p><p>索引的rebuild：</p><p>首先用下面的SQL查看表上面有哪类索引:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SELECT</span> a.<span class="hljs-property">owner</span>,       a.<span class="hljs-property">index_name</span>,       a.<span class="hljs-property">index_type</span>,       a.<span class="hljs-property">partitioned</span>,       a.<span class="hljs-property">status</span>,       b.<span class="hljs-property">status</span> p_status,       b.<span class="hljs-property">composite</span>  <span class="hljs-variable constant_">FROM</span>    dba_indexes a       <span class="hljs-variable constant_">LEFT</span> <span class="hljs-variable constant_">JOIN</span>          dba_ind_partitions b       <span class="hljs-variable constant_">ON</span> a.<span class="hljs-property">owner</span> = b.<span class="hljs-property">index_owner</span> <span class="hljs-variable constant_">AND</span> a.<span class="hljs-property">index_name</span> = b.<span class="hljs-property">index_name</span> <span class="hljs-variable constant_">WHERE</span> a.<span class="hljs-property">owner</span> = <span class="hljs-string">&#x27;&amp;owner&#x27;</span> <span class="hljs-variable constant_">AND</span> a.<span class="hljs-property">table_name</span> = <span class="hljs-string">&#x27;&amp;table_name&#x27;</span>;</code></pre></div><p>复制</p><p>对于普通索引直接rebuild online nologging parallel,  对于分区索引，必须单独rebuild 每个分区,  对于组合分区索引,必须单独rebuild 每个子分区。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Move 通过移动数据来来降低HWM，因此需要更多的磁盘空间。  Shrink 通过delete 和 insert， 会产生较多的undo 和redo。</p><p>shrink space收缩到数据存储的最小值，alter table move（不带参数）收缩到initial指定值，也可以用alter table test move storage(initial 500k)指定收缩的大小，这样可以达到shrink space效果。</p><p>总之，使用Move 效率会高点，但是会导致索引失效。Shrink 会产生undo 和redo，速度相对也慢一点。</p><p>转载：</p><p>博文学习至David Dai 大神，再此向大神致敬！<br>————————————————<br>版权声明：本文为CSDN博主「小小工匠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yangshangwei/article/details/53457321">https://blog.csdn.net/yangshangwei/article/details/53457321</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oracle表高水位</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA控制台使用不了npm的问题解决方案</title>
    <link href="/2023/07/21/IDEA%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E4%B8%8D%E4%BA%86npm%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/07/21/IDEA%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E4%B8%8D%E4%BA%86npm%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="idea中terminal使用npm报不是内部或外部命令，也不是可运行的程序-或批处理文件"><a href="#idea中terminal使用npm报不是内部或外部命令，也不是可运行的程序-或批处理文件" class="headerlink" title="idea中terminal使用npm报不是内部或外部命令，也不是可运行的程序 或批处理文件"></a>idea中terminal使用npm报不是内部或外部命令，也不是可运行的程序 或批处理文件</h1><p>今天在公司的电脑上新装了nodejs，但IDEA却用不了npm命令，运行</p><div class="code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span></code></pre></div><p>也提示不是内部或外部命令，但在cmd窗口却可以正常运行，很疑惑的一个问题，查了一些资料，应该是环境变量改变了，但IDEA还没识别到，网上查到了一些解决办法，记录下来。</p><p> 解决办法：有两个。</p><h3 id="一-部分人可行：将shell-path地址换成如下"><a href="#一-部分人可行：将shell-path地址换成如下" class="headerlink" title="(一)部分人可行：将shell path地址换成如下"></a>(一)部分人可行：将shell path地址换成如下</h3><p>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe，重启idea。再试试。</p><p><img src="https://img2020.cnblogs.com/blog/897885/202004/897885-20200401142529875-1376129187.png" alt="img"></p><h3 id="（二）如果方法一可行，就不要看这个了。如果方法一不行，再看这个。"><a href="#（二）如果方法一可行，就不要看这个了。如果方法一不行，再看这个。" class="headerlink" title="（二）如果方法一可行，就不要看这个了。如果方法一不行，再看这个。"></a>（二）如果方法一可行，就不要看这个了。如果方法一不行，再看这个。</h3><p>在doc命令下。windows 10 下，cmd添加了新功能，需要进入控制台，右击标题，选择属性，勾选使用旧版，并重启电脑，方可关联上。</p><p><img src="https://img2020.cnblogs.com/blog/897885/202004/897885-20200401142829048-332935808.png" alt="img"></p><h3 id="（三）重启电脑（解决一切不知所以的疑惑问题）"><a href="#（三）重启电脑（解决一切不知所以的疑惑问题）" class="headerlink" title="（三）重启电脑（解决一切不知所以的疑惑问题）"></a>（三）重启电脑（解决一切不知所以的疑惑问题）</h3>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录npm经常遇到的Connt find module xxx问题</title>
    <link href="/2023/05/07/%E8%AE%B0%E5%BD%95npm%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84Connt-find-module-xxx%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/07/%E8%AE%B0%E5%BD%95npm%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84Connt-find-module-xxx%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>本人经常在项目中遇到**npm：Error : Cannot find module “xxx”**等类似的问题，如下图所示，但一直不知具体原因，但多次经验也让我对此有了解决方案，在此对解决该问题的方案进行总结。</p><p><img src="/../images/image-20230807192530592.png"></p><p>nodejs版本</p><p><img src="/../images/image-20230807193401400.png"></p><p>npm版本</p><p><img src="/../images/image-20230807193410106.png"></p><p>1.最简单粗暴的办法</p><p>除node_modules 目录 再执行npm install     （亲测很有效）</p><p>2.可以先运行 清除缓存命令 </p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> cache verify</code></pre></div><p> 再运行</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span></code></pre></div><p>3.使用npm命令再次安装对应module （这里是本例中遇到的‘chalk’，具体根据报错来）</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> chalk</code></pre></div><p>虽然解决方法看似简单，但真的很操心，希望以后能少点遇到此类问题，也建议配置淘宝镜像</p><p>1、配置淘宝镜像</p><div class="code-wrapper"><pre><code class="hljs awk">npm install --registry=https:<span class="hljs-regexp">//</span>registry.npm.taobao.org <span class="hljs-regexp">//</span>单次使用npm config set registry https:<span class="hljs-regexp">//</span>registry.npm.taobao.org <span class="hljs-regexp">//</span>永远使用</code></pre></div><p>配置完成后检验是否成功：</p><div class="code-wrapper"><pre><code class="hljs arduino">npm config get registry <span class="hljs-comment">//或者下一行</span>npm info express<span class="hljs-comment">//或者上一</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀超卖的7种方案</title>
    <link href="/2023/04/17/%E7%A7%92%E6%9D%80%E8%B6%85%E5%8D%96%E7%9A%847%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
    <url>/2023/04/17/%E7%A7%92%E6%9D%80%E8%B6%85%E5%8D%96%E7%9A%847%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>高并发场景在现场的日常工作中很常见，特别是在互联网公司中，这篇文章就来通过秒杀商品来模拟高并发的场景。</p><ul><li><strong>本文环境：</strong> SpringBoot 2.5.7 + MySQL 8.0 X + MybatisPlus + Swagger2.9.2</li><li><strong>模拟工具：</strong> Jmeter</li><li><strong>模拟场景：</strong> 减库存-&gt;创建订单-&gt;模拟支付</li></ul><h2 id="2-商品秒杀-超卖"><a href="#2-商品秒杀-超卖" class="headerlink" title="2.商品秒杀-超卖"></a>2.商品秒杀-超卖</h2><p>在开发中，对于下面的代码，可能很熟悉：在Service里面加上<code>@Transactional</code>事务注解和Lock锁</p><p>控制层：Controller</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value=&quot;秒杀实现方式——Lock加锁&quot;)</span><span class="hljs-meta">@PostMapping(&quot;/start/lock&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startLock</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId)</span>&#123;    <span class="hljs-keyword">try</span> &#123;        log.info(<span class="hljs-string">&quot;开始秒杀方式一...&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextDouble() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>;        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillService.startSecondKillByLock(skgId, userId);        <span class="hljs-keyword">if</span>(result != <span class="hljs-literal">null</span>)&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="hljs-string">&quot;msg&quot;</span>));        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="hljs-string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>业务层：Service</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startSecondKillByLock</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId, <span class="hljs-type">long</span> userId)</span> &#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 校验库存</span>        <span class="hljs-type">SecondKill</span> <span class="hljs-variable">secondKill</span> <span class="hljs-operator">=</span> secondKillMapper.selectById(skgId);        <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> secondKill.getNumber();        <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 扣库存</span>            secondKill.setNumber(number - <span class="hljs-number">1</span>);            secondKillMapper.updateById(secondKill);            <span class="hljs-comment">// 创建订单</span>            <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">killed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();            killed.setSeckillId(skgId);            killed.setUserId(userId);            killed.setState((<span class="hljs-type">short</span>) <span class="hljs-number">0</span>);            killed.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            successKilledMapper.insert(killed);            <span class="hljs-comment">// 模拟支付</span>            <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>();            payment.setSeckillId(skgId);            payment.setSeckillId(skgId);            payment.setUserId(userId);            payment.setMoney(<span class="hljs-number">40</span>);            payment.setState((<span class="hljs-type">short</span>) <span class="hljs-number">1</span>);            payment.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            paymentMapper.insert(payment);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Result.error(SecondKillStateEnum.END);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScorpiosException</span>(<span class="hljs-string">&quot;异常了个乖乖&quot;</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;    <span class="hljs-keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);&#125;</code></pre></div><p>对于上面的代码应该没啥问题吧，业务方法上加事务，在处理业务的时候加锁。</p><p>但上面这样写法是有问题的，会出现超卖的情况，看下测试结果：模拟1000个并发，抢100商品</p><p>Jmeter不了解的，可以参考这篇文章：</p><blockquote><ul><li><a href="https://blog.csdn.net/zxd1435513775/article/details/106372446">https://blog.csdn.net/zxd1435513775/article/details/106372446</a></li></ul></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupU5s2jJ2rNPSk92pXttrWN7LY4X8mxzUIEDoh8uVLKiaX5FJ4Zvb8o7ugXMXclONEd7vpiasENT0Xyg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupU5s2jJ2rNPSk92pXttrWN7tRhfuWfxE2MCIqHB7xtppGwzAYnbq5bjdDTprj15JQM5dD0agU9RHw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这里在业务方法开始加了锁，在业务方法结束后释放了锁。但这里的事务提交却不是这样的，有可能在事务提交之前，就已经把锁释放了，这样会导致商品超卖现象。所以加锁的时机很重要！</p><h2 id="3-解决商品超卖"><a href="#3-解决商品超卖" class="headerlink" title="3. 解决商品超卖"></a>3. 解决商品超卖</h2><p>对于上面超卖现象，主要问题出现在事务中锁释放的时机，事务未提交之前，锁已经释放。（事务提交是在整个方法执行完）。如何解决这个问题呢，就是把加锁步骤提前</p><ul><li>可以在controller层进行加锁</li><li>可以使用Aop在业务方法执行之前进行加锁</li></ul><h3 id="3-1-方式一（改进版加锁）"><a href="#3-1-方式一（改进版加锁）" class="headerlink" title="3.1 方式一（改进版加锁）"></a>3.1 方式一（改进版加锁）</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value=&quot;秒杀实现方式——Lock加锁&quot;)</span><span class="hljs-meta">@PostMapping(&quot;/start/lock&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startLock</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId)</span>&#123;    <span class="hljs-comment">// 在此处加锁</span>    lock.lock();    <span class="hljs-keyword">try</span> &#123;        log.info(<span class="hljs-string">&quot;开始秒杀方式一...&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextDouble() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>;        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillService.startSecondKillByLock(skgId, userId);        <span class="hljs-keyword">if</span>(result != <span class="hljs-literal">null</span>)&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="hljs-string">&quot;msg&quot;</span>));        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="hljs-string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 在此处释放锁</span>        lock.unlock();    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>上面这样的加锁就可以解决事务未提交之前，锁释放的问题，可以分三种情况进行压力测试：</p><ul><li>并发数1000，商品100</li><li>并发数1000，商品1000</li><li>并发数2000，商品1000</li></ul><p>对于并发量大于商品数的情况，商品秒杀一般不会出现少卖的请况，但对于并发数小于等于商品数的时候可能会出现商品少卖情况，这也很好理解。</p><p>对于没有问题的情况就不贴图了，因为有很多种方式，贴图会太多</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupU5s2jJ2rNPSk92pXttrWN7icxAlGgtb1T8GGPZXNXX2yjPBTx2dictLauWu795rJfGHUSHibpQVgFzw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="3-2-方式二（AOP版加锁）"><a href="#3-2-方式二（AOP版加锁）" class="headerlink" title="3.2 方式二（AOP版加锁）"></a>3.2 方式二（AOP版加锁）</h3><p>对于上面在控制层进行加锁的方式，可能显得不优雅，那就还有另一种方式进行在事务之前加锁，那就是AOP</p><p>自定义AOP注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.PARAMETER, ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span>  <span class="hljs-meta">@interface</span> ServiceLock &#123;    String <span class="hljs-title function_">description</span><span class="hljs-params">()</span>  <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;</code></pre></div><p>定义切面类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Scope</span><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Order(1)</span> <span class="hljs-comment">//order越小越是最先执行，但更重要的是最先执行的最后结束</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockAspect</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 思考：为什么不用synchronized</span><span class="hljs-comment">     * service 默认是单例的，并发下lock只有一个实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 互斥锁 参数默认false，不公平锁</span>    <span class="hljs-comment">// Service层切点     用于记录错误日志</span>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.scorpios.secondkill.aop.ServiceLock)&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockAspect</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Around(&quot;lockAspect()&quot;)</span>    <span class="hljs-keyword">public</span>  Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;        lock.lock();        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            obj = joinPoint.proceed();        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();        &#125; <span class="hljs-keyword">finally</span>&#123;            lock.unlock();        &#125;        <span class="hljs-keyword">return</span> obj;    &#125;&#125;</code></pre></div><p>在业务方法上添加AOP注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@ServiceLock</span> <span class="hljs-comment">// 使用Aop进行加锁</span><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startSecondKillByAop</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId, <span class="hljs-type">long</span> userId)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 校验库存</span>        <span class="hljs-type">SecondKill</span> <span class="hljs-variable">secondKill</span> <span class="hljs-operator">=</span> secondKillMapper.selectById(skgId);        <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> secondKill.getNumber();        <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//扣库存</span>            secondKill.setNumber(number - <span class="hljs-number">1</span>);            secondKillMapper.updateById(secondKill);            <span class="hljs-comment">//创建订单</span>            <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">killed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();            killed.setSeckillId(skgId);            killed.setUserId(userId);            killed.setState((<span class="hljs-type">short</span>) <span class="hljs-number">0</span>);            killed.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            successKilledMapper.insert(killed);            <span class="hljs-comment">//支付</span>            <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>();            payment.setSeckillId(skgId);            payment.setSeckillId(skgId);            payment.setUserId(userId);            payment.setMoney(<span class="hljs-number">40</span>);            payment.setState((<span class="hljs-type">short</span>) <span class="hljs-number">1</span>);            payment.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            paymentMapper.insert(payment);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Result.error(SecondKillStateEnum.END);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScorpiosException</span>(<span class="hljs-string">&quot;异常了个乖乖&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);&#125;</code></pre></div><p>控制层：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value=&quot;秒杀实现方式二——Aop加锁&quot;)</span><span class="hljs-meta">@PostMapping(&quot;/start/aop&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startAop</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId)</span>&#123;    <span class="hljs-keyword">try</span> &#123;        log.info(<span class="hljs-string">&quot;开始秒杀方式二...&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextDouble() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>;        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillService.startSecondKillByAop(skgId, userId);        <span class="hljs-keyword">if</span>(result != <span class="hljs-literal">null</span>)&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="hljs-string">&quot;msg&quot;</span>));        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="hljs-string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>这种方式在对锁的使用上，更高阶、更美观！</p><h3 id="3-3-方式三（悲观锁一）"><a href="#3-3-方式三（悲观锁一）" class="headerlink" title="3.3 方式三（悲观锁一）"></a>3.3 方式三（悲观锁一）</h3><p>除了上面在业务代码层面加锁外，还可以使用数据库自带的锁进行并发控制。</p><p>悲观锁，什么是悲观锁呢？通俗的说，在做任何事情之前，都要进行加锁确认。这种数据库级加锁操作效率较低。</p><p>使用for update一定要加上事务，当事务处理完后，for update才会将行级锁解除</p><p>如果请求数和秒杀商品数量一致，会出现少卖</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value=&quot;秒杀实现方式三——悲观锁&quot;)</span><span class="hljs-meta">@PostMapping(&quot;/start/pes/lock/one&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startPesLockOne</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId)</span>&#123;    <span class="hljs-keyword">try</span> &#123;        log.info(<span class="hljs-string">&quot;开始秒杀方式三...&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextDouble() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>;        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillService.startSecondKillByUpdate(skgId, userId);        <span class="hljs-keyword">if</span>(result != <span class="hljs-literal">null</span>)&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="hljs-string">&quot;msg&quot;</span>));        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="hljs-string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>业务逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startSecondKillByUpdate</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId, <span class="hljs-type">long</span> userId)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 校验库存-悲观锁</span>        <span class="hljs-type">SecondKill</span> <span class="hljs-variable">secondKill</span> <span class="hljs-operator">=</span> secondKillMapper.querySecondKillForUpdate(skgId);        <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> secondKill.getNumber();        <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//扣库存</span>            secondKill.setNumber(number - <span class="hljs-number">1</span>);            secondKillMapper.updateById(secondKill);            <span class="hljs-comment">//创建订单</span>            <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">killed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();            killed.setSeckillId(skgId);            killed.setUserId(userId);            killed.setState((<span class="hljs-type">short</span>) <span class="hljs-number">0</span>);            killed.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            successKilledMapper.insert(killed);            <span class="hljs-comment">//支付</span>            <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>();            payment.setSeckillId(skgId);            payment.setSeckillId(skgId);            payment.setUserId(userId);            payment.setMoney(<span class="hljs-number">40</span>);            payment.setState((<span class="hljs-type">short</span>) <span class="hljs-number">1</span>);            payment.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            paymentMapper.insert(payment);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Result.error(SecondKillStateEnum.END);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScorpiosException</span>(<span class="hljs-string">&quot;异常了个乖乖&quot;</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;    &#125;    <span class="hljs-keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);&#125;</code></pre></div><p>Dao层</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecondKillMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;SecondKill&gt; &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将此行数据进行加锁，当整个方法将事务提交后，才会解锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skgId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Select(value = &quot;SELECT * FROM seckill WHERE seckill_id=#&#123;skgId&#125; FOR UPDATE&quot;)</span>    SecondKill <span class="hljs-title function_">querySecondKillForUpdate</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;skgId&quot;)</span> Long skgId)</span>;&#125;</code></pre></div><p>上面是利用for update进行对查询数据加锁，加的是行锁</p><h3 id="3-4-方式四（悲观锁二）"><a href="#3-4-方式四（悲观锁二）" class="headerlink" title="3.4 方式四（悲观锁二）"></a>3.4 方式四（悲观锁二）</h3><p>悲观锁的第二种方式就是利用update更新命令来加表锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * UPDATE锁表</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> skgId  商品id</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> userId    用户id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startSecondKillByUpdateTwo</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId, <span class="hljs-type">long</span> userId)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 不校验，直接扣库存更新</span>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillMapper.updateSecondKillById(skgId);        <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//创建订单</span>            <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">killed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();            killed.setSeckillId(skgId);            killed.setUserId(userId);            killed.setState((<span class="hljs-type">short</span>) <span class="hljs-number">0</span>);            killed.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            successKilledMapper.insert(killed);            <span class="hljs-comment">//支付</span>            <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>();            payment.setSeckillId(skgId);            payment.setSeckillId(skgId);            payment.setUserId(userId);            payment.setMoney(<span class="hljs-number">40</span>);            payment.setState((<span class="hljs-type">short</span>) <span class="hljs-number">1</span>);            payment.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));            paymentMapper.insert(payment);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Result.error(SecondKillStateEnum.END);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScorpiosException</span>(<span class="hljs-string">&quot;异常了个乖乖&quot;</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;    &#125;    <span class="hljs-keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);&#125;</code></pre></div><p>Dao层</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecondKillMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;SecondKill&gt; &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将此行数据进行加锁，当整个方法将事务提交后，才会解锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skgId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Select(value = &quot;SELECT * FROM seckill WHERE seckill_id=#&#123;skgId&#125; FOR UPDATE&quot;)</span>    SecondKill <span class="hljs-title function_">querySecondKillForUpdate</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;skgId&quot;)</span> Long skgId)</span>;    <span class="hljs-meta">@Update(value = &quot;UPDATE seckill SET number=number-1 WHERE seckill_id=#&#123;skgId&#125; AND number &gt; 0&quot;)</span>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateSecondKillById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;skgId&quot;)</span> <span class="hljs-type">long</span> skgId)</span>;&#125;</code></pre></div><h3 id="3-5-方式五（乐观锁）"><a href="#3-5-方式五（乐观锁）" class="headerlink" title="3.5 方式五（乐观锁）"></a>3.5 方式五（乐观锁）</h3><p>乐观锁，顾名思义，就是对操作结果很乐观，通过利用version字段来判断数据是否被修改</p><p>乐观锁，不进行库存数量的校验，直接做库存扣减</p><p>这里使用的乐观锁会出现大量的数据更新异常（抛异常就会导致购买失败）、如果配置的抢购人数比较少、比如120:100(人数:商品) 会出现少买的情况，不推荐使用乐观锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value=&quot;秒杀实现方式五——乐观锁&quot;)</span><span class="hljs-meta">@PostMapping(&quot;/start/opt/lock&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startOptLock</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId)</span>&#123;    <span class="hljs-keyword">try</span> &#123;        log.info(<span class="hljs-string">&quot;开始秒杀方式五...&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextDouble() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>;        <span class="hljs-comment">// 参数添加了购买数量</span>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillService.startSecondKillByPesLock(skgId, userId,<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(result != <span class="hljs-literal">null</span>)&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, result.get(<span class="hljs-string">&quot;msg&quot;</span>));        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;--&#123;&#125;&quot;</span>, userId, <span class="hljs-string">&quot;哎呦喂，人也太多了，请稍后！&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;<span class="hljs-meta">@Override</span><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startSecondKillByPesLock</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId, <span class="hljs-type">long</span> userId, <span class="hljs-type">int</span> number)</span> &#123;    <span class="hljs-comment">// 乐观锁，不进行库存数量的校验，直接</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">SecondKill</span> <span class="hljs-variable">kill</span> <span class="hljs-operator">=</span> secondKillMapper.selectById(skgId);        <span class="hljs-comment">// 剩余的数量应该要大于等于秒杀的数量</span>        <span class="hljs-keyword">if</span>(kill.getNumber() &gt;= number) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillMapper.updateSecondKillByVersion(number,skgId,kill.getVersion());            <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//创建订单</span>                <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">killed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();                killed.setSeckillId(skgId);                killed.setUserId(userId);                killed.setState((<span class="hljs-type">short</span>) <span class="hljs-number">0</span>);                killed.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));                successKilledMapper.insert(killed);                <span class="hljs-comment">//支付</span>                <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>();                payment.setSeckillId(skgId);                payment.setSeckillId(skgId);                payment.setUserId(userId);                payment.setMoney(<span class="hljs-number">40</span>);                payment.setState((<span class="hljs-type">short</span>) <span class="hljs-number">1</span>);                payment.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));                paymentMapper.insert(payment);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> Result.error(SecondKillStateEnum.END);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScorpiosException</span>(<span class="hljs-string">&quot;异常了个乖乖&quot;</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;    &#125;    <span class="hljs-keyword">return</span> Result.ok(SecondKillStateEnum.SUCCESS);&#125;<span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecondKillMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;SecondKill&gt; &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将此行数据进行加锁，当整个方法将事务提交后，才会解锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skgId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Select(value = &quot;SELECT * FROM seckill WHERE seckill_id=#&#123;skgId&#125; FOR UPDATE&quot;)</span>    SecondKill <span class="hljs-title function_">querySecondKillForUpdate</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;skgId&quot;)</span> Long skgId)</span>;    <span class="hljs-meta">@Update(value = &quot;UPDATE seckill SET number=number-1 WHERE seckill_id=#&#123;skgId&#125; AND number &gt; 0&quot;)</span>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateSecondKillById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;skgId&quot;)</span> <span class="hljs-type">long</span> skgId)</span>;    <span class="hljs-meta">@Update(value = &quot;UPDATE seckill  SET number=number-#&#123;number&#125;,version=version+1 WHERE seckill_id=#&#123;skgId&#125; AND version = #&#123;version&#125;&quot;)</span>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateSecondKillByVersion</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;number&quot;)</span> <span class="hljs-type">int</span> number, <span class="hljs-meta">@Param(&quot;skgId&quot;)</span> <span class="hljs-type">long</span> skgId, <span class="hljs-meta">@Param(&quot;version&quot;)</span><span class="hljs-type">int</span> version)</span>;&#125;</code></pre></div><p>乐观锁会出现大量的数据更新异常（抛异常就会导致购买失败），会出现少买的情况，不推荐使用乐观锁</p><h3 id="3-6-方式六（阻塞队列）"><a href="#3-6-方式六（阻塞队列）" class="headerlink" title="3.6 方式六（阻塞队列）"></a>3.6 方式六（阻塞队列）</h3><p>利用阻塞队类，也可以解决高并发问题。其思想就是把接收到的请求按顺序存放到队列中，消费者线程逐一从队列里取数据进行处理，看下具体代码。</p><p>阻塞队列：这里使用静态内部类的方式来实现单例模式，在并发条件下不会出现问题。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 秒杀队列(固定长度为100)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondKillQueue</span> &#123;    <span class="hljs-comment">// 队列大小</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">QUEUE_MAX_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;    <span class="hljs-comment">// 用于多线程间下单的队列</span>    <span class="hljs-keyword">static</span> BlockingQueue&lt;SuccessKilled&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;SuccessKilled&gt;(QUEUE_MAX_SIZE);    <span class="hljs-comment">// 使用静态内部类，实现单例模式</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SecondKillQueue</span><span class="hljs-params">()</span>&#123;&#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;        <span class="hljs-comment">// 静态初始化器，由JVM来保证线程安全</span>        <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-type">SecondKillQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondKillQueue</span>();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 单例队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecondKillQueue <span class="hljs-title function_">getSkillQueue</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> SingletonHolder.queue;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生产入队</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> kill</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><span class="hljs-comment">     * add(e) 队列未满时，返回true；队列满则抛出IllegalStateException(“Queue full”)异常——AbstractQueue</span><span class="hljs-comment">     * put(e) 队列未满时，直接插入没有返回值；队列满时会阻塞等待，一直等到队列未满时再插入。</span><span class="hljs-comment">     * offer(e) 队列未满时，返回true；队列满时返回false。非阻塞立即返回。</span><span class="hljs-comment">     * offer(e, time, unit) 设定等待的时间，如果在指定时间内还不能往队列中插入数据则返回false，插入成功返回true。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span>  Boolean  <span class="hljs-title function_">produce</span><span class="hljs-params">(SuccessKilled kill)</span> &#123;        <span class="hljs-keyword">return</span> blockingQueue.offer(kill);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 消费出队</span><span class="hljs-comment">     * poll() 获取并移除队首元素，在指定的时间内去轮询队列看有没有首元素有则返回，否者超时后返回null</span><span class="hljs-comment">     * take() 与带超时时间的poll类似不同在于take时候如果当前队列空了它会一直等待其他线程调用notEmpty.signal()才会被唤醒</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span>  SuccessKilled <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">return</span> blockingQueue.take();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取队列大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> blockingQueue.size();    &#125;&#125;</code></pre></div><p>消费秒杀队列：实现ApplicationRunner接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 消费秒杀队列</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SecondKillService seckillService;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments <span class="hljs-keyword">var</span>)</span>&#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            log.info(<span class="hljs-string">&quot;队列启动成功&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 进程内队列</span>                    <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">kill</span> <span class="hljs-operator">=</span> SecondKillQueue.getSkillQueue().consume();                    <span class="hljs-keyword">if</span>(kill != <span class="hljs-literal">null</span>)&#123;                        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> seckillService.startSecondKillByAop(kill.getSeckillId(), kill.getUserId());                        <span class="hljs-keyword">if</span>(result != <span class="hljs-literal">null</span> &amp;&amp; result.equals(Result.ok(SecondKillStateEnum.SUCCESS)))&#123;                            log.info(<span class="hljs-string">&quot;TaskRunner,result:&#123;&#125;&quot;</span>,result);                            log.info(<span class="hljs-string">&quot;TaskRunner从消息队列取出用户，用户:&#123;&#125;&#123;&#125;&quot;</span>,kill.getUserId(),<span class="hljs-string">&quot;秒杀成功&quot;</span>);                        &#125;                    &#125;                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();    &#125;&#125;<span class="hljs-meta">@ApiOperation(value=&quot;秒杀实现方式六——消息队列&quot;)</span><span class="hljs-meta">@PostMapping(&quot;/start/queue&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startQueue</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId)</span>&#123;    <span class="hljs-keyword">try</span> &#123;        log.info(<span class="hljs-string">&quot;开始秒杀方式六...&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextDouble() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>;        <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">kill</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();        kill.setSeckillId(skgId);        kill.setUserId(userId);        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> SecondKillQueue.getSkillQueue().produce(kill);        <span class="hljs-comment">// 虽然进入了队列，但是不一定能秒杀成功 进队出队有时间间隙</span>        <span class="hljs-keyword">if</span>(flag)&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,kill.getUserId(),<span class="hljs-string">&quot;秒杀成功&quot;</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,userId,<span class="hljs-string">&quot;秒杀失败&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><blockquote><p>注意：在业务层和AOP方法中，不能抛出任何异常， throw new RuntimeException()这些抛异常代码要注释掉。因为一旦程序抛出异常就会停止，导致消费秒杀队列进程终止！</p></blockquote><p>使用阻塞队列来实现秒杀，有几点要注意：</p><ul><li>消费秒杀队列中调用业务方法加锁与不加锁情况一样，也就是<code>seckillService.startSecondKillByAop()</code>、<code>seckillService.startSecondKillByLock()</code>方法结果一样，这也很好理解</li><li>当队列长度与商品数量一致时，会出现少卖的现象，可以调大数值</li><li>下面是队列长度1000，商品数量1000，并发数2000情况下出现的少卖</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupU5s2jJ2rNPSk92pXttrWN7QVspLsqttacbqibPJqJdW8z351tHAKSwWsSlnTQ4VPL8GIL2P8150kQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="3-7-方式七（Disruptor队列）"><a href="#3-7-方式七（Disruptor队列）" class="headerlink" title="3.7.方式七（Disruptor队列）"></a>3.7.方式七（Disruptor队列）</h3><p>Disruptor是个高性能队列，研发的初衷是解决内存队列的延迟问题，在性能测试中发现竟然与I&#x2F;O操作处于同样的数量级，基于Disruptor开发的系统单线程能支撑每秒600万订单。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 事件生成工厂（用来初始化预分配事件对象）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondKillEventFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventFactory</span>&lt;SecondKillEvent&gt; &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> SecondKillEvent <span class="hljs-title function_">newInstance</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondKillEvent</span>();    &#125;&#125;<span class="hljs-comment">// 事件对象（秒杀事件）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondKillEvent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> seckillId;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> userId; <span class="hljs-comment">// set/get方法略</span>&#125;<span class="hljs-comment">// 使用translator方式生产者</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondKillEventProducer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> EventTranslatorVararg&lt;SecondKillEvent&gt; translator = (seckillEvent, seq, objs) -&gt; &#123;        seckillEvent.setSeckillId((Long) objs[<span class="hljs-number">0</span>]);        seckillEvent.setUserId((Long) objs[<span class="hljs-number">1</span>]);    &#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RingBuffer&lt;SecondKillEvent&gt; ringBuffer;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SecondKillEventProducer</span><span class="hljs-params">(RingBuffer&lt;SecondKillEvent&gt; ringBuffer)</span>&#123;        <span class="hljs-built_in">this</span>.ringBuffer = ringBuffer;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">secondKill</span><span class="hljs-params">(<span class="hljs-type">long</span> seckillId, <span class="hljs-type">long</span> userId)</span>&#123;        <span class="hljs-built_in">this</span>.ringBuffer.publishEvent(translator, seckillId, userId);    &#125;&#125;<span class="hljs-comment">// 消费者(秒杀处理器)</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondKillEventConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventHandler</span>&lt;SecondKillEvent&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">SecondKillService</span> <span class="hljs-variable">secondKillService</span> <span class="hljs-operator">=</span> (SecondKillService) SpringUtil.getBean(<span class="hljs-string">&quot;secondKillService&quot;</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(SecondKillEvent seckillEvent, <span class="hljs-type">long</span> seq, <span class="hljs-type">boolean</span> bool)</span> &#123;        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> secondKillService.startSecondKillByAop(seckillEvent.getSeckillId(), seckillEvent.getUserId());        <span class="hljs-keyword">if</span>(result.equals(Result.ok(SecondKillStateEnum.SUCCESS)))&#123;            log.info(<span class="hljs-string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,seckillEvent.getUserId(),<span class="hljs-string">&quot;秒杀成功&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisruptorUtil</span> &#123;    <span class="hljs-keyword">static</span> Disruptor&lt;SecondKillEvent&gt; disruptor;    <span class="hljs-keyword">static</span>&#123;        <span class="hljs-type">SecondKillEventFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondKillEventFactory</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">ringBufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>;        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> runnable -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);        disruptor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Disruptor</span>&lt;&gt;(factory, ringBufferSize, threadFactory);        disruptor.handleEventsWith(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondKillEventConsumer</span>());        disruptor.start();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(SecondKillEvent kill)</span>&#123;        RingBuffer&lt;SecondKillEvent&gt; ringBuffer = disruptor.getRingBuffer();        <span class="hljs-type">SecondKillEventProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondKillEventProducer</span>(ringBuffer);        producer.secondKill(kill.getSeckillId(),kill.getUserId());    &#125;&#125;<span class="hljs-meta">@ApiOperation(value=&quot;秒杀实现方式七——Disruptor队列&quot;)</span><span class="hljs-meta">@PostMapping(&quot;/start/disruptor&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startDisruptor</span><span class="hljs-params">(<span class="hljs-type">long</span> skgId)</span>&#123;    <span class="hljs-keyword">try</span> &#123;        log.info(<span class="hljs-string">&quot;开始秒杀方式七...&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextDouble() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>;        <span class="hljs-type">SecondKillEvent</span> <span class="hljs-variable">kill</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondKillEvent</span>();        kill.setSeckillId(skgId);        kill.setUserId(userId);        DisruptorUtil.producer(kill);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>经过测试，发现使用Disruptor队列队列，与自定义队列有着同样的问题，也会出现超卖的情况，但效率有所提高。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>对于上面七种实现并发的方式，做一下总结：</p><ul><li>一、二方式是在代码中利用锁和事务的方式解决了并发问题，主要解决的是锁要加载事务之前</li><li>三、四、五方式主要是数据库的锁来解决并发问题，方式三是利用for upate对表加行锁，方式四是利用update来对表加锁，方式五是通过增加version字段来控制数据库的更新操作，方式五的效果最差</li><li>六、七方式是通过队列来解决并发问题，这里需要特别注意的是，在代码中不能通过throw抛异常，否则消费线程会终止，而且由于进队和出队存在时间间隙，会导致商品少卖</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秒杀超卖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql实用函数</title>
    <link href="/2023/04/11/Mysql%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2023/04/11/Mysql%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h3 id="0-显示当前时间"><a href="#0-显示当前时间" class="headerlink" title="0. 显示当前时间"></a><strong>0. 显示当前时间</strong></h3><p> <strong>命令</strong>：<code>select now()</code>。<br> <strong>作用</strong>: 显示当前时间。<br> <strong>应用场景</strong>: 创建时间，修改时间等默认值。<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select now();</span><span class="hljs-section">+---------------------+</span><span class="hljs-section">| now()               |</span><span class="hljs-section">+---------------------+</span><span class="hljs-section">| 2017-12-27 20:14:56 |</span><span class="hljs-section">+---------------------+</span>1 row in set (0.00 sec)</code></pre></div><h3 id="1-字符长度"><a href="#1-字符长度" class="headerlink" title="1. 字符长度"></a><strong>1. 字符长度</strong></h3><p> <strong>命令</strong>：<code>select char_length(&#39;andyqan&#39;)</code>。<br> <strong>作用</strong>: 显示指定字符长度。<br> <strong>应用场景</strong>: 查看字符长度时。<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select char_length(&#x27;andyqian&#x27;);</span><span class="hljs-section">+-------------------------+</span><span class="hljs-section">| char_length(&#x27;andyqian&#x27;) |</span><span class="hljs-section">+-------------------------+</span><span class="hljs-section">|                       8 |</span><span class="hljs-section">+-------------------------+</span>1 row in set (0.00 sec)</code></pre></div><h3 id="2-日期格式化"><a href="#2-日期格式化" class="headerlink" title="2. 日期格式化"></a><strong>2. 日期格式化</strong></h3><p> <strong>命令</strong>：<code>select date_format(now(),&#39;%y-%m-%d)</code>。<br> <strong>作用</strong>：格式化日期。<br> <strong>应用场景</strong>：格式化日期时。<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select date_format(now(),&#x27;%y-%m-%d&#x27;);</span><span class="hljs-section">+-------------------------------+</span><span class="hljs-section">| date_format(now(),&#x27;%y-%m-%d&#x27;) |</span><span class="hljs-section">+-------------------------------+</span><span class="hljs-section">| 17-12-28                      |</span><span class="hljs-section">+-------------------------------+</span>1 row in set (0.00 sec)</code></pre></div><p>这里支持的格式有:<br> %y：表示年(两位数)，例如: 17 年。<br> %Y：表示4位数中的年，例如: 2017年<br> %m：表示月(1-12)<br> %d: 表示月中的天<br> %H: 小时(0-23)<br> %i: 分钟 (0-59)<br> %s: 秒 (0-59)</p><p>年月日时分秒: %y-%m-%d %H:%i:%s，<br> 如下所示：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select DATE_FORMAT(now(),&#x27;%y-%m-%d %H:%i:%s&#x27;);</span><span class="hljs-section">+----------------------------------------+</span><span class="hljs-section">| DATE_FORMAT(now(),&#x27;%y-%m-%d %H:%i:%s&#x27;) |</span><span class="hljs-section">+----------------------------------------+</span><span class="hljs-section">| 17-12-27 20:28:54                      |</span><span class="hljs-section">+----------------------------------------+</span>1 row in set (0.00 sec)</code></pre></div><h3 id="3-添加-减少日期时间"><a href="#3-添加-减少日期时间" class="headerlink" title="3. 添加&#x2F;减少日期时间"></a><strong>3. 添加&#x2F;减少日期时间</strong></h3><p> <strong>命令</strong>：<br> <code>DATE_ADD(date,interval expr unit)</code><br> <code>DATE_SUB(date,interval expr unit)</code><br> <strong>作用</strong>: 增加&#x2F;减少日期时间<br> <strong>应用场景</strong>：当前时间的前一天，前几分钟。 常用于数据统计。<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select date_add(now(),interval 1 day);</span><span class="hljs-section">+--------------------------------+</span><span class="hljs-section">| date_add(now(),interval 1 day) |</span><span class="hljs-section">+--------------------------------+</span><span class="hljs-section">| 2017-12-28 20:10:17            |</span><span class="hljs-section">+--------------------------------+</span>1 row in set (0.00 sec)</code></pre></div><p>其中Date表示日期格式，其中就包括: 如<br> 2017-12-27，now() 等格式。<br> expr：表示数量。<br> unit：表示单位，支持毫秒(microsecond)，秒(second)，小时(hour)，天(day)，周(week)，年(year)等。</p><h3 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4. 类型转换"></a><strong>4. 类型转换</strong></h3><p> <strong>命令</strong>： <code>CAST(expr AS type)</code><br> <strong>作用</strong>: 主要用于显示类型转换<br> <strong>应用场景</strong>：显示类型转换<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select cast(18700000000 as char);</span><span class="hljs-section">+---------------------------+</span><span class="hljs-section">| cast(18700000000 as char) |</span><span class="hljs-section">+---------------------------+</span><span class="hljs-section">| 18700000000               |</span><span class="hljs-section">+---------------------------+</span>1 row in set (0.00 sec)</code></pre></div><p>需要注意的是，其中type支持的不是全部基本数据类型</p><h3 id="5-加密函数"><a href="#5-加密函数" class="headerlink" title="5. 加密函数"></a><strong>5. 加密函数</strong></h3><p> <strong>命令</strong>： <code>md5(data)</code><br> <strong>作用</strong>: 用于加密数据<br> <strong>应用场景</strong>：加密，一些隐私数据，例如银行卡号，身份证等需要存储密文，(当然，不建议使用数据库层加密，应该在应用层加密)<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select md5(&quot;andyqian&quot;);</span><span class="hljs-section">+----------------------------------+</span><span class="hljs-section">| md5(&quot;andyqian&quot;)                  |</span><span class="hljs-section">+----------------------------------+</span><span class="hljs-section">| 8a6f60827608e7f1ae29d1abcecffc3a |</span><span class="hljs-section">+----------------------------------+</span>1 row in set (0.00 sec)</code></pre></div><p>注意事项: 如果目前你们数据库中的数据还是明文，此时可以使用数据库加密算法进行加密。</p><p>例如: (仅做演示):</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> t_base_user <span class="hljs-keyword">set</span> <span class="hljs-type">name</span>=md5(<span class="hljs-type">name</span>),updated_time=now() <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span>;</code></pre></div><p>支持的加密函数有:</p><ol><li>md5()</li><li>des_encrypt(加密) &#x2F; des_decrypt(解密);</li><li>sha1()</li><li>password() 等等</li></ol><p>这里不再一一介绍，有兴趣的同学，可以移步至官网进行详细了解。</p><h3 id="6-字符串连接"><a href="#6-字符串连接" class="headerlink" title="6. 字符串连接"></a><strong>6. 字符串连接</strong></h3><p> <strong>命令</strong>： <code>concat(str,str2,str3)</code><br> <strong>作用</strong>：拼接字符串<br> <strong>应用场景</strong>：拼接字符串，例如在某些字段上同一加上指定字符串。<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select concat(&quot;andy&quot;,&quot;qian&quot;);</span><span class="hljs-section">+-----------------------+</span><span class="hljs-section">| concat(&quot;andy&quot;,&quot;qian&quot;) |</span><span class="hljs-section">+-----------------------+</span><span class="hljs-section">| andyqian              |</span><span class="hljs-section">+-----------------------+</span>1 row in set (0.00 sec)</code></pre></div><p>该函数平时也还是用的比较多的，基本上场景是，在某些数据上，加上特定的字符串。方法如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/3/160ba0e5ed36134b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><h3 id="7-JSON函数-5-7版本才支持"><a href="#7-JSON函数-5-7版本才支持" class="headerlink" title="7. JSON函数(5.7版本才支持)"></a><strong>7. JSON函数(5.7版本才支持)</strong></h3><p><strong>命令</strong>：<code>json_object(函数)</code><br> <strong>作用</strong>：转换json字符串<br> <strong>应用场景</strong>：指定数据转换json字符串<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select json_object(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;);</span><span class="hljs-section">+---------------------------------------------------+</span><span class="hljs-section">| json_object(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;) |</span><span class="hljs-section">+---------------------------------------------------+</span><span class="hljs-section">| &#123;&quot;name&quot;: &quot;andyqian&quot;, &quot;database&quot;: &quot;MySQL&quot;&#125;         |</span><span class="hljs-section">+---------------------------------------------------+</span>1 row in set (0.00 sec)</code></pre></div><p>其中包括json_array:</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select json_array(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;);</span><span class="hljs-section">+--------------------------------------------------+</span><span class="hljs-section">| json_array(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;) |</span><span class="hljs-section">+--------------------------------------------------+</span>| [&quot;name&quot;, &quot;andyqian&quot;, &quot;database&quot;, &quot;MySQL&quot;]        |<span class="hljs-code">+--------------------------------------------------+</span>1 row in set (0.00 sec)</code></pre></div><p>判断是否为json字符串的json_valid():</p><div class="code-wrapper"><pre><code class="hljs scilab"><span class="hljs-keyword">select</span> json_valid(<span class="hljs-string">&#x27;&#123;&quot;</span>name<span class="hljs-string">&quot;: &quot;</span>andyqian<span class="hljs-string">&quot;, &quot;</span>database<span class="hljs-string">&quot;: &quot;</span>MySQL<span class="hljs-string">&quot;&#125;&#x27;</span>);</code></pre></div><p>其中为有效json字符串时为1。<br> 无效json字符串时为0.<br> 还有很多方法，不再一一演示。</p><h3 id="8-聚合函数"><a href="#8-聚合函数" class="headerlink" title="8. 聚合函数"></a><strong>8. 聚合函数</strong></h3><p> <strong>命令</strong>： <code>sum()，count()，avg()，max()，min()</code><br> <strong>作用</strong>：统计，求平均值，最大，最小值<br> <strong>应用场景</strong>：这类函数非常常见，主要用于数据统计，在SQL优化方面，也适用。<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select max(id) from t_base_user;</span><span class="hljs-section">+---------+</span><span class="hljs-section">| max(id) |</span><span class="hljs-section">+---------+</span><span class="hljs-section">|       2 |</span><span class="hljs-section">+---------+</span>1 row in set (0.00 sec)</code></pre></div><p>这里有个小技巧，如果主键是有序递增的，当需要有多少用户时，可以使用max(id)来代替count(*)函数。</p><h3 id="9-distinct"><a href="#9-distinct" class="headerlink" title="9. distinct()"></a><strong>9. distinct()</strong></h3><p> <strong>命令</strong>： <code>distinct</code><br> <strong>作用</strong>：去重<br> <strong>应用场景</strong>：需要统计类型，状态，计算区分度时。<br> <strong>例子</strong>：</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select count(distinct(name))/count(*) from t_base_user;</span><span class="hljs-section">+--------------------------------+</span><span class="hljs-section">| count(distinct(name))/count(*) |</span><span class="hljs-section">+--------------------------------+</span><span class="hljs-section">|                         0.6667 |</span><span class="hljs-section">+--------------------------------+</span>1 row in set (0.00 sec)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql索引失效的场景</title>
    <link href="/2023/03/23/Mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF/"/>
    <url>/2023/03/23/Mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库及索引准备"><a href="#数据库及索引准备" class="headerlink" title="数据库及索引准备"></a>数据库及索引准备</h2><h3 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h3><p>为了逐项验证索引的使用情况，先准备一张表t_user：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `t_user` (  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;ID&#x27;,  `id_no` varchar(18) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT &#x27;身份编号&#x27;,  `username` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT &#x27;用户名&#x27;,  `age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  PRIMARY KEY (`id`),  KEY `union_idx` (`id_no`,`username`,`age`),  KEY `create_time_idx` (`create_time`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;</code></pre></div><p>在上述表结构中有三个索引：</p><ul><li><code>id</code>：为数据库主键；</li><li><code>union_idx</code>：为id_no、username、age构成的联合索引；</li><li><code>create_time_idx</code>：是由create_time构成的普通索引；</li></ul><h3 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h3><p>初始化数据分两部分：基础数据和批量导入数据。</p><p>基础数据insert了4条数据，其中第4条数据的创建时间为未来的时间，用于后续特殊场景的验证：</p><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO `t_user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#x27;1001&#x27;, &#x27;Tom1&#x27;, 11, &#x27;2022-02-27 09:04:23&#x27;);INSERT INTO `t_user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#x27;1002&#x27;, &#x27;Tom2&#x27;, 12, &#x27;2022-02-26 09:04:23&#x27;);INSERT INTO `t_user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#x27;1003&#x27;, &#x27;Tom3&#x27;, 13, &#x27;2022-02-25 09:04:23&#x27;);INSERT INTO `t_user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#x27;1004&#x27;, &#x27;Tom4&#x27;, 14, &#x27;2023-02-25 09:04:23&#x27;);</code></pre></div><p>除了基础数据，还有一条存储过程及其调用的SQL，方便批量插入数据，用来验证数据比较多的场景：</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 删除历史存储过程DROP PROCEDURE IF EXISTS `insert_t_user`-- 创建存储过程delimiter $CREATE PROCEDURE insert_t_user(IN limit_num int)BEGIN    DECLARE i INT DEFAULT 10;    DECLARE id_no varchar(18) ;    DECLARE username varchar(32) ;    DECLARE age TINYINT DEFAULT 1;    WHILE i &lt; limit_num DO        SET id_no = CONCAT(&quot;NO&quot;, i);        SET username = CONCAT(&quot;Tom&quot;,i);        SET age = FLOOR(10 + RAND()*2);        INSERT INTO `t_user` VALUES (NULL, id_no, username, age, NOW());        SET i = i + 1;    END WHILE;END $-- 调用存储过程call insert_t_user(100);</code></pre></div><p>关于存储过程的创建和存储，可暂时不执行，当用到时再执行。</p><h3 id="数据库版本及执行计划"><a href="#数据库版本及执行计划" class="headerlink" title="数据库版本及执行计划"></a>数据库版本及执行计划</h3><p>查看当前数据库的版本：</p><div class="code-wrapper"><pre><code class="hljs mysql">select version();8.0.18</code></pre></div><p>上述为本人测试的数据库版本：<code>8.0.18</code>。当然，以下的所有示例，大家可在其他版本进行执行验证。</p><p>查看SQL语句执行计划，一般我们都采用<code>explain</code>关键字，通过执行结果来判断索引使用情况。</p><p>执行示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id = 1;</code></pre></div><p>执行结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469453" alt="explain"></p><p>可以看到上述SQL语句使用了主键索引（PRIMARY），<code>key_len</code>为4；</p><p>其中<code>key_len</code>的含义为：表示索引使用的字节数，根据这个值可以判断索引的使用情况，特别是在组合索引的时候，判断该索引有多少部分被使用到非常重要。</p><p>做好以上数据及知识的准备，下面就开始讲解具体索引失效的实例了。</p><h2 id="1-联合索引不满足最左匹配原则"><a href="#1-联合索引不满足最左匹配原则" class="headerlink" title="1 联合索引不满足最左匹配原则"></a>1 联合索引不满足最左匹配原则</h2><p>联合索引遵从最左匹配原则，顾名思义，<strong>在联合索引中，最左侧的字段优先匹配</strong>。因此，在创建联合索引时，where子句中使用最频繁的字段放在组合索引的最左侧。</p><p>而在查询时，要想让查询条件走索引，则需满足：最左边的字段要出现在查询条件中。</p><p>实例中，<code>union_idx</code>联合索引组成：</p><div class="code-wrapper"><pre><code class="hljs mysql">KEY `union_idx` (`id_no`,`username`,`age`)</code></pre></div><p>最左边的字段为id_no，一般情况下，只要保证id_no出现在查询条件中，则会走该联合索引。</p><p><strong>示例一</strong>：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no = &#x27;1002&#x27;;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469454" alt="explain-01"></p><p>通过explain执行结果可以看出，上述SQL语句走了<code>union_idx</code>这条索引。</p><p>这里再普及一下key_len的计算：</p><ul><li><code>id_no</code> 类型为varchar(18)，字符集为utf8mb4_bin，也就是使用4个字节来表示一个完整的UTF-8。此时，key_len &#x3D; 18* 4 &#x3D; 72；</li><li>由于该字段类型varchar为变长数据类型，需要再额外添加2个字节。此时，key_len &#x3D; 72 + 2 &#x3D; 74；</li><li>由于该字段运行为NULL（default NULL），需要再添加1个字节。此时，key_len &#x3D; 74 + 1 &#x3D; 75；</li></ul><p>上面演示了key_len一种情况的计算过程，后续不再进行逐一推演，知道基本组成和原理即可，更多情况大家可自行查看。</p><p><strong>示例二</strong>：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no = &#x27;1002&#x27; and username = &#x27;Tom2&#x27;;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469455" alt="explain-02"></p><p>很显然，依旧走了<code>union_idx</code>索引，根据上面key_len的分析，大胆猜测，在使用索引时，不仅使用了<code>id_no</code>列，还使用了<code>username</code>列。</p><p><strong>示例三</strong>：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no = &#x27;1002&#x27; and age = 12;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469456" alt="explain-03"></p><p>走了<code>union_idx</code>索引，但跟示例一一样，只用到了<code>id_no</code>列。</p><p>当然，还有三列都在查询条件中的情况，就不再举例了。上面都是走索引的正向例子，也就是满足<code>最左匹配原则</code>的例子，下面来看看，不满足该原则的反向例子。</p><p><strong>反向示例</strong>：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where username = &#x27;Tom2&#x27; and age = 12;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469457" alt="explain-04"></p><p>此时，可以看到未走任何索引，也就是说索引失效了。</p><p>同样的，下面只要没出现最左条件的组合，索引也是失效的：</p><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> age = <span class="hljs-number">12</span>;<span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> username = <span class="hljs-string">&#x27;Tom2&#x27;</span>;</code></pre></div><p>那么，第一种索引失效的场景就是：<strong>在联合索引的场景下，查询条件不满足最左匹配原则</strong>。</p><h2 id="2-使用了select"><a href="#2-使用了select" class="headerlink" title="2 使用了select *"></a>2 使用了select *</h2><p>在《阿里巴巴开发手册》的<strong>ORM映射</strong>章节中有一条【强制】的规范：</p><blockquote><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明:1)增加查询分析器解析成本。2)增减字段容易与 resultMap 配置不一致。3)无用字段增加网络 消耗，尤其是 text 类型的字段。</p></blockquote><p>虽然在规范手册中没有提到索引方面的问题，但禁止使用<code>select *</code> 语句可能会带来的附带好处就是：某些情况下可以走<code>覆盖索引</code>。</p><p>比如，在上面的联合索引中，如果查询条件是age或username，当使用了<code>select *</code> ，肯定是不会走索引的。</p><p>但如果希望根据username查询出id_no、username、age这三个结果（均为索引字段），明确查询结果字段，是可以走<code>覆盖索引</code>的：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select id_no, username, age from t_user where username = &#x27;Tom2&#x27;;explain select id_no, username, age from t_user where age = 12;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469458" alt="覆盖索引"></p><p>无论查询条件是<code>username</code>还是<code>age</code>，都走了索引，根据key_len可以看出使用了索引的所有列。</p><p>第二种索引失效场景：<strong>在联合索引下，尽量使用明确的查询列来趋向于走覆盖索引</strong>；</p><p>这一条不走索引的情况属于优化项，如果业务场景满足，则进来促使SQL语句走索引。至于阿里巴巴开发手册中的规范，只不过是两者撞到一起了，规范本身并不是为这条索引规则而定的。</p><h2 id="3-索引列参与运算"><a href="#3-索引列参与运算" class="headerlink" title="3 索引列参与运算"></a>3 索引列参与运算</h2><p>直接来看示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id + 1 = 2 ;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469459" alt="索引列计算"></p><p>可以看到，即便id列有索引，由于进行了计算处理，导致无法正常走索引。</p><p>针对这种情况，其实不单单是索引的问题，还会增加数据库的计算负担。就以上述SQL语句为例，数据库需要全表扫描出所有的id字段值，然后对其计算，计算之后再与参数值进行比较。如果每次执行都经历上述步骤，性能损耗可想而知。</p><p>建议的使用方式是：先在内存中进行计算好预期的值，或者在SQL语句条件的右侧进行参数值的计算。</p><p>针对上述示例的优化如下：</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 内存计算，得知要查询的id为1explain select * from t_user where id = 1 ;-- 参数侧计算explain select * from t_user where id = 2 - 1 ;</code></pre></div><p>第三种索引失效情况：<strong>索引列参与了运算，会导致全表扫描，索引失效</strong>。</p><h2 id="4-索引列参使用了函数"><a href="#4-索引列参使用了函数" class="headerlink" title="4 索引列参使用了函数"></a>4 索引列参使用了函数</h2><p>示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where SUBSTR(id_no,1,3) = &#x27;100&#x27;;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469460" alt="索引-函数"></p><p>上述示例中，索引列使用了函数（SUBSTR，字符串截取），导致索引失效。</p><p>此时，索引失效的原因与第三种情况一样，都是因为数据库要先进行全表扫描，获得数据之后再进行截取、计算，导致索引索引失效。同时，还伴随着性能问题。</p><p>示例中只列举了SUBSTR函数，像CONCAT等类似的函数，也都会出现类似的情况。解决方案可参考第三种场景，可考虑先通过内存计算或其他方式减少数据库来进行内容的处理。</p><p>第四种索引失效情况：<strong>索引列参与了函数处理，会导致全表扫描，索引失效</strong>。</p><h2 id="5-错误的Like使用"><a href="#5-错误的Like使用" class="headerlink" title="5 错误的Like使用"></a>5 错误的Like使用</h2><p>示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no like &#x27;%00%&#x27;;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469460" alt="索引-like"></p><p>针对<code>like</code>的使用非常频繁，但使用不当往往会导致不走索引。常见的like使用方式有：</p><ul><li>方式一：like ‘%abc’；</li><li>方式二：like ‘abc%’；</li><li>方式三：like ‘%abc%’；</li></ul><p>其中方式一和方式三，由于占位符出现在首部，导致无法走索引。这种情况不做索引的原因很容易理解，索引本身就相当于目录，从左到右逐个排序。而条件的左侧使用了占位符，导致无法按照正常的目录进行匹配，导致索引失效就很正常了。</p><p>第五种索引失效情况：<strong>模糊查询时（like语句），模糊匹配的占位符位于条件的首部</strong>。</p><h2 id="6-类型隐式转换"><a href="#6-类型隐式转换" class="headerlink" title="6 类型隐式转换"></a>6 类型隐式转换</h2><p>示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no = 1002;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469461" alt="隐式转换"></p><p><code>id_no</code>字段类型为varchar，但在SQL语句中使用了int类型，导致全表扫描。</p><p>出现索引失效的原因是：varchar和int是两个种不同的类型。</p><p>解决方案就是将参数<code>1002</code>添加上单引号或双引号。</p><p>第六种索引失效情况：<strong>参数类型与字段类型不匹配，导致类型发生了隐式转换，索引失效</strong>。</p><p>这种情况还有一个特例，如果字段类型为int类型，而查询条件添加了单引号或双引号，则Mysql会参数转化为int类型，虽然使用了单引号或双引号：</p><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id = <span class="hljs-string">&#x27;2&#x27;</span>;</code></pre></div><p>上述语句是依旧会走索引的。</p><h2 id="7、使用OR操作"><a href="#7、使用OR操作" class="headerlink" title="7、使用OR操作"></a>7、使用OR操作</h2><p>OR是日常使用最多的操作关键字了，但使用不当，也会导致索引失效。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id = 2 or username = &#x27;Tom2&#x27;;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469462" alt="or-索引"></p><p>看到上述执行结果是否是很惊奇啊，明明id字段是有索引的，由于使用<code>or</code>关键字，索引竟然失效了。</p><p>其实，换一个角度来想，如果单独使用<code>username</code>字段作为条件很显然是全表扫描，既然已经进行了全表扫描了，前面<code>id</code>的条件再走一次索引反而是浪费了。所以，在使用or关键字时，切记两个条件都要添加索引，否则会导致索引失效。</p><p>但如果or两边同时使用“&gt;”和“&lt;”，则索引也会失效：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id  &gt; 1 or id  &lt; 80;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469463" alt="or-范围"></p><p>第七种索引失效情况：<strong>查询条件使用or关键字，其中一个字段没有创建索引，则会导致整个查询语句索引失效； or两边为“&gt;”和“&lt;”范围查询时，索引失效</strong>。</p><h2 id="8-两列做比较"><a href="#8-两列做比较" class="headerlink" title="8 两列做比较"></a>8 两列做比较</h2><p>如果两个列数据都有索引，但在查询条件中对两列数据进行了对比操作，则会导致索引失效。</p><p>这里举个不恰当的示例，比如age小于id这样的两列（真实场景可能是两列同维度的数据比较，这里迁就现有表结构）：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id &gt; age;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469464" alt="索引-两列比较"></p><p>这里虽然id有索引，age也可以创建索引，但当两列做比较时，索引还是会失效的。</p><p>第八种索引失效情况：<strong>两列数据做比较，即便两列都创建了索引，索引也会失效</strong>。</p><h2 id="9-不等于比较"><a href="#9-不等于比较" class="headerlink" title="9 不等于比较"></a>9 不等于比较</h2><p>示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no &lt;&gt; &#x27;1002&#x27;;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469465" alt="索引-不等"></p><p>当查询条件为字符串时，使用”&lt;&gt;“或”!&#x3D;“作为条件查询，有可能不走索引，但也不全是。</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where create_time != &#x27;2022-02-27 09:56:42&#x27;;</code></pre></div><p>上述SQL中，由于“2022-02-27 09:56:42”是存储过程在同一秒生成的，大量数据是这个时间。执行之后会发现，当查询结果集占比比较小时，会走索引，占比比较大时不会走索引。此处与结果集与总体的占比有关。</p><p>需要注意的是：上述语句如果是<code>id</code>进行不等操作，则正常走索引。</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id != 2;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469466" alt="不等-ID"></p><p>第九种索引失效情况：<strong>查询条件使用不等进行比较时，需要慎重，普通索引会查询结果集占比较大时索引会失效</strong>。</p><h2 id="10-is-not-null"><a href="#10-is-not-null" class="headerlink" title="10 is not null"></a>10 is not null</h2><p>示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no is not null;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469467" alt="索引-is not null"></p><p>第十种索引失效情况：<strong>查询条件使用is null时正常走索引，使用is not null时，不走索引</strong>。</p><h2 id="11-not-in和not-exists"><a href="#11-not-in和not-exists" class="headerlink" title="11 not in和not exists"></a>11 not in和not exists</h2><p>在日常中使用比较多的范围查询有in、exists、not in、not exists、between and等。</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id in (2,3);explain select * from t_user where id_no in (&#x27;1001&#x27;,&#x27;1002&#x27;);explain select * from t_user u1 where exists (select 1 from t_user u2 where u2.id  = 2 and u2.id = u1.id);explain select * from t_user where id_no between &#x27;1002&#x27; and &#x27;1003&#x27;;</code></pre></div><p>上述四种语句执行时都会正常走索引，具体的explain结果就不再展示。主要看不走索引的情况：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where id_no not in(&#x27;1002&#x27; , &#x27;1003&#x27;);</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469468" alt="索引-not in"></p><p>当使用<code>not in</code>时，不走索引？把条件列换成主键试试：</p><div class="code-wrapper"><pre><code class="hljs csharp">explain <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-keyword">not</span> <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-number">2</span>,<span class="hljs-number">3</span></span>)</span>;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469469" alt="主键-not in"></p><p>如果是主键，则正常走索引。</p><p>第十一种索引失效情况：<strong>查询条件使用not in时，如果是主键则走索引，如果是普通索引，则索引失效</strong>。</p><p>再来看看<code>not exists</code>：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user u1 where not exists (select 1 from t_user u2 where u2.id  = 2 and u2.id = u1.id);</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469470" alt="索引-not in"></p><p>当查询条件使用<code>not exists</code>时，不走索引。</p><p>第十二种索引失效情况：<strong>查询条件使用not exists时，索引失效</strong>。</p><h2 id="12-order-by导致索引失效"><a href="#12-order-by导致索引失效" class="headerlink" title="12 order by导致索引失效"></a>12 order by导致索引失效</h2><p>示例：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user order by id_no ;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469471" alt="索引-order by"></p><p>其实这种情况的索引失效很容易理解，毕竟需要对全表数据进行排序处理。</p><p>那么，添加删limit关键字是否就走索引了呢？</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user order by id_no limit 10;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469472" alt="order by limit"></p><p>结果依旧不走索引。在网络上看到有说如果<code>order by</code>条件满足最左匹配则会正常走索引， 在当前8.0.18版本中并未出现。所以，在基于<code>order by</code>和<code>limit</code>进行使用时，要特别留意。是否走索引不仅涉及到数据库版本，还要看Mysql优化器是如何处理的。</p><p>这里还有一个特例，就是主键使用<code>order by</code>时，可以正常走索引。</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user order by id desc;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469473" alt="主键-order by"></p><p>可以看出针对主键，还是<code>order by</code>可以正常走索引。</p><p>另外，笔者测试如下SQL语句：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select id from t_user order by age;explain select id , username from t_user order by age;explain select id_no from t_user order by id_no;</code></pre></div><p>上述三条SQL语句都是走索引的，也就是说覆盖索引的场景也是可以正常走索引的。</p><p>现在将<code>id</code>和<code>id_no</code>组合起来进行<code>order by</code>：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user order by id,id_no desc;explain select * from t_user order by id,id_no desc limit 10;explain select * from t_user order by id_no desc,username desc;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469474" alt="orderby多索引"></p><p>上述两个SQL语句，都未走索引。</p><p>第十三种索引失效情况：<strong>当查询条件涉及到order by、limit等条件时，是否走索引情况比较复杂，而且与Mysql版本有关，通常普通索引，如果未使用limit，则不会走索引。order by多个索引字段时，可能不会走索引。其他情况，建议在使用时进行expain验证。</strong></p><h2 id="13-参数不同导致索引失效"><a href="#13-参数不同导致索引失效" class="headerlink" title="13 参数不同导致索引失效"></a>13 参数不同导致索引失效</h2><p>此时，如果你还未执行最开始创建的存储过程，建议你先执行一下存储过程，然后执行如下SQL：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where create_time &gt; &#x27;2023-02-24 09:04:23&#x27;;</code></pre></div><p>其中，时间是未来的时间，确保能够查到数据。</p><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469475" alt="索引-参数"></p><p>可以看到，正常走索引。</p><p>随后，我们将查询条件的参数换个日期：</p><div class="code-wrapper"><pre><code class="hljs mysql">explain select * from t_user where create_time &gt; &#x27;2022-02-27 09:04:23&#x27;;</code></pre></div><p>explain结果：</p><p><img src="https://segmentfault.com/img/remote/1460000041469476" alt="索引-参数"></p><p>此时，进行了全表扫描。这也是最开始提到的奇怪的现象。</p><p>为什么同样的查询语句，只是查询的参数值不同，却会出现一个走索引，一个不走索引的情况呢？</p><p>答案很简单：<strong>上述索引失效是因为DBMS发现全表扫描比走索引效率更高，因此就放弃了走索引</strong>。</p><p>也就是说，当Mysql发现通过索引扫描的行记录数超过全表的10%-30%时，优化器可能会放弃走索引，自动变成全表扫描。某些场景下即便强制SQL语句走索引，也同样会失效。</p><p>类似的问题，在进行范围查询（比如&gt;、&lt; 、&gt;&#x3D;、&lt;&#x3D;、in等条件）时往往会出现上述情况，而上面提到的临界值根据场景不同也会有所不同。</p><p>第十四种索引失效情况：<strong>当查询条件为大于等于、in等范围查询时，根据查询结果占全表数据比例的不同，优化器有可能会放弃索引，进行全表扫描。</strong></p><h2 id="14-其他"><a href="#14-其他" class="headerlink" title="14 其他"></a>14 其他</h2><p>当然，还有其他一些是否走索引的规则，这与索引的类型是B-tree索引还是位图索引也有关系，就不再详细展开。</p><p>这里要说的其他，可以总结为第十五种索引失效的情况：<strong>Mysql优化器的其他优化策略，比如优化器认为在某些情况下，全表扫描比走索引快，则它就会放弃索引。</strong></p><p>针对这种情况，一般不用过多理会，当发现问题时再定点排查即可。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程学习</title>
    <link href="/2022/10/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/10/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、J-U-C-简介"><a href="#一、J-U-C-简介" class="headerlink" title="一、J.U.C 简介"></a>一、J.U.C 简介</h2><p>Java 的 <code>java.util.concurrent</code> 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为：</p><ul><li>原子类 - 如：<code>AtomicInteger</code>、<code>AtomicIntegerArray</code>、<code>AtomicReference</code>、<code>AtomicStampedReference</code> 等。</li><li>锁 - 如：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等。</li><li>并发容器 - 如：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 等。</li><li>阻塞队列 - 如：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li><li>非阻塞队列 - 如： <code>ConcurrentLinkedQueue</code> 、<code>LinkedTransferQueue</code> 等。</li><li><code>Executor</code> 框架（线程池）- 如：<code>ThreadPoolExecutor</code>、<code>Executors</code> 等。</li></ul><p>我个人理解，Java 并发框架可以分为以下层次。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f45c6acd9390cc~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>由 Java 并发框架图不难看出，J.U.C 包中的工具类是基于 <code>synchronized</code>、<code>volatile</code>、<code>CAS</code>、<code>ThreadLocal</code> 这样的并发核心机制打造的。所以，要想深入理解 J.U.C 工具类的特性、为什么具有这样那样的特性，就必须先理解这些核心机制。</p><h2 id="二、synchronized"><a href="#二、synchronized" class="headerlink" title="二、synchronized"></a>二、synchronized</h2><blockquote><p><code>synchronized</code> 是 Java 中的关键字，是 <strong>利用锁的机制来实现互斥同步的</strong>。</p><p><strong><code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>。</p><p>如果不需要 <code>Lock</code> 、<code>ReadWriteLock</code> 所提供的高级同步特性，应该优先考虑使用 <code>synchronized</code> ，理由如下：</p><ul><li>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平。从趋势来看，Java 未来仍将继续优化 <code>synchronized</code> ，而不是 <code>ReentrantLock</code> 。</li><li><code>ReentrantLock</code> 是 Oracle JDK 的 API，在其他版本的 JDK 中不一定支持；而 <code>synchronized</code> 是 JVM 的内置特性，所有 JDK 版本都提供支持。</li></ul></blockquote><h3 id="synchronized-的用法"><a href="#synchronized-的用法" class="headerlink" title="synchronized 的用法"></a>synchronized 的用法</h3><p><code>synchronized</code> 有 3 种应用方式：</p><ul><li><strong>同步实例方法</strong> - 对于普通同步方法，锁是当前实例对象</li><li><strong>同步静态方法</strong> - 对于静态同步方法，锁是当前类的 <code>Class</code> 对象</li><li><strong>同步代码块</strong> - 对于同步方法块，锁是 <code>synchonized</code> 括号里配置的对象</li></ul><blockquote><p>说明：</p><p>类似 <code>Vector</code>、<code>Hashtable</code> 这类同步类，就是使用 <code>synchonized</code> 修饰其重要方法，来保证其线程安全。</p><p>事实上，这类同步容器也非绝对的线程安全，当执行迭代器遍历，根据条件删除元素这种场景下，就可能出现线程不安全的情况。此外，Java 1.6 针对 <code>synchonized</code> 进行优化前，由于阻塞，其性能不高。</p><p>综上，这类同步容器，在现代 Java 程序中，已经渐渐不用了。</p></blockquote><h4 id="同步实例方法"><a href="#同步实例方法" class="headerlink" title="同步实例方法"></a>同步实例方法</h4><p>❌ 错误示例 - 未同步的示例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoSynchronizedDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">NoSynchronizedDemo</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSynchronizedDemo</span>();        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX; i++) &#123;            increase();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;        count++;    &#125;&#125;<span class="hljs-comment">// 输出结果: 小于 200000 的随机数字</span></code></pre></div><p>Java 实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">SynchronizedDemo</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedDemo</span>();        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX; i++) &#123;            increase();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * synchronized 修饰普通方法</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;        count++;    &#125;&#125;</code></pre></div><h4 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h4><p>静态方法的同步是指同步在该方法所在的类对象上。因为在 JVM 中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p><p>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">SynchronizedDemo2</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedDemo2</span>();        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX; i++) &#123;            increase();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * synchronized 修饰静态方法</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;        count++;    &#125;&#125;</code></pre></div><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>有时你不需要同步整个方法，而是同步方法中的一部分。Java 可以对方法的一部分进行同步。</p><p>注意 Java 同步块构造器用括号将对象括起来。在上例中，使用了 <code>this</code>，即为调用 add 方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p><p>一次只有一个线程能够在同步于同一个监视器对象的 Java 方法内执行。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">SynchronizedDemo3</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedDemo3</span>();        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX; i++) &#123;            increase();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * synchronized 修饰代码块</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">synchronized</span> (SynchronizedDemo3.class) &#123;            count++;        &#125;    &#125;&#125;</code></pre></div><h3 id="synchronized-的原理"><a href="#synchronized-的原理" class="headerlink" title="synchronized 的原理"></a>synchronized 的原理</h3><p><code>synchronized</code> 经过编译后，会在同步块的前后分别形成 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。如果 <code>synchronized</code> 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 <code>synchronized</code> 修饰的是实例方法还是静态方法，去对对应的对象实例或 Class 对象来作为锁对象。</p><p><code>synchronized</code> 同步块对同一线程来说是可重入的，不会出现锁死问题。</p><p><code>synchronized</code> 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。</p><h4 id="锁的机制"><a href="#锁的机制" class="headerlink" title="锁的机制"></a>锁的机制</h4><p>锁具备以下两种特性：</p><ul><li><strong>互斥性</strong>：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</li><li><strong>可见性</strong>：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</li></ul><h4 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h4><ul><li><strong>对象锁</strong> - 在 Java 中，每个对象都会有一个 <code>monitor</code> 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</li><li><strong>类锁</strong> - 在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</li></ul><h3 id="synchronized-的优化"><a href="#synchronized-的优化" class="headerlink" title="synchronized 的优化"></a>synchronized 的优化</h3><blockquote><p>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平。</p></blockquote><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 Java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p><strong>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除</strong>。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;    <span class="hljs-keyword">return</span> s1 + s2 + s3;&#125;</code></pre></div><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 Java 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();    sb.append(s1);    sb.append(s2);    sb.append(s3);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre></div><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果<strong>一系列的连续操作都对同一个对象反复加锁和解锁</strong>，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果<strong>虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</strong>。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>Java 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：</p><ul><li><strong>无锁状态（unlocked）</strong></li><li><strong>偏向锁状态（biasble）</strong></li><li><strong>轻量级锁状态（lightweight locked）</strong></li><li><strong>重量级锁状态（inflated）</strong></li></ul><p><strong>轻量级锁</strong>是相对于传统的重量级锁而言，它 <strong>使用 CAS 操作来避免重量级锁使用互斥量的开销</strong>。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的思想是偏向于<strong>让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要</strong>。</p><h2 id="三、volatile"><a href="#三、volatile" class="headerlink" title="三、volatile"></a>三、volatile</h2><h3 id="volatile-的要点"><a href="#volatile-的要点" class="headerlink" title="volatile 的要点"></a>volatile 的要点</h3><p>volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。</p><p>可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ol><p>如果一个字段被声明成 volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的。</p><h3 id="volatile-的用法"><a href="#volatile-的用法" class="headerlink" title="volatile 的用法"></a>volatile 的用法</h3><p>如果 <code>volatile</code> 变量修饰符使用恰当的话，它比 <code>synchronized</code> 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但是，<code>volatile</code> 无法替代 <code>synchronized</code> ，因为 <code>volatile</code> 无法保证操作的原子性。</p><p>通常来说，<strong>使用 <code>volatile</code> 必须具备以下 2 个条件</strong>：</p><ul><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p>示例：状态标记量</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">while</span>(!flag) &#123;    doSomething();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFlag</span><span class="hljs-params">()</span> &#123;    flag = <span class="hljs-literal">true</span>;&#125;</code></pre></div><p>示例：双重锁实现线程安全的单例类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;                <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre></div><h3 id="volatile-的原理"><a href="#volatile-的原理" class="headerlink" title="volatile 的原理"></a>volatile 的原理</h3><p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，<strong>加入 <code>volatile</code> 关键字时，会多出一个 <code>lock</code> 前缀指令</strong>。</p><p><strong><code>lock</code> 前缀指令实际上相当于一个内存屏障</strong>（也成内存栅栏），内存屏障会提供 3 个功能：</p><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li></ul><h2 id="四、CAS"><a href="#四、CAS" class="headerlink" title="四、CAS"></a>四、CAS</h2><h3 id="CAS-的要点"><a href="#CAS-的要点" class="headerlink" title="CAS 的要点"></a>CAS 的要点</h3><p>互斥同步是最常见的并发正确性保障手段。</p><p><strong>互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题</strong>，因此互斥同步也被称为阻塞同步。互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>为什么说乐观锁需要 <strong>硬件指令集的发展</strong> 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。硬件支持的原子性操作最典型的是：CAS。</p><p><strong>CAS（Compare and Swap）</strong>，字面意思为<strong>比较并交换</strong>。CAS 有 3 个操作数，分别是：内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p><h3 id="CAS-的原理"><a href="#CAS-的原理" class="headerlink" title="CAS 的原理"></a>CAS 的原理</h3><p>Java 是如何实现 CAS ?</p><p>Java 主要利用 <code>Unsafe</code> 这个类提供的 CAS 操作。</p><p><code>Unsafe</code> 的 CAS 依赖的是 JV M 针对不同的操作系统实现的 <code>Atomic::cmpxchg</code> 指令。</p><p><code>Atomic::cmpxchg</code> 的实现使用了汇编的 CAS 操作，并使用 CPU 提供的 <code>lock</code> 信号保证其原子性。</p><h3 id="CAS-的应用"><a href="#CAS-的应用" class="headerlink" title="CAS 的应用"></a>CAS 的应用</h3><h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><blockquote><p>原子类是 CAS 在 Java 中最典型的应用。</p></blockquote><p>我们先来看一个常见的代码片段。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(a==b) &#123;    a++;&#125;</code></pre></div><p>如果 <code>a++</code> 执行前， a 的值被修改了怎么办？还能得到预期值吗？出现该问题的原因是在并发环境下，以上代码片段不是原子操作，随时可能被其他线程所篡改。</p><p>解决这种问题的最经典方式是应用原子类的 <code>incrementAndGet</code> 方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                    count.incrementAndGet();                &#125;            &#125;);        &#125;        executorService.shutdown();        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);        System.out.println(<span class="hljs-string">&quot;Final Count is : &quot;</span> + count.get());    &#125;&#125;</code></pre></div><p>J.U.C 包中提供了 <code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 分别针对 <code>Boolean</code>、<code>Integer</code>、<code>Long</code> 执行原子操作，操作和上面的示例大体相似，不做赘述。</p><h4 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>利用原子类（本质上是 CAS），可以实现自旋锁。</p><p>所谓自旋锁，是指线程反复检查锁变量是否可用，直到成功为止。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p><p>示例：非线程安全示例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());        &#125;        executorService.shutdown();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 卖出了第 &quot;</span> + ticket + <span class="hljs-string">&quot; 张票&quot;</span>);                ticket--;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs apache">复制代码<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">10</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">10</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">10</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">8</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">9</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">6</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">7</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">4</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">5</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">2</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">3</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">1</span> 张票</code></pre></div><p>很明显，出现了重复售票的情况。</p><p>示例：使用自旋锁来保证线程安全</p><p>可以通过自旋锁这种非阻塞同步来保证线程安全，下面使用 <code>AtomicReference</code> 来实现一个自旋锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo2</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        threadSafeDemo();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadSafeDemo</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">SpinLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpinLock</span>();        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(lock));        &#125;        executorService.shutdown();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLock</span> &#123;        <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();            <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, current)) &#123;&#125;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();            atomicReference.compareAndSet(current, <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;        <span class="hljs-keyword">private</span> SpinLock lock;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(SpinLock lock)</span> &#123;            <span class="hljs-built_in">this</span>.lock = lock;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                lock.lock();                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 卖出了第 &quot;</span> + ticket + <span class="hljs-string">&quot; 张票&quot;</span>);                    ticket--;                &#125;                lock.unlock();            &#125;        &#125;    &#125;&#125;</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs apache">复制代码<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">10</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">9</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">8</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">7</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">6</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">5</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">4</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">3</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">2</span> 张票<span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">1</span> 张票</code></pre></div><h3 id="CAS-的问题"><a href="#CAS-的问题" class="headerlink" title="CAS 的问题"></a>CAS 的问题</h3><p>一般情况下，CAS 比锁性能更高。因为 CAS 是一种非阻塞算法，所以其避免了线程阻塞和唤醒的等待时间。</p><p>但是，CAS 也有一些问题。</p><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 <code>AtomicStampedReference</code> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋 CAS （不断尝试，直到成功为止）如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 <code>pause</code> 指令那么效率会有一定的提升，<code>pause</code> 指令有两个作用：</p><ul><li>它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</li></ul><p>比较花费 CPU 资源，即使没有任何用也会做一些无用功。</p><h4 id="只能保证一个共享变量的原子性"><a href="#只能保证一个共享变量的原子性" class="headerlink" title="只能保证一个共享变量的原子性"></a>只能保证一个共享变量的原子性</h4><p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p><p>或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 <code>i ＝ 2, j = a</code>，合并一下 <code>ij=2a</code>，然后用 CAS 来操作 <code>ij</code>。从 Java 1.5 开始 JDK 提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p><h2 id="五、ThreadLocal"><a href="#五、ThreadLocal" class="headerlink" title="五、ThreadLocal"></a>五、ThreadLocal</h2><blockquote><p><strong><code>ThreadLocal</code> 是一个存储线程本地副本的工具类</strong>。</p><p>要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。</p><p>Java 中的 <strong>无同步方案</strong> 有：</p><ul><li><strong>可重入代码</strong> - 也叫纯代码。如果一个方法，它的 <strong>返回结果是可以预测的</strong>，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。</li><li><strong>线程本地存储</strong> - 使用 <strong><code>ThreadLocal</code> 为共享变量在每个线程中都创建了一个本地副本</strong>，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。</li></ul></blockquote><h3 id="ThreadLocal-的用法"><a href="#ThreadLocal-的用法" class="headerlink" title="ThreadLocal 的用法"></a>ThreadLocal 的用法</h3><p><code>ThreadLocal</code> 的方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="hljs-title function_">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;&#125;&#125;</code></pre></div><blockquote><p>说明：</p><ul><li><code>get</code> - 用于获取 <code>ThreadLocal</code> 在当前线程中保存的变量副本。</li><li><code>set</code> - 用于设置当前线程中变量的副本。</li><li><code>remove</code> - 用于删除当前线程中变量的副本。如果此线程局部变量随后被当前线程读取，则其值将通过调用其 <code>initialValue</code> 方法重新初始化，除非其值由中间线程中的当前线程设置。 这可能会导致当前线程中多次调用 <code>initialValue</code> 方法。</li><li><code>initialValue</code> - 为 ThreadLocal 设置默认的 <code>get</code> 初始值，需要重写 <code>initialValue</code> 方法 。</li></ul></blockquote><p><code>ThreadLocal</code> 常用于防止对可变的单例（Singleton）变量或全局变量进行共享。典型应用场景有：管理数据库连接、Session。</p><p>示例 - 数据库连接</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Connection&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> DriverManager.getConnection(DB_URL);    &#125;&#125;;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> connectionHolder.get();&#125;</code></pre></div><p>示例 - Session 管理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Session&gt; sessionHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> (Session) sessionHolder.get();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;            session = createSession();            sessionHolder.set(session);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> session;&#125;</code></pre></div><p>示例 - 完整使用示例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());        &#125;        executorService.shutdown();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> threadLocal.get();            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    count++;                    Thread.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            threadLocal.set(count);            threadLocal.remove();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + count);        &#125;    &#125;&#125;</code></pre></div><p>全部输出 count &#x3D; 10</p><h3 id="ThreadLocal-的原理"><a href="#ThreadLocal-的原理" class="headerlink" title="ThreadLocal 的原理"></a>ThreadLocal 的原理</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p><code>Thread</code> 类中维护着一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员 <code>threadLocals</code>。这个成员就是用来存储线程独占的变量副本。</p><p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的内部类，它维护着一个 <code>Entry</code> 数组， <code>Entry</code> 用于保存键值对，其 key 是 <code>ThreadLocal</code> 对象，value 是传递进来的对象（变量副本）。</p><h4 id="如何解决-Hash-冲突"><a href="#如何解决-Hash-冲突" class="headerlink" title="如何解决 Hash 冲突"></a>如何解决 Hash 冲突</h4><p><code>ThreadLocalMap</code> 虽然是类似 <code>Map</code> 结构的数据结构，但它并没有实现 <code>Map</code> 接口。它不支持 <code>Map</code> 接口中的 <code>next</code> 方法，这意味着 <code>ThreadLocalMap</code> 中解决 Hash 冲突的方式并非 <strong>拉链表</strong> 方式。</p><p>实际上，**<code>ThreadLocalMap</code> 采用线性探测的方式来解决 Hash 冲突**。所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p><h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p>ThreadLocalMap 的 <code>Entry</code> 继承了 <code>WeakReference</code>，所以它的 key （<code>ThreadLocal</code> 对象）是弱引用，而 value （变量副本）是强引用。</p><ul><li>如果 <code>ThreadLocal</code> 对象没有外部强引用来引用它，那么 <code>ThreadLocal</code> 对象会在下次 GC 时被回收。</li><li>此时，<code>Entry</code> 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 <code>ThreadLocal</code> 的线程一直持续运行，那么 value 就会一直得不到回收，产生内存泄露。</li></ul><p>那么如何避免内存泄漏呢？方法就是：<strong>使用 <code>ThreadLocal</code> 的 <code>set</code> 方法后，显示的调用 <code>remove</code> 方法</strong> 。</p><div class="code-wrapper"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<span class="hljs-keyword">try</span> &#123;    threadLocal.set(<span class="hljs-string">&quot;xxx&quot;</span>);    <span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">finally</span> &#123;    threadLocal.remove();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射学习</title>
    <link href="/2022/09/29/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/29/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是反射？"><a href="#一、什么是反射？" class="headerlink" title="一、什么是反射？"></a>一、什么是反射？</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><blockquote><p>简单的来说： 1.通过new关键字创建对象操作对象，在编译时就已经确定。 2.通过反射可以在程序运行过程中动态的操作对象，可以获得编译期无法获得的信息，动态操作最大限度发挥了java扩展性。</p></blockquote><h2 id="二、反射原理"><a href="#二、反射原理" class="headerlink" title="二、反射原理"></a>二、反射原理</h2><p>Java反射的原理:java类的执行需要经历以下过程：</p><ul><li>编译：.java文件编译后生成.class字节码文件</li><li>加载：类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例</li><li>链接 <code>验证</code>：格式（class文件规范） 语义（final类是否有子类） 操作 <code>准备</code>：静态变量赋初值和内存空间，final修饰的内存空间直接赋原值，此处不是用户指定的初值。 <code>解析</code>：符号引用转化为直接引用，分配地址</li><li>初始化：有父类先初始化父类，然后初始化自己；将static修饰代码执行一遍，如果是静态变量，则用用户指定值覆盖原有初值；如果是代码块，则执行一遍操作。</li></ul><p>Java的反射就是利用上面第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。</p><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。总结说：反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。</p><h2 id="三、反射机制相关"><a href="#三、反射机制相关" class="headerlink" title="三、反射机制相关"></a>三、反射机制相关</h2><p>与Java反射相关的类如下：</p><table><thead><tr><th>类名</th><th>用途</th></tr></thead><tbody><tr><td>Class类</td><td>代表类的实体，在运行的Java应用程序中表示类和接口</td></tr><tr><td>Field类</td><td>代表类的成员变量（成员变量也称为类的属性）</td></tr><tr><td>Method类</td><td>代表类的方法</td></tr><tr><td>Constructor类</td><td>代表类的构造方法</td></tr></tbody></table><p>反射可访问的常用信息</p><table><thead><tr><th>类型</th><th>访问方法</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>包路径</td><td>getPackage()</td><td>Package 对象</td><td>获取该类的存放路径</td></tr><tr><td>类名称</td><td>getName()</td><td>String 对象</td><td>获取该类的名称</td></tr><tr><td>继承类</td><td>getSuperclass()</td><td>Class 对象</td><td>获取该类继承的类</td></tr><tr><td>实现接口</td><td>getlnterfaces()</td><td>Class 型数组</td><td>获取该类实现的所有接口</td></tr><tr><td>构造方法</td><td>getConstructors()</td><td>Constructor 型数组</td><td>获取所有权限为 public 的构造方法</td></tr><tr><td>构造方法</td><td>getDeclaredContruectors()</td><td>Constructor 对象</td><td>获取当前对象的所有构造方法</td></tr><tr><td>方法</td><td>getMethods()</td><td>Methods 型数组</td><td>获取所有权限为 public 的方法</td></tr><tr><td>方法</td><td>getDeclaredMethods()</td><td>Methods 对象</td><td>获取当前对象的所有方法</td></tr><tr><td>成员变量</td><td>getFields()</td><td>Field 型数组</td><td>获取所有权限为 public 的成员变量</td></tr><tr><td>成员变量</td><td>getDeclareFileds()</td><td>Field 对象</td><td>获取当前对象的所有成员变量</td></tr><tr><td>内部类</td><td>getClasses()</td><td>Class 型数组</td><td>获取所有权限为 public 的内部类</td></tr><tr><td>内部类</td><td>getDeclaredClasses()</td><td>Class 型数组</td><td>获取所有内部类</td></tr><tr><td>内部类的声明类</td><td>getDeclaringClass()</td><td>Class 对象</td><td>如果该类为内部类，则返回它的成员类，否则返回 null</td></tr></tbody></table><p>Java 反射机制主要提供了以下功能，这些功能都位于java.lang.reflect包。</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><h2 id="四、反射的使用"><a href="#四、反射的使用" class="headerlink" title="四、反射的使用"></a>四、反射的使用</h2><h3 id="1、java中的Class三种获取方式"><a href="#1、java中的Class三种获取方式" class="headerlink" title="1、java中的Class三种获取方式"></a>1、java中的Class三种获取方式</h3><p> jdk提供了三种方式获取一个对象的Class，就Person person 来说</p><p>  1.person .getClass()，这个是Object类里面的方法</p><p>  2.Person .Class属性，任何的数据类型，基本数据类型或者抽象数据类型，都可以通过这种方式获取类</p><p>  3.Class.forName(“”)，Class类提供了这样一个方法，让我们通过类名来获取到对象类</p><p> 说明：在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已被加载到内存，就可以用它来产生该类型的所有对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&gt; personClazz01 = person.getClass();     <span class="hljs-comment">//方式二</span>    <span class="hljs-keyword">try</span> &#123;        Class&lt;?&gt; personClazz02 = Class.forName(<span class="hljs-string">&quot;Person&quot;</span>);    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;     <span class="hljs-comment">//方式三</span>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&gt; personClazz03 = Person.class;</code></pre></div><h3 id="2、如何通过反射获取私有成员变量和私有方法"><a href="#2、如何通过反射获取私有成员变量和私有方法" class="headerlink" title="2、如何通过反射获取私有成员变量和私有方法"></a>2、如何通过反射获取私有成员变量和私有方法</h3><p>Person类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zhangsan&quot;</span>;<span class="hljs-keyword">private</span> String age; <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> name;&#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;    <span class="hljs-built_in">this</span>.name = name;&#125;&#125;        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();    <span class="hljs-comment">//打印没有改变属性之前的name值</span>    System.out.println(<span class="hljs-string">&quot;before：&quot;</span> + getPrivateValue(person, <span class="hljs-string">&quot;name&quot;</span>));    person.setName(<span class="hljs-string">&quot;lisi&quot;</span>);    <span class="hljs-comment">//打印修改之后的name值</span>    System.out.println(<span class="hljs-string">&quot;after：&quot;</span> + getPrivateValue(person, <span class="hljs-string">&quot;name&quot;</span>));   <span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过反射获取私有的成员变量</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> person</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">getPrivateValue</span><span class="hljs-params">(Person person, String fieldName)</span> &#123;     <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> person.getClass().getDeclaredField(fieldName);        <span class="hljs-comment">// 参数值为true，打开禁用访问控制检查</span>        <span class="hljs-comment">//setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。</span>        <span class="hljs-comment">//所以即使是public方法，其accessible 属相默认也是false</span>        field.setAccessible(<span class="hljs-literal">true</span>);        <span class="hljs-keyword">return</span> field.get(person);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><p>运行结果</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/4/16f6f61e9859659d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="图片.png"></p><h3 id="实例demo"><a href="#实例demo" class="headerlink" title="实例demo"></a>实例demo</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<span class="hljs-keyword">import</span> java.lang.reflect.TypeVariable; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 为了看清楚Java反射部分代码，所有异常我都最后抛出来给虚拟机处理！</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalAccessException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InvocationTargetException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NoSuchFieldException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> SecurityException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NoSuchMethodException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-comment">//Demo1.  通过Java反射机制得到类的包名和类名</span>Demo1();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//Demo2.  验证所有的类都是Class类的实例对象</span>Demo2();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//Demo3.  通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]，无参构造</span>Demo3();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//Demo4:  通过Java反射机制得到一个类的构造函数，并实现构造带参实例对象</span>Demo4();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//Demo5:  通过Java反射机制操作成员变量, set 和 get</span>Demo5();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等</span>Demo6();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//Demo7: 通过Java反射机制调用类中方法</span>Demo7();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//Demo8: 通过Java反射机制获得类加载器</span>Demo8();System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo1: 通过Java反射机制得到类的包名和类名</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo1</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();System.out.println(<span class="hljs-string">&quot;Demo1: 包名: &quot;</span> + person.getClass().getPackage().getName() + <span class="hljs-string">&quot;，&quot;</span> + <span class="hljs-string">&quot;完整类名: &quot;</span> + person.getClass().getName());&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo2: 验证所有的类都是Class类的实例对象</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<span class="hljs-comment">//定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类</span>Class&lt;?&gt; class1 = <span class="hljs-literal">null</span>;        Class&lt;?&gt; class2 = <span class="hljs-literal">null</span>;                <span class="hljs-comment">//写法1, 可能抛出 ClassNotFoundException [多用这个写法]</span>        class1 = Class.forName(<span class="hljs-string">&quot;cn.lee.demo.Person&quot;</span>);        System.out.println(<span class="hljs-string">&quot;Demo2:(写法1) 包名: &quot;</span> + class1.getPackage().getName() + <span class="hljs-string">&quot;，&quot;</span> + <span class="hljs-string">&quot;完整类名: &quot;</span> + class1.getName());                <span class="hljs-comment">//写法2</span>        class2 = Person.class;        System.out.println(<span class="hljs-string">&quot;Demo2:(写法2) 包名: &quot;</span> + class2.getPackage().getName() + <span class="hljs-string">&quot;，&quot;</span> + <span class="hljs-string">&quot;完整类名: &quot;</span> + class2.getName());&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalAccessException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException&#123;Class&lt;?&gt; class1 = <span class="hljs-literal">null</span>;class1 = Class.forName(<span class="hljs-string">&quot;cn.lee.demo.Person&quot;</span>);<span class="hljs-comment">//由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～</span><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) class1.newInstance();person.setAge(<span class="hljs-number">20</span>);person.setName(<span class="hljs-string">&quot;LeeFeng&quot;</span>);System.out.println(<span class="hljs-string">&quot;Demo3: &quot;</span> + person.getName() + <span class="hljs-string">&quot; : &quot;</span> + person.getAge());&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InvocationTargetException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalAccessException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException&#123;Class&lt;?&gt; class1 = <span class="hljs-literal">null</span>;<span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;class1 = Class.forName(<span class="hljs-string">&quot;cn.lee.demo.Person&quot;</span>);<span class="hljs-comment">//得到一系列构造函数集合</span>Constructor&lt;?&gt;[] constructors = class1.getConstructors();person1 = (Person) constructors[<span class="hljs-number">0</span>].newInstance();person1.setAge(<span class="hljs-number">30</span>);person1.setName(<span class="hljs-string">&quot;leeFeng&quot;</span>);person2 = (Person) constructors[<span class="hljs-number">1</span>].newInstance(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;leeFeng&quot;</span>);System.out.println(<span class="hljs-string">&quot;Demo4: &quot;</span> + person1.getName() + <span class="hljs-string">&quot; : &quot;</span> + person1.getAge()+ <span class="hljs-string">&quot;  ,   &quot;</span> + person2.getName() + <span class="hljs-string">&quot; : &quot;</span> + person2.getAge());&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo5: 通过Java反射机制操作成员变量, set 和 get</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalAccessException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NoSuchFieldException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> SecurityException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException&#123;Class&lt;?&gt; class1 = <span class="hljs-literal">null</span>;class1 = Class.forName(<span class="hljs-string">&quot;cn.lee.demo.Person&quot;</span>);<span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> class1.newInstance();<span class="hljs-type">Field</span> <span class="hljs-variable">personNameField</span> <span class="hljs-operator">=</span> class1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);personNameField.setAccessible(<span class="hljs-literal">true</span>);personNameField.set(obj, <span class="hljs-string">&quot;胖虎先森&quot;</span>);System.out.println(<span class="hljs-string">&quot;Demo5: 修改属性之后得到属性变量的值：&quot;</span> + personNameField.get(obj));&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;Class&lt;?&gt; class1 = <span class="hljs-literal">null</span>;class1 = Class.forName(<span class="hljs-string">&quot;cn.lee.demo.SuperMan&quot;</span>);<span class="hljs-comment">//取得父类名称</span>Class&lt;?&gt;  superClass = class1.getSuperclass();System.out.println(<span class="hljs-string">&quot;Demo6:  SuperMan类的父类名: &quot;</span> + superClass.getName());System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);Field[] fields = class1.getDeclaredFields();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;System.out.println(<span class="hljs-string">&quot;类中的成员: &quot;</span> + fields[i]);&#125;System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//取得类方法</span>Method[] methods = class1.getDeclaredMethods();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; methods.length; i++) &#123;System.out.println(<span class="hljs-string">&quot;Demo6,取得SuperMan类的方法：&quot;</span>);System.out.println(<span class="hljs-string">&quot;函数名：&quot;</span> + methods[i].getName());System.out.println(<span class="hljs-string">&quot;函数返回类型：&quot;</span> + methods[i].getReturnType());System.out.println(<span class="hljs-string">&quot;函数访问修饰符：&quot;</span> + Modifier.toString(methods[i].getModifiers()));System.out.println(<span class="hljs-string">&quot;函数代码写法： &quot;</span> + methods[i]);&#125;System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<span class="hljs-comment">//取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈</span>Class&lt;?&gt; interfaces[] = class1.getInterfaces();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; interfaces.length; i++) &#123;System.out.println(<span class="hljs-string">&quot;实现的接口类名: &quot;</span> + interfaces[i].getName() );&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo7: 通过Java反射机制调用类方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NoSuchMethodException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> SecurityException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InvocationTargetException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalAccessException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo7</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException&#123;Class&lt;?&gt; class1 = <span class="hljs-literal">null</span>;class1 = Class.forName(<span class="hljs-string">&quot;cn.lee.demo.SuperMan&quot;</span>);System.out.println(<span class="hljs-string">&quot;Demo7: \n调用无参方法fly()：&quot;</span>);<span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> class1.getMethod(<span class="hljs-string">&quot;fly&quot;</span>);method.invoke(class1.newInstance());System.out.println(<span class="hljs-string">&quot;调用有参方法walk(int m)：&quot;</span>);method = class1.getMethod(<span class="hljs-string">&quot;walk&quot;</span>,<span class="hljs-type">int</span>.class);method.invoke(class1.newInstance(),<span class="hljs-number">100</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Demo8: 通过Java反射机制得到类加载器信息</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 在java中有三种类类加载器。[这段资料网上截取]</span><span class="hljs-comment">1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。</span><span class="hljs-comment">2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类</span><span class="hljs-comment">3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo8</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;Class&lt;?&gt; class1 = <span class="hljs-literal">null</span>;class1 = Class.forName(<span class="hljs-string">&quot;cn.lee.demo.SuperMan&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">nameString</span> <span class="hljs-operator">=</span> class1.getClassLoader().getClass().getName();System.out.println(<span class="hljs-string">&quot;Demo8: 类加载器类名: &quot;</span> + nameString);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaoyaomeng</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Person</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span>&#123;<span class="hljs-built_in">this</span>.age = age;<span class="hljs-built_in">this</span>.name = name;&#125; <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> age;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<span class="hljs-built_in">this</span>.age = age;&#125;<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<span class="hljs-built_in">this</span>.name = name;&#125;&#125; <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionInterface</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> BlueBriefs;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;超人会飞耶～～&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlueBriefs</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> BlueBriefs;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlueBriefs</span><span class="hljs-params">(<span class="hljs-type">boolean</span> blueBriefs)</span> &#123;BlueBriefs = blueBriefs;&#125; <span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">&quot;超人会走耶～～走了&quot;</span> + m + <span class="hljs-string">&quot;米就走不动了！&quot;</span>);&#125;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ActionInterface</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>;&#125;</code></pre></div><h2 id="五、java反射调用service或mapper中的接口"><a href="#五、java反射调用service或mapper中的接口" class="headerlink" title="五、java反射调用service或mapper中的接口"></a>五、java反射调用service或mapper中的接口</h2><p>java中的反射需要一个实例，但是接口无法提供这样的实例，但是JDK提供了一个叫做动态代理的东西，这个代理恰恰只能代理接口。所以我们想要反射接口需要使用这个动态代理来做。</p><p>在java的动态代理机制中，有两个重要的东西，一个是 InvocationHandler(接口)、另一个则是 Proxy(类)，这是我们动态代理必须用到的两个东西。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>先来看一下静态代理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStaticProxy</span> &#123;    <span class="hljs-comment">//这里传入的是接口类型的对象，方便向上转型，实现多态</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(ProxyInterface pi)</span>&#123;        pi.say();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        consumer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyObject</span>());    &#125;&#125;<span class="hljs-comment">//代理接口</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProxyInterface</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>;&#125;<span class="hljs-comment">//被代理者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProxyInterface</span>&#123;    <span class="hljs-comment">//实现接口方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        System.out.println(<span class="hljs-string">&quot;say&quot;</span>);    &#125;    &#125;<span class="hljs-comment">//代理者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProxyInterface</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        <span class="hljs-comment">//dosomething for example</span>        System.out.println(<span class="hljs-string">&quot;hello proxy&quot;</span>);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObject</span>().say();        System.out.println(<span class="hljs-string">&quot;this is method end&quot;</span>);    &#125;    &#125;output:hello proxysay<span class="hljs-built_in">this</span> is method end</code></pre></div><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestActiveProxy</span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customer</span><span class="hljs-params">(ProxyInterface pi)</span>&#123;        pi.say();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">RealObject</span> <span class="hljs-variable">real</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObject</span>();        <span class="hljs-type">ProxyInterface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (ProxyInterface)Proxy.newProxyInstance(ProxyInterface.class.getClassLoader(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;ProxyInterface.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyObject</span>(real));        customer(proxy);    &#125;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProxyInterface</span>&#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>;&#125;<span class="hljs-comment">//被代理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProxyInterface</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;i&#x27;m talking&quot;</span>);    &#125;&#125;<span class="hljs-comment">//代理类，实现InvocationHandler 接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">proxied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyObject</span><span class="hljs-params">()</span>&#123;            &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyObject</span><span class="hljs-params">(Object proxied)</span>&#123;        <span class="hljs-built_in">this</span>.proxied  = proxied;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object arg0, Method arg1, Object[] arg2)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);        <span class="hljs-keyword">return</span> arg1.invoke(proxied, arg2);    &#125;;&#125;</code></pre></div><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>假如现在我们需要通过反射得到<code>TestMapper</code>接口，然后调用其中的一个<code>selectById</code>方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestMapper</span>&#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">            * 根据id查对象</span><span class="hljs-comment">            */</span>            User  <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id)</span>;    &#125;</code></pre></div><p>现在如果我们需要反射使用该接口根据用户ID获取用户对象是无法直接反射调取的，所以我们需要一个动态代理类。 创建一个<code>MyInvocationHandler</code>实现<code>InvocationHandler</code>接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;    <span class="hljs-keyword">private</span> Object target;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;        <span class="hljs-built_in">this</span>.target = target;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-keyword">return</span> method.invoke(target,args);    &#125;&#125;</code></pre></div><p>去生成代理对象并调用方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.sqlSessionFactory.openSession(); Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.demo.mapper.TestMapper&quot;</span>); <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(                clazz.getClassLoader(),                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125;,                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>(sqlSession.getMapper(clazz))        );<span class="hljs-comment">//这里我是通过sqlSession来获取Mapper的</span> <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> instance.getClass().getMethod(<span class="hljs-string">&quot;selectById&quot;</span>,Integer.class); method.invoke(instance, <span class="hljs-number">1</span>);<span class="hljs-comment">//object为mapper中传入的参数</span></code></pre></div><p>这里需要注意，newProxyInstance()方法中最后一个参数，即为我们创建的动态代理的类（因为我这里调用的接口为mybatis中mapper中的接口，所以需要从sqlSession中getMapper）。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java注解学习</title>
    <link href="/2022/09/23/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/23/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1、注解是什么？"><a href="#1、注解是什么？" class="headerlink" title="1、注解是什么？"></a>1、注解是什么？</h2><p>Java注解（Annotation）又称Java标注，是JDK5.0引入的一种注释机制，注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据，注解对它们注解的代码没有直接影响。 怎么理解呢？ 可以理解成字面意思，他就是个注解，用来注释用的，和商场里的标签一样，标记这个东西是黄瓜，标记这个是西瓜似得 我们看看Java里怎么自定义一个注解？</p><h2 id="2、注解的定义"><a href="#2、注解的定义" class="headerlink" title="2、注解的定义"></a>2、注解的定义</h2><p>Java中所有的注解，默认实现Annotation接口：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Annotation</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object var1)</span>;    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;    String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationType();&#125;</code></pre></div><h2 id="3、元注解"><a href="#3、元注解" class="headerlink" title="3、元注解"></a>3、元注解</h2><p><strong>元注解</strong>：在定义注解时，注解类也能够使用其它的注解声明，对注解类型进行注解的注解类，我们称之为元注解（meta-annotation），一般我们在定义自定义注解时，需要指定的元注解有两个</p><blockquote><p>@Documented和@Inherited这两个元注解，前者用于被Javadoc工具提取成文档，后者表示允许子类集成父类中定义的注解</p></blockquote><p>@Target 注解标记另一个注解，以限制可以应用注解的Java元素类型。目标注解指定以下元素类型之一作为其值</p><ul><li>ElementType.TYPE  用于类的任何元素（类 、接口，注解，枚举）</li><li>ElementType.FIELD 应用于字段或属性</li><li>ElementType.METHOD 应用于方法级注解</li><li>ElementType.PARAMETER 应用于方法的参数</li><li>ElementType.CONSTRUCTOR 用用于构造方法</li><li>ElementType.LOCAL_VARIABLE 应用于局部变量</li><li>ElementType.ANNOTATION_TYPE 应用于注解类型</li><li>ElementType.PACKAGE 应用于包声明</li></ul><p>@ Retention 注解指定标记注解的存储方式，指定注解的生效时期就用这个注解</p><ul><li>RetentionPolicy.SOURCE  标记注解仅保留在 源码级别中，并被编译器忽略</li><li>RetentionPolicy.CLASS  标记注解在编译时由编译器保留，单JVM会忽略</li><li>RetentionPolicy.RUNTIME 便捷的注解由JVM保留，因此运行时环境可以使用它 <strong>编译器保留的时候 ，源码级别的时期也是能使用的，而不是单单在编译时被使用，RUNTIME的时候同理，RUNTIME时期包含了SOURCE时期和CLASS时期</strong></li></ul><h2 id="4、自定义一个注解"><a href="#4、自定义一个注解" class="headerlink" title="4、自定义一个注解"></a>4、自定义一个注解</h2><p>在元注解中，我们看到，允许在使用注解时传递参数，我们也能在自定义注解中传递参数（让自定义注解的主体包含annotation type element 注解类型元素声明），看起来很像方法，可以定义可选的默认值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.annotation.Target;<span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span> <span class="hljs-comment">//注解的保留时期 到编译期</span><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)</span><span class="hljs-comment">//应用与类 的元素  和  属性 字段</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BindView &#123;    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<span class="hljs-comment">//没有默认值</span>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span>  <span class="hljs-number">1</span>; <span class="hljs-comment">//有默认值</span>&#125;</code></pre></div><p>使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<span class="hljs-comment">//    @BindView(&quot;amszlk&quot;)</span>    <span class="hljs-meta">@BindView(value = &quot;amszlk&quot;,age=10)</span>    <span class="hljs-keyword">private</span> String name;&#125;</code></pre></div><blockquote><p>使用注解时，如果定义的注解中的 类型元素 无默认值，则必须传值</p></blockquote><h2 id="5、注解应用场景"><a href="#5、注解应用场景" class="headerlink" title="5、注解应用场景"></a>5、注解应用场景</h2><p>按照@Retention元注解 定义的注解存储方式，注解可以被在三种场景下使用</p><h3 id="5-1-SOURCE：作用于源码级别的注解，可以提供给IDE语法检查，APT等场景使用"><a href="#5-1-SOURCE：作用于源码级别的注解，可以提供给IDE语法检查，APT等场景使用" class="headerlink" title="5.1 SOURCE：作用于源码级别的注解，可以提供给IDE语法检查，APT等场景使用"></a>5.1 SOURCE：作用于源码级别的注解，可以提供给IDE语法检查，APT等场景使用</h3><h4 id="5-1-1、IDE语法检查"><a href="#5-1-1、IDE语法检查" class="headerlink" title="5.1.1、IDE语法检查"></a>5.1.1、IDE语法检查</h4><p>在Android开发中，在support-annotation和androidx.annotation中均提供了@IntDef注解，此注解的定义如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(SOURCE)</span><span class="hljs-comment">//源码级注解</span><span class="hljs-meta">@Target(&#123;ANNOTATION_TYPE&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> IntDef &#123;    <span class="hljs-comment">/** Defines the allowed constants for this element */</span>    <span class="hljs-type">int</span>[] value() <span class="hljs-keyword">default</span> &#123;&#125;;    <span class="hljs-comment">/** Defines whether the constants can be used as a flag, or just as an enum (the default) */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">flag</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Whether any other values are allowed. Normally this is</span><span class="hljs-comment">     * not the case, but this allows you to specify a set of</span><span class="hljs-comment">     * expected constants, which helps code completion in the IDE</span><span class="hljs-comment">     * and documentation generation and so on, but without</span><span class="hljs-comment">     * flagging compilation warnings if other values are specified.</span><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><p>Java中的枚举的实质是特殊单例的静态成员变量，在运行期所有枚举类作为单例，全部加载到内存中，比常量多5到10倍的内存占用，该注解的意义在于能够取代枚举，实现方法入参限制 例： 我们定义一个方法test，此方法接收参数coder需要在，Java和JavaScript中选一个</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Coder</span> &#123;    JAVA,JAVASCRIPT&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Coder coder)</span>&#123;    &#125;</code></pre></div><p>我们现在为了进行内存优化，不再使用枚举</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span>  <span class="hljs-type">int</span> JAVA=<span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> JAVASCRIPT=<span class="hljs-number">2</span>;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> coder)</span>&#123;          &#125;&#125;</code></pre></div><p>然而此时，调用test方法，由于用的是test，无法进行类型限定，可以传1和2之外的数，这是我们可以用@IntDef增加自定义注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@IntDef(value=&#123;JAVA,JAVASCRIPT&#125;)</span><span class="hljs-comment">//限定为JAVA和JAVASCRIPT</span>    <span class="hljs-meta">@Target(ElementType.PARAMETER)</span><span class="hljs-comment">//作用于参数</span>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><span class="hljs-comment">//源码级别的注解</span>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Coder &#123;    &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-meta">@Coder</span> <span class="hljs-type">int</span> coder)</span>&#123;   &#125;</code></pre></div><p>这样调用的时候传递的参数如果不是JAVA和JAVASCRIPT就会报错</p><p> <img src="/../images/java%E6%B3%A8%E8%A7%A31.jpg" alt="在这里插入图片描述"></p><h4 id="5-1-2APT注解处理器"><a href="#5-1-2APT注解处理器" class="headerlink" title="5.1.2APT注解处理器"></a>5.1.2APT注解处理器</h4><p>APT：Annotation Processor Tools 注解处理器，用于处理注解，编写好的Java源文件，需要经过javac编译，翻译为虚拟机能够加载解析的字节码文件Class文件，注解处理器是javac自带的一个工具，用来编译时期扫描处理注解信息。你可以为某些注解注册自己的注解处理器，注册的注解处理器由javac调起，并将注解信息传递给注解处理器进行处理 注解处理器是对注解应用最广泛的场景。Glide，ARouter，ButterKnifer，Tinker，EventBus等框架中都有注解处理器的影子，这些框架中对注解定义并不是Source级别，更多的是Class级别，因为Class级别包含了Source级别</p><h3 id="5-2CLASS"><a href="#5-2CLASS" class="headerlink" title="5.2CLASS"></a>5.2CLASS</h3><p>定义为CLASS的注解，会保留在class文件中，但是会被虚拟机忽略，即无法在运行期反射获取注解。此时完全符合此种注解的应用场景为字节码操作，如热修复Roubust中 字节码操作：直接修改字节码class文件达到修改代码执行逻辑的目的 举个栗子：登录拦截，在我们程序中有多处需要进行是否登录的判断，判断是否登录，是通过验证，未登录就进入登录，如果使用普通的编码方式，就是在许多方法里加上if else判断，但是有了CLASS时期的注解，我们可以使用AOP，将程序中所有功能点划分为需要登录与不需要登录两种切面，用注解来区分切面</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span>    <span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Login&#123;            &#125;    <span class="hljs-meta">@Login</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jumpAActivity</span><span class="hljs-params">()</span>&#123;            &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jumpBActivity</span><span class="hljs-params">()</span>&#123;            &#125;</code></pre></div><p>在以上代码中，我们能够在该类所在编译的字节码中获取得注解为Login的方法，然后去操作字节码，修改class中的内容，加入if else</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Class文件</span><span class="hljs-meta">@Login</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jumpAActivity</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.isLogin)  &#123;<span class="hljs-built_in">this</span>.startActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,LogingActivity.class))&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">this</span>.startActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,AActivity.class))&#125;      &#125;</code></pre></div><h3 id="5-3-RUNTIME"><a href="#5-3-RUNTIME" class="headerlink" title="5.3 RUNTIME"></a>5.3 RUNTIME</h3><p>注解保留至运行期，意味着我们能够在运行期间结合反射技术来获取注解中的所有信息</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>本文内容来源于书籍和网络。</p></blockquote><p>[TOC]</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。</p><p>拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。</p><h1 id="二、创建型"><a href="#二、创建型" class="headerlink" title="二、创建型"></a>二、创建型</h1><h2 id="1-单例（Singleton）"><a href="#1-单例（Singleton）" class="headerlink" title="1. 单例（Singleton）"></a>1. 单例（Singleton）</h2><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_176.png" alt="img"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><h4 id="Ⅰ-懒汉式-线程不安全"><a href="#Ⅰ-懒汉式-线程不安全" class="headerlink" title="Ⅰ 懒汉式-线程不安全"></a>Ⅰ 懒汉式-线程不安全</h4><p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p><p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;                                <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;        &#125;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;                        uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();                &#125;                <span class="hljs-keyword">return</span> uniqueInstance;        &#125;&#125;</code></pre></div><h4 id="Ⅱ-饿汉式-线程安全"><a href="#Ⅱ-饿汉式-线程安全" class="headerlink" title="Ⅱ 饿汉式-线程安全"></a>Ⅱ 饿汉式-线程安全</h4><p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p><p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">uniqueInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();</code></pre></div><h4 id="Ⅲ-懒汉式-线程安全"><a href="#Ⅲ-懒汉式-线程安全" class="headerlink" title="Ⅲ 懒汉式-线程安全"></a>Ⅲ 懒汉式-线程安全</h4><p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();    &#125;     <span class="hljs-keyword">return</span> uniqueInstance;&#125;</code></pre></div><h4 id="Ⅳ-双重校验锁-线程安全"><a href="#Ⅳ-双重校验锁-线程安全" class="headerlink" title="Ⅳ 双重校验锁-线程安全"></a>Ⅳ 双重校验锁-线程安全</h4><p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p><p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;        <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;                        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;                                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;                                        uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();                                &#125;                        &#125;                &#125;                <span class="hljs-keyword">return</span> uniqueInstance;        &#125;&#125;</code></pre></div><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance &#x3D;&#x3D; null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance &#x3D;&#x3D; null 时两个线程同时进行实例化操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;        uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();    &#125;&#125;</code></pre></div><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h4 id="Ⅴ-静态内部类实现"><a href="#Ⅴ-静态内部类实现" class="headerlink" title="Ⅴ 静态内部类实现"></a>Ⅴ 静态内部类实现</h4><p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;        &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;                <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;        &#125;&#125;</code></pre></div><h4 id="Ⅵ-枚举实现"><a href="#Ⅵ-枚举实现" class="headerlink" title="Ⅵ 枚举实现"></a>Ⅵ 枚举实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;            INSTANCE;            <span class="hljs-keyword">private</span> String objName;            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getObjName</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> objName;        &#125;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObjName</span><span class="hljs-params">(String objName)</span> &#123;                <span class="hljs-built_in">this</span>.objName = objName;        &#125;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                    <span class="hljs-comment">// 单例测试        </span>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">firstSingleton</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;        firstSingleton.setObjName(<span class="hljs-string">&quot;firstName&quot;</span>);        System.out.println(firstSingleton.getObjName());                <span class="hljs-type">Singleton</span> <span class="hljs-variable">secondSingleton</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;        secondSingleton.setObjName(<span class="hljs-string">&quot;secondName&quot;</span>);        System.out.println(firstSingleton.getObjName());        System.out.println(secondSingleton.getObjName());                      <span class="hljs-comment">// 反射获取实例测试        </span>        <span class="hljs-keyword">try</span> &#123;                        Singleton[] enumConstants = Singleton.class.getEnumConstants();            <span class="hljs-keyword">for</span> (Singleton enumConstant : enumConstants) &#123;                System.out.println(enumConstant.getObjName());                                                                                                                                                             &#125;                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        e.printStackTrace();                &#125;        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">   firstName</span><span class="hljs-attribute">secondName</span><span class="hljs-attribute">secondName</span><span class="hljs-attribute">secondName</span></code></pre></div><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p><p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ul><li>Logger Classes</li><li>Configuration Classes</li><li>Accesing resources in shared mode</li><li>Factories implemented as Singletons</li></ul><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime()">java.lang.Runtime#getRuntime()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--">java.awt.Desktop#getDesktop()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--">java.lang.System#getSecurityManager()</a></li></ul><h2 id="2-简单工厂（Simple-Factory）"><a href="#2-简单工厂（Simple-Factory）" class="headerlink" title="2. 简单工厂（Simple Factory）"></a>2. 简单工厂（Simple Factory）</h2><h3 id="Intent-1"><a href="#Intent-1" class="headerlink" title="Intent"></a>Intent</h3><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><h3 id="Class-Diagram-1"><a href="#Class-Diagram-1" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_155.png" alt="img"></p><h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Product</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ConcreteProduct</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Product</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ConcreteProduct1</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Product</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ConcreteProduct2</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Product</span> &#123;&#125;</code></pre></div><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                Product product;                <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;                        product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct1</span>();                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;                        product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct2</span>();                &#125; <span class="hljs-keyword">else</span> &#123;                        product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct</span>();                &#125;                <span class="hljs-comment">// do something with the product    </span>    &#125;&#125;</code></pre></div><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;        <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">createProduct</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;                <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct1</span>();                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct2</span>();                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct</span>();        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                <span class="hljs-type">SimpleFactory</span> <span class="hljs-variable">simpleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFactory</span>();                <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> simpleFactory.createProduct(<span class="hljs-number">1</span>);                <span class="hljs-comment">// do something with the product    </span>    &#125;&#125;</code></pre></div><h2 id="3-工厂方法（Factory-Method）"><a href="#3-工厂方法（Factory-Method）" class="headerlink" title="3. 工厂方法（Factory Method）"></a>3. 工厂方法（Factory Method）</h2><h3 id="Intent-2"><a href="#Intent-2" class="headerlink" title="Intent"></a>Intent</h3><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><h3 id="Class-Diagram-2"><a href="#Class-Diagram-2" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_177.png" alt="img"></p><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;        <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">factoryMethod</span><span class="hljs-params">()</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;                <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> factoryMethod();                <span class="hljs-comment">// do something with the product    </span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;        <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">factoryMethod</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct</span>();        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;        <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">factoryMethod</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct1</span>();        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;        <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">factoryMethod</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct2</span>();        &#125;&#125;</code></pre></div><h3 id="JDK-1"><a href="#JDK-1" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--">java.util.Calendar</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-">java.util.ResourceBundle</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--">java.text.NumberFormat</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-">java.nio.charset.Charset</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-">java.net.URLStreamHandlerFactory</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-">java.util.EnumSet</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--">javax.xml.bind.JAXBContext</a></li></ul><h2 id="4-抽象工厂（Abstract-Factory）"><a href="#4-抽象工厂（Abstract-Factory）" class="headerlink" title="4. 抽象工厂（Abstract Factory）"></a>4. 抽象工厂（Abstract Factory）</h2><h3 id="Intent-3"><a href="#Intent-3" class="headerlink" title="Intent"></a>Intent</h3><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p><h3 id="Class-Diagram-3"><a href="#Class-Diagram-3" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_175.png" alt="img"></p><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductA</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductB</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProductA</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProductA</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProductB</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProductB</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;        <span class="hljs-keyword">abstract</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span>;        <span class="hljs-keyword">abstract</span> AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span> &#123;        AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA1</span>();    &#125;        AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductB1</span>();        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span> &#123;       AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA2</span>();    &#125;        AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductB2</span>();        &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                <span class="hljs-type">AbstractFactory</span> <span class="hljs-variable">abstractFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFactory1</span>();                <span class="hljs-type">AbstractProductA</span> <span class="hljs-variable">productA</span> <span class="hljs-operator">=</span> abstractFactory.createProductA();        <span class="hljs-type">AbstractProductB</span> <span class="hljs-variable">productB</span> <span class="hljs-operator">=</span> abstractFactory.createProductB();                <span class="hljs-comment">// do something with productA and productB    </span>    &#125;&#125;</code></pre></div><h3 id="JDK-2"><a href="#JDK-2" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html">javax.xml.parsers.DocumentBuilderFactory</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--">javax.xml.transform.TransformerFactory</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--">javax.xml.xpath.XPathFactory</a></li></ul><h2 id="5-生成器（Builder）"><a href="#5-生成器（Builder）" class="headerlink" title="5. 生成器（Builder）"></a>5. 生成器（Builder）</h2><h3 id="Intent-4"><a href="#Intent-4" class="headerlink" title="Intent"></a>Intent</h3><p>封装一个对象的构造过程，并允许按步骤构造。</p><h3 id="Class-Diagram-4"><a href="#Class-Diagram-4" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><img src="https://www.xuxueli.com/blog/static/images/img_173.png" alt="img"></p><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractStringBuilder</span> &#123;          <span class="hljs-keyword">protected</span> <span class="hljs-type">char</span>[] value;            <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> count;            <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractStringBuilder</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;                count = <span class="hljs-number">0</span>;                value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[capacity];        &#125;            <span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;                ensureCapacityInternal(count + <span class="hljs-number">1</span>);                value[count++] = c;                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;        &#125;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;                <span class="hljs-comment">// overflow-conscious code        </span>        <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>)                     expandCapacity(minimumCapacity);        &#125;            <span class="hljs-keyword">void</span> <span class="hljs-title function_">expandCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> value.length * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;                <span class="hljs-keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="hljs-number">0</span>)                        newCapacity = minimumCapacity;                <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">if</span> (minimumCapacity &lt; <span class="hljs-number">0</span>)                 <span class="hljs-comment">// overflow                </span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();                        newCapacity = Integer.MAX_VALUE;                &#125;                value = Arrays.copyOf(value, newCapacity);        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractStringBuilder</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">()</span> &#123;                <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>);    &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;               <span class="hljs-comment">// Create a copy, don&#x27;t share the array        </span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, <span class="hljs-number">0</span>, count);        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">26</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;                        sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + i));                &#125;        System.out.println(sb.toString());        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">abcdefghijklmnopqrstuvwxyz</span></code></pre></div><h3 id="JDK-3"><a href="#JDK-3" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">java.lang.StringBuilder</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-">java.nio.ByteBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-">java.lang.StringBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html">java.lang.Appendable</a></li><li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder">Apache Camel builders</a></li></ul><h2 id="6-原型模式（Prototype）"><a href="#6-原型模式（Prototype）" class="headerlink" title="6. 原型模式（Prototype）"></a>6. 原型模式（Prototype）</h2><h3 id="Intent-5"><a href="#Intent-5" class="headerlink" title="Intent"></a>Intent</h3><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p><h3 id="Class-Diagram-5"><a href="#Class-Diagram-5" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><img src="https://www.xuxueli.com/blog/static/images/img_168.png" alt="img"></p><h3 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Prototype</span> &#123;        <span class="hljs-keyword">abstract</span> Prototype <span class="hljs-title function_">myClone</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcretePrototype</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Prototype</span> &#123;        <span class="hljs-keyword">private</span> String filed;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcretePrototype</span><span class="hljs-params">(String filed)</span> &#123;                <span class="hljs-built_in">this</span>.filed = filed;        &#125;        <span class="hljs-meta">@Override</span>        Prototype <span class="hljs-title function_">myClone</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcretePrototype</span>(filed);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> filed;        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                <span class="hljs-type">Prototype</span> <span class="hljs-variable">prototype</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcretePrototype</span>(<span class="hljs-string">&quot;abc&quot;</span>);                <span class="hljs-type">Prototype</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> prototype.myClone();            System.out.println(clone.toString());        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">abc</span></code></pre></div><h3 id="JDK-4"><a href="#JDK-4" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()">java.lang.Object#clone()</a></li></ul><h1 id="三、行为型"><a href="#三、行为型" class="headerlink" title="三、行为型"></a>三、行为型</h1><h2 id="1-责任链（Chain-Of-Responsibility）"><a href="#1-责任链（Chain-Of-Responsibility）" class="headerlink" title="1. 责任链（Chain Of Responsibility）"></a>1. 责任链（Chain Of Responsibility）</h2><h3 id="Intent-6"><a href="#Intent-6" class="headerlink" title="Intent"></a>Intent</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p><h3 id="Class-Diagram-6"><a href="#Class-Diagram-6" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Handler：定义处理请求的接口，并且实现后继链（successor）</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_171.png" alt="img"></p><h3 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-keyword">protected</span> Handler successor;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(Handler successor)</span> &#123;        <span class="hljs-built_in">this</span>.successor = successor;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(Request request)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteHandler1</span><span class="hljs-params">(Handler successor)</span> &#123;        <span class="hljs-built_in">super</span>(successor);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(Request request)</span> &#123;        <span class="hljs-keyword">if</span> (request.getType() == RequestType.TYPE1) &#123;            System.out.println(request.getName() + <span class="hljs-string">&quot; is handle by ConcreteHandler1&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;            successor.handleRequest(request);        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteHandler2</span><span class="hljs-params">(Handler successor)</span> &#123;        <span class="hljs-built_in">super</span>(successor);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(Request request)</span> &#123;        <span class="hljs-keyword">if</span> (request.getType() == RequestType.TYPE2) &#123;            System.out.println(request.getName() + <span class="hljs-string">&quot; is handle by ConcreteHandler2&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;            successor.handleRequest(request);        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;    <span class="hljs-keyword">private</span> RequestType type;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Request</span><span class="hljs-params">(RequestType type, String name)</span> &#123;        <span class="hljs-built_in">this</span>.type = type;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> RequestType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> type;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RequestType</span> &#123;    TYPE1, TYPE2&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Handler</span> <span class="hljs-variable">handler1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler1</span>(<span class="hljs-literal">null</span>);        <span class="hljs-type">Handler</span> <span class="hljs-variable">handler2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler2</span>(handler1);        <span class="hljs-type">Request</span> <span class="hljs-variable">request1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(RequestType.TYPE1, <span class="hljs-string">&quot;request1&quot;</span>);        handler2.handleRequest(request1);        <span class="hljs-type">Request</span> <span class="hljs-variable">request2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(RequestType.TYPE2, <span class="hljs-string">&quot;request2&quot;</span>);        handler2.handleRequest(request2);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs applescript">request1 <span class="hljs-keyword">is</span> handle <span class="hljs-keyword">by</span> ConcreteHandler1request2 <span class="hljs-keyword">is</span> handle <span class="hljs-keyword">by</span> ConcreteHandler2</code></pre></div><h3 id="JDK-5"><a href="#JDK-5" class="headerlink" title="JDK"></a>JDK</h3><ul><li>[java.util.logging.Logger#log()](<a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log">http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log</a>(java.util.logging.Level, java.lang.String))</li><li><a href="https://commons.apache.org/proper/commons-chain/index.html">Apache Commons Chain</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-">javax.servlet.Filter#doFilter()</a></li></ul><h2 id="2-命令（Command）"><a href="#2-命令（Command）" class="headerlink" title="2. 命令（Command）"></a>2. 命令（Command）</h2><h3 id="Intent-7"><a href="#Intent-7" class="headerlink" title="Intent"></a>Intent</h3><p>将命令封装成对象中，具有以下作用：</p><ul><li>使用命令来参数化其它对象</li><li>将命令放入队列中进行排队</li><li>将命令的操作记录到日志中</li><li>支持可撤销的操作</li></ul><h3 id="Class-Diagram-7"><a href="#Class-Diagram-7" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Command：命令</li><li>Receiver：命令接收者，也就是命令真正的执行者</li><li>Invoker：通过它来调用命令</li><li>Client：可以设置命令与命令的接收者</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_170.png" alt="img"></p><h3 id="Implementation-7"><a href="#Implementation-7" class="headerlink" title="Implementation"></a>Implementation</h3><p>设计一个遥控器，可以控制电灯开关。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_174.jpg" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;    Light light;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOnCommand</span><span class="hljs-params">(Light light)</span> &#123;        <span class="hljs-built_in">this</span>.light = light;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;        light.on();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOffCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;    Light light;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOffCommand</span><span class="hljs-params">(Light light)</span> &#123;        <span class="hljs-built_in">this</span>.light = light;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;        light.off();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Light is on!&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Light is off!&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 遥控器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;    <span class="hljs-keyword">private</span> Command[] onCommands;    <span class="hljs-keyword">private</span> Command[] offCommands;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">slotNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invoker</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.onCommands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>[slotNum];        <span class="hljs-built_in">this</span>.offCommands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>[slotNum];    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOnCommand</span><span class="hljs-params">(Command command, <span class="hljs-type">int</span> slot)</span> &#123;        onCommands[slot] = command;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOffCommand</span><span class="hljs-params">(Command command, <span class="hljs-type">int</span> slot)</span> &#123;        offCommands[slot] = command;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onButtonWasPushed</span><span class="hljs-params">(<span class="hljs-type">int</span> slot)</span> &#123;        onCommands[slot].execute();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offButtonWasPushed</span><span class="hljs-params">(<span class="hljs-type">int</span> slot)</span> &#123;        offCommands[slot].execute();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();        <span class="hljs-type">Light</span> <span class="hljs-variable">light</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Light</span>();        <span class="hljs-type">Command</span> <span class="hljs-variable">lightOnCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightOnCommand</span>(light);        <span class="hljs-type">Command</span> <span class="hljs-variable">lightOffCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightOffCommand</span>(light);        invoker.setOnCommand(lightOnCommand, <span class="hljs-number">0</span>);        invoker.setOffCommand(lightOffCommand, <span class="hljs-number">0</span>);        invoker.onButtonWasPushed(<span class="hljs-number">0</span>);        invoker.offButtonWasPushed(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div><h3 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li><li><a href="https://github.com/Netflix/Hystrix/wiki">Netflix Hystrix</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html">javax.swing.Action</a></li></ul><h2 id="3-解释器（Interpreter）"><a href="#3-解释器（Interpreter）" class="headerlink" title="3. 解释器（Interpreter）"></a>3. 解释器（Interpreter）</h2><h3 id="Intent-8"><a href="#Intent-8" class="headerlink" title="Intent"></a>Intent</h3><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p><h3 id="Class-Diagram-8"><a href="#Class-Diagram-8" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。</li><li>Context：上下文，包含解释器之外的一些全局信息。</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_148.png" alt="img"></p><h3 id="Implementation-8"><a href="#Implementation-8" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p><p>例如一颗解析树为 D And (A Or (B C))，文本 “D A” 满足该解析树定义的规则。</p><p>这里的 Context 指的是 String。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String str)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">literal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TerminalExpression</span><span class="hljs-params">(String str)</span> &#123;        literal = str;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String str)</span> &#123;        <span class="hljs-type">StringTokenizer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(str);        <span class="hljs-keyword">while</span> (st.hasMoreTokens()) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> st.nextToken();            <span class="hljs-keyword">if</span> (test.equals(literal)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">Expression</span> <span class="hljs-variable">expression1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">Expression</span> <span class="hljs-variable">expression2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndExpression</span><span class="hljs-params">(Expression expression1, Expression expression2)</span> &#123;        <span class="hljs-built_in">this</span>.expression1 = expression1;        <span class="hljs-built_in">this</span>.expression2 = expression2;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String str)</span> &#123;        <span class="hljs-keyword">return</span> expression1.interpret(str) &amp;&amp; expression2.interpret(str);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">Expression</span> <span class="hljs-variable">expression1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">Expression</span> <span class="hljs-variable">expression2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrExpression</span><span class="hljs-params">(Expression expression1, Expression expression2)</span> &#123;        <span class="hljs-built_in">this</span>.expression1 = expression1;        <span class="hljs-built_in">this</span>.expression2 = expression2;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String str)</span> &#123;        <span class="hljs-keyword">return</span> expression1.interpret(str) || expression2.interpret(str);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">构建解析树</span><span class="hljs-comment">**/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Expression <span class="hljs-title function_">buildInterpreterTree</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// Literal</span>        <span class="hljs-type">Expression</span> <span class="hljs-variable">terminal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;A&quot;</span>);        <span class="hljs-type">Expression</span> <span class="hljs-variable">terminal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;B&quot;</span>);        <span class="hljs-type">Expression</span> <span class="hljs-variable">terminal3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;C&quot;</span>);        <span class="hljs-type">Expression</span> <span class="hljs-variable">terminal4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-string">&quot;D&quot;</span>);        <span class="hljs-comment">// B C</span>        <span class="hljs-type">Expression</span> <span class="hljs-variable">alternation1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrExpression</span>(terminal2, terminal3);        <span class="hljs-comment">// A Or (B C)</span>        <span class="hljs-type">Expression</span> <span class="hljs-variable">alternation2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrExpression</span>(terminal1, alternation1);        <span class="hljs-comment">// D And (A Or (B C))</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndExpression</span>(terminal4, alternation2);    &#125;                <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Expression</span> <span class="hljs-variable">define</span> <span class="hljs-operator">=</span> buildInterpreterTree();        <span class="hljs-type">String</span> <span class="hljs-variable">context1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D A&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">context2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A B&quot;</span>;        System.out.println(define.interpret(context1));        System.out.println(define.interpret(context2));    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><span class="hljs-literal">false</span></code></pre></div><h3 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.Pattern</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html">java.text.Normalizer</a></li><li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html">java.text.Format</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html">javax.el.ELResolver</a></li></ul><h2 id="4-迭代器（Iterator）"><a href="#4-迭代器（Iterator）" class="headerlink" title="4. 迭代器（Iterator）"></a>4. 迭代器（Iterator）</h2><h3 id="Intent-9"><a href="#Intent-9" class="headerlink" title="Intent"></a>Intent</h3><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p><h3 id="Class-Diagram-9"><a href="#Class-Diagram-9" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li><li>Iterator 主要定义了 hasNext() 和 next() 方法。</li><li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_163.png" alt="img"></p><h3 id="Implementation-9"><a href="#Implementation-9" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;    Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> &#123;    <span class="hljs-keyword">private</span> Integer[] items;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteAggregate</span><span class="hljs-params">()</span> &#123;        items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;            items[i] = i;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>&lt;Integer&gt;(items);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;Item&gt; &#123;    Item <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span>&lt;Item&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;    <span class="hljs-keyword">private</span> Item[] items;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(Item[] items)</span> &#123;        <span class="hljs-built_in">this</span>.items = items;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> items[position++];    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> position &lt; items.length;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Aggregate</span> <span class="hljs-variable">aggregate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteAggregate</span>();        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;</code></pre></div><h3 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">java.util.Iterator</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html">java.util.Enumeration</a></li></ul><h2 id="5-中介者（Mediator）"><a href="#5-中介者（Mediator）" class="headerlink" title="5. 中介者（Mediator）"></a>5. 中介者（Mediator）</h2><h3 id="Intent-10"><a href="#Intent-10" class="headerlink" title="Intent"></a>Intent</h3><p>集中相关对象之间复杂的沟通和控制方式。</p><h3 id="Class-Diagram-10"><a href="#Class-Diagram-10" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。</li><li>Colleague：同事，相关对象</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_154.png" alt="img"></p><h3 id="Implementation-10"><a href="#Implementation-10" class="headerlink" title="Implementation"></a>Implementation</h3><p>Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p><p><img src="https://www.xuxueli.com/blog/static/images/img_158.jpg" alt="img"></p><p>使用中介者模式可以将复杂的依赖结构变成星形结构：</p><p><img src="https://www.xuxueli.com/blog/static/images/img_160.jpg" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Mediator mediator)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alarm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Mediator mediator)</span> &#123;        mediator.doEvent(<span class="hljs-string">&quot;alarm&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAlarm</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;doAlarm()&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeePot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Mediator mediator)</span> &#123;        mediator.doEvent(<span class="hljs-string">&quot;coffeePot&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doCoffeePot</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;doCoffeePot()&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calender</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Mediator mediator)</span> &#123;        mediator.doEvent(<span class="hljs-string">&quot;calender&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doCalender</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;doCalender()&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sprinkler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Mediator mediator)</span> &#123;        mediator.doEvent(<span class="hljs-string">&quot;sprinkler&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSprinkler</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;doSprinkler()&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">(String eventType)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;    <span class="hljs-keyword">private</span> Alarm alarm;    <span class="hljs-keyword">private</span> CoffeePot coffeePot;    <span class="hljs-keyword">private</span> Calender calender;    <span class="hljs-keyword">private</span> Sprinkler sprinkler;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteMediator</span><span class="hljs-params">(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler)</span> &#123;        <span class="hljs-built_in">this</span>.alarm = alarm;        <span class="hljs-built_in">this</span>.coffeePot = coffeePot;        <span class="hljs-built_in">this</span>.calender = calender;        <span class="hljs-built_in">this</span>.sprinkler = sprinkler;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">(String eventType)</span> &#123;        <span class="hljs-keyword">switch</span> (eventType) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;alarm&quot;</span>:                doAlarmEvent();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;coffeePot&quot;</span>:                doCoffeePotEvent();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;calender&quot;</span>:                doCalenderEvent();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                doSprinklerEvent();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAlarmEvent</span><span class="hljs-params">()</span> &#123;        alarm.doAlarm();        coffeePot.doCoffeePot();        calender.doCalender();        sprinkler.doSprinkler();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doCoffeePotEvent</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doCalenderEvent</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSprinklerEvent</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Alarm</span> <span class="hljs-variable">alarm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Alarm</span>();        <span class="hljs-type">CoffeePot</span> <span class="hljs-variable">coffeePot</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoffeePot</span>();        <span class="hljs-type">Calender</span> <span class="hljs-variable">calender</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calender</span>();        <span class="hljs-type">Sprinkler</span> <span class="hljs-variable">sprinkler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sprinkler</span>();        <span class="hljs-type">Mediator</span> <span class="hljs-variable">mediator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteMediator</span>(alarm, coffeePot, calender, sprinkler);        <span class="hljs-comment">// 闹钟事件到达，调用中介者就可以操作相关对象</span>        alarm.onEvent(mediator);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">doAlarm</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">doCoffeePot</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">doCalender</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">doSprinkler</span><span class="hljs-params">()</span></span></code></pre></div><h3 id="JDK-9"><a href="#JDK-9" class="headerlink" title="JDK"></a>JDK</h3><ul><li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html">java.util.Timer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-">java.util.concurrent.Executor#execute()</a></li><li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">java.util.concurrent.ExecutorService</a></li><li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html">java.util.concurrent.ScheduledExecutorService</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">java.lang.reflect.Method#invoke()</a></li></ul><h2 id="6-备忘录（Memento）"><a href="#6-备忘录（Memento）" class="headerlink" title="6. 备忘录（Memento）"></a>6. 备忘录（Memento）</h2><h3 id="Intent-11"><a href="#Intent-11" class="headerlink" title="Intent"></a>Intent</h3><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p><h3 id="Class-Diagram-11"><a href="#Class-Diagram-11" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Originator：原始对象</li><li>Caretaker：负责保存好备忘录</li><li>Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_162.png" alt="img"></p><h3 id="Implementation-11"><a href="#Implementation-11" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p><p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html">Memento Pattern - Calculator Example - Java Sourcecode</a></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">Originator Interface</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-comment">// Create Memento</span>    PreviousCalculationToCareTaker <span class="hljs-title function_">backupLastCalculation</span><span class="hljs-params">()</span>;    <span class="hljs-comment">// setMemento</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">restorePreviousCalculation</span><span class="hljs-params">(PreviousCalculationToCareTaker memento)</span>;    <span class="hljs-type">int</span> <span class="hljs-title function_">getCalculationResult</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirstNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> firstNumber)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecondNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> secondNumber)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"></span><span class="hljs-comment">Originator Implementation</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> firstNumber;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> secondNumber;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> PreviousCalculationToCareTaker <span class="hljs-title function_">backupLastCalculation</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// create a memento object used for restoring two numbers</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PreviousCalculationImp</span>(firstNumber, secondNumber);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restorePreviousCalculation</span><span class="hljs-params">(PreviousCalculationToCareTaker memento)</span> &#123;        <span class="hljs-built_in">this</span>.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();        <span class="hljs-built_in">this</span>.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCalculationResult</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// result is adding two numbers</span>        <span class="hljs-keyword">return</span> firstNumber + secondNumber;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirstNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> firstNumber)</span> &#123;        <span class="hljs-built_in">this</span>.firstNumber = firstNumber;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecondNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> secondNumber)</span> &#123;        <span class="hljs-built_in">this</span>.secondNumber = secondNumber;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">Memento Interface to Originator</span><span class="hljs-comment">This interface allows the originator to restore its state</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PreviousCalculationToOriginator</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-title function_">getFirstNumber</span><span class="hljs-params">()</span>;    <span class="hljs-type">int</span> <span class="hljs-title function_">getSecondNumber</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">Memento interface to CalculatorOperator (Caretaker)</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PreviousCalculationToCareTaker</span> &#123;<span class="hljs-comment">// no operations permitted for the caretaker</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">Memento Object Implementation</span><span class="hljs-comment">Note that this object implements both interfaces to Originator and CareTaker</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreviousCalculationImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PreviousCalculationToCareTaker</span>,    PreviousCalculationToOriginator &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> firstNumber;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> secondNumber;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PreviousCalculationImp</span><span class="hljs-params">(<span class="hljs-type">int</span> firstNumber, <span class="hljs-type">int</span> secondNumber)</span> &#123;        <span class="hljs-built_in">this</span>.firstNumber = firstNumber;        <span class="hljs-built_in">this</span>.secondNumber = secondNumber;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFirstNumber</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> firstNumber;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSecondNumber</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> secondNumber;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">CareTaker object</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// program starts</span>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalculatorImp</span>();        <span class="hljs-comment">// assume user enters two numbers</span>        calculator.setFirstNumber(<span class="hljs-number">10</span>);        calculator.setSecondNumber(<span class="hljs-number">100</span>);        <span class="hljs-comment">// find result</span>        System.out.println(calculator.getCalculationResult());        <span class="hljs-comment">// Store result of this calculation in case of error</span>        <span class="hljs-type">PreviousCalculationToCareTaker</span> <span class="hljs-variable">memento</span> <span class="hljs-operator">=</span> calculator.backupLastCalculation();        <span class="hljs-comment">// user enters a number</span>        calculator.setFirstNumber(<span class="hljs-number">17</span>);        <span class="hljs-comment">// user enters a wrong second number and calculates result</span>        calculator.setSecondNumber(-<span class="hljs-number">290</span>);        <span class="hljs-comment">// calculate result</span>        System.out.println(calculator.getCalculationResult());        <span class="hljs-comment">// user hits CTRL + Z to undo last operation and see last result</span>        calculator.restorePreviousCalculation(memento);        <span class="hljs-comment">// result restored</span>        System.out.println(calculator.getCalculationResult());    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs diff">110<span class="hljs-deletion">-273</span>110</code></pre></div><h3 id="JDK-10"><a href="#JDK-10" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.io.Serializable</li></ul><h2 id="7-观察者（Observer）"><a href="#7-观察者（Observer）" class="headerlink" title="7. 观察者（Observer）"></a>7. 观察者（Observer）</h2><h3 id="Intent-12"><a href="#Intent-12" class="headerlink" title="Intent"></a>Intent</h3><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p><p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_152.jpg" alt="img"></p><h3 id="Class-Diagram-12"><a href="#Class-Diagram-12" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p><p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_165.png" alt="img"></p><h3 id="Implementation-12"><a href="#Implementation-12" class="headerlink" title="Implementation"></a>Implementation</h3><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_167.jpg" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObserver</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers;    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">()</span> &#123;        observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMeasurements</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span> &#123;        <span class="hljs-built_in">this</span>.temperature = temperature;        <span class="hljs-built_in">this</span>.humidity = humidity;        <span class="hljs-built_in">this</span>.pressure = pressure;        notifyObserver();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span> &#123;        observers.add(o);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> observers.indexOf(o);        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;            observers.remove(i);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObserver</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (Observer o : observers) &#123;            o.update(temperature, humidity, pressure);        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temp, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StatisticsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StatisticsDisplay</span><span class="hljs-params">(Subject weatherData)</span> &#123;        weatherData.reisterObserver(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temp, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span> &#123;        System.out.println(<span class="hljs-string">&quot;StatisticsDisplay.update: &quot;</span> + temp + <span class="hljs-string">&quot; &quot;</span> + humidity + <span class="hljs-string">&quot; &quot;</span> + pressure);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditionsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CurrentConditionsDisplay</span><span class="hljs-params">(Subject weatherData)</span> &#123;        weatherData.registerObserver(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temp, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span> &#123;        System.out.println(<span class="hljs-string">&quot;CurrentConditionsDisplay.update: &quot;</span> + temp + <span class="hljs-string">&quot; &quot;</span> + humidity + <span class="hljs-string">&quot; &quot;</span> + pressure);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherStation</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>();        <span class="hljs-type">CurrentConditionsDisplay</span> <span class="hljs-variable">currentConditionsDisplay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditionsDisplay</span>(weatherData);        <span class="hljs-type">StatisticsDisplay</span> <span class="hljs-variable">statisticsDisplay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StatisticsDisplay</span>(weatherData);        weatherData.setMeasurements(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        weatherData.setMeasurements(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">CurrentConditionsDisplay</span>.update: <span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span><span class="hljs-attribute">StatisticsDisplay</span>.update: <span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span><span class="hljs-attribute">CurrentConditionsDisplay</span>.update: <span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">1</span>.<span class="hljs-number">0</span><span class="hljs-attribute">StatisticsDisplay</span>.update: <span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">1</span>.<span class="hljs-number">0</span></code></pre></div><h3 id="JDK-11"><a href="#JDK-11" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html">java.util.EventListener</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html">javax.servlet.http.HttpSessionBindingListener</a></li><li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li></ul><h2 id="8-状态（State）"><a href="#8-状态（State）" class="headerlink" title="8. 状态（State）"></a>8. 状态（State）</h2><h3 id="Intent-13"><a href="#Intent-13" class="headerlink" title="Intent"></a>Intent</h3><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p><h3 id="Class-Diagram-13"><a href="#Class-Diagram-13" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><img src="https://www.xuxueli.com/blog/static/images/img_157.png" alt="img"></p><h3 id="Implementation-13"><a href="#Implementation-13" class="headerlink" title="Implementation"></a>Implementation</h3><p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_159.jpg" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">State</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 投入 25 分钱</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQuarter</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 退回 25 分钱</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">ejectQuarter</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 转动曲柄</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnCrank</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发放糖果</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispense</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HasQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">private</span> GumballMachine gumballMachine;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HasQuarterState</span><span class="hljs-params">(GumballMachine gumballMachine)</span> &#123;        <span class="hljs-built_in">this</span>.gumballMachine = gumballMachine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You can&#x27;t insert another quarter&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ejectQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Quarter returned&quot;</span>);        gumballMachine.setState(gumballMachine.getNoQuarterState());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnCrank</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You turned...&quot;</span>);        gumballMachine.setState(gumballMachine.getSoldState());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispense</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;No gumball dispensed&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;    GumballMachine gumballMachine;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NoQuarterState</span><span class="hljs-params">(GumballMachine gumballMachine)</span> &#123;        <span class="hljs-built_in">this</span>.gumballMachine = gumballMachine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You insert a quarter&quot;</span>);        gumballMachine.setState(gumballMachine.getHasQuarterState());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ejectQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You haven&#x27;t insert a quarter&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnCrank</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You turned, but there&#x27;s no quarter&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispense</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You need to pay first&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoldOutState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;    GumballMachine gumballMachine;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SoldOutState</span><span class="hljs-params">(GumballMachine gumballMachine)</span> &#123;        <span class="hljs-built_in">this</span>.gumballMachine = gumballMachine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You can&#x27;t insert a quarter, the machine is sold out&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ejectQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You can&#x27;t eject, you haven&#x27;t inserted a quarter yet&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnCrank</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;You turned, but there are no gumballs&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispense</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;No gumball dispensed&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoldState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;    GumballMachine gumballMachine;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SoldState</span><span class="hljs-params">(GumballMachine gumballMachine)</span> &#123;        <span class="hljs-built_in">this</span>.gumballMachine = gumballMachine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Please wait, we&#x27;re already giving you a gumball&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ejectQuarter</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Sorry, you already turned the crank&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnCrank</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Turning twice doesn&#x27;t get you another gumball!&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispense</span><span class="hljs-params">()</span> &#123;        gumballMachine.releaseBall();        <span class="hljs-keyword">if</span> (gumballMachine.getCount() &gt; <span class="hljs-number">0</span>) &#123;            gumballMachine.setState(gumballMachine.getNoQuarterState());        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;Oops, out of gumballs&quot;</span>);            gumballMachine.setState(gumballMachine.getSoldOutState());        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GumballMachine</span> &#123;    <span class="hljs-keyword">private</span> State soldOutState;    <span class="hljs-keyword">private</span> State noQuarterState;    <span class="hljs-keyword">private</span> State hasQuarterState;    <span class="hljs-keyword">private</span> State soldState;    <span class="hljs-keyword">private</span> State state;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GumballMachine</span><span class="hljs-params">(<span class="hljs-type">int</span> numberGumballs)</span> &#123;        count = numberGumballs;        soldOutState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoldOutState</span>(<span class="hljs-built_in">this</span>);        noQuarterState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoQuarterState</span>(<span class="hljs-built_in">this</span>);        hasQuarterState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HasQuarterState</span>(<span class="hljs-built_in">this</span>);        soldState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoldState</span>(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">if</span> (numberGumballs &gt; <span class="hljs-number">0</span>) &#123;            state = noQuarterState;        &#125; <span class="hljs-keyword">else</span> &#123;            state = soldOutState;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQuarter</span><span class="hljs-params">()</span> &#123;        state.insertQuarter();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ejectQuarter</span><span class="hljs-params">()</span> &#123;        state.ejectQuarter();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnCrank</span><span class="hljs-params">()</span> &#123;        state.turnCrank();        state.dispense();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;        <span class="hljs-built_in">this</span>.state = state;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseBall</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;A gumball comes rolling out the slot...&quot;</span>);        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>) &#123;            count -= <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getSoldOutState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> soldOutState;    &#125;    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getNoQuarterState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> noQuarterState;    &#125;    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getHasQuarterState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> hasQuarterState;    &#125;    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getSoldState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> soldState;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">GumballMachine</span> <span class="hljs-variable">gumballMachine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GumballMachine</span>(<span class="hljs-number">5</span>);        gumballMachine.insertQuarter();        gumballMachine.turnCrank();        gumballMachine.insertQuarter();        gumballMachine.ejectQuarter();        gumballMachine.turnCrank();        gumballMachine.insertQuarter();        gumballMachine.turnCrank();        gumballMachine.insertQuarter();        gumballMachine.turnCrank();        gumballMachine.ejectQuarter();        gumballMachine.insertQuarter();        gumballMachine.insertQuarter();        gumballMachine.turnCrank();        gumballMachine.insertQuarter();        gumballMachine.turnCrank();        gumballMachine.insertQuarter();        gumballMachine.turnCrank();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs stata">You insert a quarterYou turned...A gumball comes <span class="hljs-keyword">rolling</span> <span class="hljs-keyword">out</span> the slot...You insert a quarterQuarter returnedYou turned, but there&#x27;s <span class="hljs-keyword">no</span> quarterYou need to pay firstYou insert a quarterYou turned...A gumball comes <span class="hljs-keyword">rolling</span> <span class="hljs-keyword">out</span> the slot...You insert a quarterYou turned...A gumball comes <span class="hljs-keyword">rolling</span> <span class="hljs-keyword">out</span> the slot...You haven&#x27;t insert a quarterYou insert a quarterYou can&#x27;t insert another quarterYou turned...A gumball comes <span class="hljs-keyword">rolling</span> <span class="hljs-keyword">out</span> the slot...You insert a quarterYou turned...A gumball comes <span class="hljs-keyword">rolling</span> <span class="hljs-keyword">out</span> the slot...Oops, <span class="hljs-keyword">out</span> of gumballsYou can&#x27;t insert a quarter, the machine is sold <span class="hljs-keyword">out</span>You turned, but there are <span class="hljs-keyword">no</span> gumballs<span class="hljs-keyword">No</span> gumball dispensed</code></pre></div><h2 id="9-策略（Strategy）"><a href="#9-策略（Strategy）" class="headerlink" title="9. 策略（Strategy）"></a>9. 策略（Strategy）</h2><h3 id="Intent-14"><a href="#Intent-14" class="headerlink" title="Intent"></a>Intent</h3><p>定义一系列算法，封装每个算法，并使它们可以互换。</p><p>策略模式可以让算法独立于使用它的客户端。</p><h3 id="Class-Diagram-14"><a href="#Class-Diagram-14" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。</li><li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_172.png" alt="img"></p><h3 id="与状态模式的比较"><a href="#与状态模式的比较" class="headerlink" title="与状态模式的比较"></a>与状态模式的比较</h3><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p><p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p><h3 id="Implementation-14"><a href="#Implementation-14" class="headerlink" title="Implementation"></a>Implementation</h3><p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">QuackBehavior</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Quack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">QuackBehavior</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;quack!&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Squeak</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">QuackBehavior</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;squeak!&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;    <span class="hljs-keyword">private</span> QuackBehavior quackBehavior;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performQuack</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (quackBehavior != <span class="hljs-literal">null</span>) &#123;            quackBehavior.quack();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setQuackBehavior</span><span class="hljs-params">(QuackBehavior quackBehavior)</span> &#123;        <span class="hljs-built_in">this</span>.quackBehavior = quackBehavior;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Duck</span> <span class="hljs-variable">duck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Duck</span>();        duck.setQuackBehavior(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Squeak</span>());        duck.performQuack();        duck.setQuackBehavior(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Quack</span>());        duck.performQuack();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs erlang-repl">squeak!quack!</code></pre></div><h3 id="JDK-12"><a href="#JDK-12" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.util.Comparator#compare()</li><li>javax.servlet.http.HttpServlet</li><li>javax.servlet.Filter#doFilter()</li></ul><h2 id="10-模板方法（Template-Method）"><a href="#10-模板方法（Template-Method）" class="headerlink" title="10. 模板方法（Template Method）"></a>10. 模板方法（Template Method）</h2><h3 id="Intent-15"><a href="#Intent-15" class="headerlink" title="Intent"></a>Intent</h3><p>定义算法框架，并将一些步骤的实现延迟到子类。</p><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><h3 id="Class-Diagram-15"><a href="#Class-Diagram-15" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><img src="https://www.xuxueli.com/blog/static/images/img_166.png" alt="img"></p><h3 id="Implementation-15"><a href="#Implementation-15" class="headerlink" title="Implementation"></a>Implementation</h3><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_164.png" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CaffeineBeverage</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareRecipe</span><span class="hljs-params">()</span> &#123;        boilWater();        brew();        pourInCup();        addCondiments();    &#125;    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">boilWater</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;boilWater&quot;</span>);    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourInCup</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;pourInCup&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CaffeineBeverage</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Coffee.brew&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Coffee.addCondiments&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CaffeineBeverage</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Tea.brew&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Tea.addCondiments&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">CaffeineBeverage</span> <span class="hljs-variable">caffeineBeverage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Coffee</span>();        caffeineBeverage.prepareRecipe();        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);        caffeineBeverage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tea</span>();        caffeineBeverage.prepareRecipe();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs asciidoc">boilWaterCoffee.brewpourInCup<span class="hljs-section">Coffee.addCondiments</span><span class="hljs-section">-----------</span>boilWaterTea.brewpourInCupTea.addCondiments</code></pre></div><h3 id="JDK-13"><a href="#JDK-13" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.util.Collections#sort()</li><li>java.io.InputStream#skip()</li><li>java.io.InputStream#read()</li><li>java.util.AbstractList#indexOf()</li></ul><h2 id="11-访问者（Visitor）"><a href="#11-访问者（Visitor）" class="headerlink" title="11. 访问者（Visitor）"></a>11. 访问者（Visitor）</h2><h3 id="Intent-16"><a href="#Intent-16" class="headerlink" title="Intent"></a>Intent</h3><p>为一个对象结构（比如组合结构）增加新能力。</p><h3 id="Class-Diagram-16"><a href="#Class-Diagram-16" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li><li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li><li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_156.png" alt="img"></p><h3 id="Implementation-16"><a href="#Implementation-16" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerGroup</span> &#123;    <span class="hljs-keyword">private</span> List&lt;Customer&gt; customers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;        <span class="hljs-keyword">for</span> (Customer customer : customers) &#123;            customer.accept(visitor);        &#125;    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCustomer</span><span class="hljs-params">(Customer customer)</span> &#123;        customers.add(customer);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> List&lt;Order&gt; orders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    Customer(String name) &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOrder</span><span class="hljs-params">(Order order)</span> &#123;        orders.add(order);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">for</span> (Order order : orders) &#123;            order.accept(visitor);        &#125;    &#125;java&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> List&lt;Item&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();    Order(String name) &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    Order(String name, String itemName) &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(itemName));    &#125;    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(Item item)</span> &#123;        items.add(item);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">for</span> (Item item : items) &#123;            item.accept(visitor);        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">private</span> String name;    Item(String name) &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="hljs-built_in">this</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Customer customer)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Item item)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneralReport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customersNo;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> ordersNo;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> itemsNo;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Customer customer)</span> &#123;        System.out.println(customer.getName());        customersNo++;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span> &#123;        System.out.println(order.getName());        ordersNo++;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Item item)</span> &#123;        System.out.println(item.getName());        itemsNo++;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayResults</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Number of customers: &quot;</span> + customersNo);        System.out.println(<span class="hljs-string">&quot;Number of orders:    &quot;</span> + ordersNo);        System.out.println(<span class="hljs-string">&quot;Number of items:     &quot;</span> + itemsNo);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-string">&quot;customer1&quot;</span>);        customer1.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;order1&quot;</span>, <span class="hljs-string">&quot;item1&quot;</span>));        customer1.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;order2&quot;</span>, <span class="hljs-string">&quot;item1&quot;</span>));        customer1.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;order3&quot;</span>, <span class="hljs-string">&quot;item1&quot;</span>));        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;order_a&quot;</span>);        order.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;item_a1&quot;</span>));        order.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;item_a2&quot;</span>));        order.addItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;item_a3&quot;</span>));        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-string">&quot;customer2&quot;</span>);        customer2.addOrder(order);        <span class="hljs-type">CustomerGroup</span> <span class="hljs-variable">customers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomerGroup</span>();        customers.addCustomer(customer1);        customers.addCustomer(customer2);        <span class="hljs-type">GeneralReport</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneralReport</span>();        customers.accept(visitor);        visitor.displayResults();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mipsasm">customer1<span class="hljs-keyword">order1</span><span class="hljs-keyword"></span>item1<span class="hljs-keyword">order2</span><span class="hljs-keyword"></span>item1<span class="hljs-keyword">order3</span><span class="hljs-keyword"></span>item1customer2<span class="hljs-keyword">order_a</span><span class="hljs-keyword"></span>item_a1item_a2item_a3Number of customers: <span class="hljs-number">2</span>Number of <span class="hljs-keyword">orders: </span>   <span class="hljs-number">4</span>Number of items:     <span class="hljs-number">6</span></code></pre></div><h3 id="JDK-14"><a href="#JDK-14" class="headerlink" title="JDK"></a>JDK</h3><ul><li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li><li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li></ul><h2 id="12-空对象（Null）"><a href="#12-空对象（Null）" class="headerlink" title="12. 空对象（Null）"></a>12. 空对象（Null）</h2><h3 id="Intent-17"><a href="#Intent-17" class="headerlink" title="Intent"></a>Intent</h3><p>使用什么都不做的空对象来代替 NULL。</p><p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p><h3 id="Class-Diagram-17"><a href="#Class-Diagram-17" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><img src="https://www.xuxueli.com/blog/static/images/img_161.png" alt="img"></p><h3 id="Implementation-17"><a href="#Implementation-17" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOperation</span> &#123;    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOperation</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;do something&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NullOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOperation</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// do nothing</span>    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">AbstractOperation</span> <span class="hljs-variable">abstractOperation</span> <span class="hljs-operator">=</span> func(-<span class="hljs-number">1</span>);        abstractOperation.request();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractOperation <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> para)</span> &#123;        <span class="hljs-keyword">if</span> (para &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullOperation</span>();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealOperation</span>();    &#125;&#125;</code></pre></div><h1 id="四、结构型"><a href="#四、结构型" class="headerlink" title="四、结构型"></a>四、结构型</h1><h2 id="1-适配器（Adapter）"><a href="#1-适配器（Adapter）" class="headerlink" title="1. 适配器（Adapter）"></a>1. 适配器（Adapter）</h2><h3 id="Intent-18"><a href="#Intent-18" class="headerlink" title="Intent"></a>Intent</h3><p>把一个类接口转换成另一个用户需要的接口。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_149.png" alt="img"></p><h3 id="Class-Diagram-18"><a href="#Class-Diagram-18" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><img src="https://www.xuxueli.com/blog/static/images/img_179.png" alt="img"></p><h3 id="Implementation-18"><a href="#Implementation-18" class="headerlink" title="Implementation"></a>Implementation</h3><p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p><p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Duck</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Turkey</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildTurkey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Turkey</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;gobble!&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TurkeyAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Duck</span> &#123;    Turkey turkey;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TurkeyAdapter</span><span class="hljs-params">(Turkey turkey)</span> &#123;        <span class="hljs-built_in">this</span>.turkey = turkey;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;        turkey.gobble();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Turkey</span> <span class="hljs-variable">turkey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WildTurkey</span>();        <span class="hljs-type">Duck</span> <span class="hljs-variable">duck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TurkeyAdapter</span>(turkey);        duck.quack();    &#125;&#125;</code></pre></div><h3 id="JDK-15"><a href="#JDK-15" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList(T...)">java.util.Arrays#asList()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-">java.util.Collections#list()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-">java.util.Collections#enumeration()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-">javax.xml.bind.annotation.adapters.XMLAdapter</a></li></ul><h2 id="2-桥接（Bridge）"><a href="#2-桥接（Bridge）" class="headerlink" title="2. 桥接（Bridge）"></a>2. 桥接（Bridge）</h2><h3 id="Intent-19"><a href="#Intent-19" class="headerlink" title="Intent"></a>Intent</h3><p>将抽象与实现分离开来，使它们可以独立变化。</p><h3 id="Class-Diagram-19"><a href="#Class-Diagram-19" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Abstraction：定义抽象类的接口</li><li>Implementor：定义实现类接口</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_146.png" alt="img"></p><h3 id="Implementation-19"><a href="#Implementation-19" class="headerlink" title="Implementation"></a>Implementation</h3><p>RemoteControl 表示遥控器，指代 Abstraction。</p><p>TV 表示电视，指代 Implementor。</p><p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tuneChannel</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sony</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TV</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Sony.on()&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Sony.off()&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tuneChannel</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Sony.tuneChannel()&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RCA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TV</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;RCA.on()&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;RCA.off()&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tuneChannel</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;RCA.tuneChannel()&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;    <span class="hljs-keyword">protected</span> TV tv;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RemoteControl</span><span class="hljs-params">(TV tv)</span> &#123;        <span class="hljs-built_in">this</span>.tv = tv;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tuneChannel</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteRemoteControl1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RemoteControl</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteRemoteControl1</span><span class="hljs-params">(TV tv)</span> &#123;        <span class="hljs-built_in">super</span>(tv);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;ConcreteRemoteControl1.on()&quot;</span>);        tv.on();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;ConcreteRemoteControl1.off()&quot;</span>);        tv.off();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tuneChannel</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;ConcreteRemoteControl1.tuneChannel()&quot;</span>);        tv.tuneChannel();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteRemoteControl2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RemoteControl</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteRemoteControl2</span><span class="hljs-params">(TV tv)</span> &#123;        <span class="hljs-built_in">super</span>(tv);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;ConcreteRemoteControl2.on()&quot;</span>);        tv.on();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;ConcreteRemoteControl2.off()&quot;</span>);        tv.off();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tuneChannel</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;ConcreteRemoteControl2.tuneChannel()&quot;</span>);        tv.tuneChannel();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">RemoteControl</span> <span class="hljs-variable">remoteControl1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteRemoteControl1</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RCA</span>());        remoteControl1.on();        remoteControl1.off();        remoteControl1.tuneChannel();        <span class="hljs-type">RemoteControl</span> <span class="hljs-variable">remoteControl2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteRemoteControl2</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sony</span>());         remoteControl2.on();         remoteControl2.off();         remoteControl2.tuneChannel();    &#125;&#125;</code></pre></div><h3 id="JDK-16"><a href="#JDK-16" class="headerlink" title="JDK"></a>JDK</h3><ul><li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li><li>JDBC</li></ul><h2 id="3-组合（Composite）"><a href="#3-组合（Composite）" class="headerlink" title="3. 组合（Composite）"></a>3. 组合（Composite）</h2><h3 id="Intent-20"><a href="#Intent-20" class="headerlink" title="Intent"></a>Intent</h3><p>将对象组合成树形结构来表示“整体&#x2F;部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p><h3 id="Class-Diagram-20"><a href="#Class-Diagram-20" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p><p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_147.png" alt="img"></p><h3 id="Implementation-20"><a href="#Implementation-20" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">protected</span> String name;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Component</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;        print(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>;    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span>;    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">private</span> List&lt;Component&gt; child;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Composite</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">super</span>(name);        child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;Composite:&quot;</span> + name);        <span class="hljs-keyword">for</span> (Component component : child) &#123;            component.print(level + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;        child.add(component);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;        child.remove(component);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Leaf</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">super</span>(name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;left:&quot;</span> + name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); <span class="hljs-comment">// 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Composite</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;root&quot;</span>);        <span class="hljs-type">Component</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;1&quot;</span>);        <span class="hljs-type">Component</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;2&quot;</span>);        <span class="hljs-type">Component</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;3&quot;</span>);        root.add(node1);        root.add(node2);        root.add(node3);        <span class="hljs-type">Component</span> <span class="hljs-variable">node21</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;21&quot;</span>);        <span class="hljs-type">Component</span> <span class="hljs-variable">node22</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;22&quot;</span>);        node2.add(node21);        node2.add(node22);        <span class="hljs-type">Component</span> <span class="hljs-variable">node221</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;221&quot;</span>);        node22.add(node221);        root.print();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ldif"><span class="hljs-attribute">Composite</span>:root<span class="hljs-literal">-</span>-left:1<span class="hljs-literal">-</span>-Composite:2<span class="hljs-literal">-</span>---left:21<span class="hljs-literal">-</span>---Composite:22<span class="hljs-literal">-</span>-----left:221<span class="hljs-literal">-</span>-left:3</code></pre></div><h3 id="JDK-17"><a href="#JDK-17" class="headerlink" title="JDK"></a>JDK</h3><ul><li>javax.swing.JComponent#add(Component)</li><li>java.awt.Container#add(Component)</li><li>java.util.Map#putAll(Map)</li><li>java.util.List#addAll(Collection)</li><li>java.util.Set#addAll(Collection)</li></ul><h2 id="4-装饰（Decorator）"><a href="#4-装饰（Decorator）" class="headerlink" title="4. 装饰（Decorator）"></a>4. 装饰（Decorator）</h2><h3 id="Intent-21"><a href="#Intent-21" class="headerlink" title="Intent"></a>Intent</h3><p>为对象动态添加功能。</p><h3 id="Class-Diagram-21"><a href="#Class-Diagram-21" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_151.png" alt="img"></p><h3 id="Implementation-21"><a href="#Implementation-21" class="headerlink" title="Implementation"></a>Implementation</h3><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p><p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p><p><img src="https://www.xuxueli.com/blog/static/images/img_169.jpg" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DarkRoast</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseBlend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CondimentDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-keyword">protected</span> Beverage beverage;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Milk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CondimentDecorator</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Milk</span><span class="hljs-params">(Beverage beverage)</span> &#123;        <span class="hljs-built_in">this</span>.beverage = beverage;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + beverage.cost();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CondimentDecorator</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mocha</span><span class="hljs-params">(Beverage beverage)</span> &#123;        <span class="hljs-built_in">this</span>.beverage = beverage;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + beverage.cost();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Beverage</span> <span class="hljs-variable">beverage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HouseBlend</span>();        beverage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mocha</span>(beverage);        beverage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Milk</span>(beverage);        System.out.println(beverage.cost());    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">0</span></code></pre></div><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p><p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p><h3 id="JDK-18"><a href="#JDK-18" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.io.BufferedInputStream(InputStream)</li><li>java.io.DataInputStream(InputStream)</li><li>java.io.BufferedOutputStream(OutputStream)</li><li>java.util.zip.ZipOutputStream(OutputStream)</li><li>java.util.Collections#checked<a href="https://www.xuxueli.com/blog/?blog=./notebook/2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md">List|Map|Set|SortedSet|SortedMap</a></li></ul><h2 id="5-外观（Facade）"><a href="#5-外观（Facade）" class="headerlink" title="5. 外观（Facade）"></a>5. 外观（Facade）</h2><h3 id="Intent-22"><a href="#Intent-22" class="headerlink" title="Intent"></a>Intent</h3><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p><h3 id="Class-Diagram-22"><a href="#Class-Diagram-22" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><img src="https://www.xuxueli.com/blog/static/images/img_178.png" alt="img"></p><h3 id="Implementation-22"><a href="#Implementation-22" class="headerlink" title="Implementation"></a>Implementation</h3><p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystem</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnOnTV</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;turnOnTV()&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCD</span><span class="hljs-params">(String cd)</span> &#123;        System.out.println(<span class="hljs-string">&quot;setCD( &quot;</span> + cd + <span class="hljs-string">&quot; )&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startWatching</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;startWatching()&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystem</span> <span class="hljs-variable">subSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystem</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchMovie</span><span class="hljs-params">()</span> &#123;        subSystem.turnOnTV();        subSystem.setCD(<span class="hljs-string">&quot;a movie&quot;</span>);        subSystem.startWatching();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();        facade.watchMovie();    &#125;&#125;###</code></pre></div><p>设计原则</p><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p><h2 id="6-享元（Flyweight）"><a href="#6-享元（Flyweight）" class="headerlink" title="6. 享元（Flyweight）"></a>6. 享元（Flyweight）</h2><h3 id="Intent-23"><a href="#Intent-23" class="headerlink" title="Intent"></a>Intent</h3><p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p><h3 id="Class-Diagram-23"><a href="#Class-Diagram-23" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Flyweight：享元对象</li><li>IntrinsicState：内部状态，享元对象共享内部状态</li><li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_150.png" alt="img"></p><h3 id="Implementation-23"><a href="#Implementation-23" class="headerlink" title="Implementation"></a>Implementation</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOperation</span><span class="hljs-params">(String extrinsicState)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-keyword">private</span> String intrinsicState;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteFlyweight</span><span class="hljs-params">(String intrinsicState)</span> &#123;        <span class="hljs-built_in">this</span>.intrinsicState = intrinsicState;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOperation</span><span class="hljs-params">(String extrinsicState)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Object address: &quot;</span> + System.identityHashCode(<span class="hljs-built_in">this</span>));        System.out.println(<span class="hljs-string">&quot;IntrinsicState: &quot;</span> + intrinsicState);        System.out.println(<span class="hljs-string">&quot;ExtrinsicState: &quot;</span> + extrinsicState);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;    <span class="hljs-keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String intrinsicState)</span> &#123;        <span class="hljs-keyword">if</span> (!flyweights.containsKey(intrinsicState)) &#123;            <span class="hljs-type">Flyweight</span> <span class="hljs-variable">flyweight</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>(intrinsicState);            flyweights.put(intrinsicState, flyweight);        &#125;        <span class="hljs-keyword">return</span> flyweights.get(intrinsicState);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">FlyweightFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyweightFactory</span>();        <span class="hljs-type">Flyweight</span> <span class="hljs-variable">flyweight1</span> <span class="hljs-operator">=</span> factory.getFlyweight(<span class="hljs-string">&quot;aa&quot;</span>);        <span class="hljs-type">Flyweight</span> <span class="hljs-variable">flyweight2</span> <span class="hljs-operator">=</span> factory.getFlyweight(<span class="hljs-string">&quot;aa&quot;</span>);        flyweight1.doOperation(<span class="hljs-string">&quot;x&quot;</span>);        flyweight2.doOperation(<span class="hljs-string">&quot;y&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Object address</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1163157884</span><span class="hljs-attribute">IntrinsicState</span><span class="hljs-punctuation">:</span> <span class="hljs-string">aa</span><span class="hljs-attribute">ExtrinsicState</span><span class="hljs-punctuation">:</span> <span class="hljs-string">x</span><span class="hljs-attribute">Object address</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1163157884</span><span class="hljs-attribute">IntrinsicState</span><span class="hljs-punctuation">:</span> <span class="hljs-string">aa</span><span class="hljs-attribute">ExtrinsicState</span><span class="hljs-punctuation">:</span> <span class="hljs-string">y</span></code></pre></div><h3 id="JDK-19"><a href="#JDK-19" class="headerlink" title="JDK"></a>JDK</h3><p>Java 利用缓存来加速大量小对象的访问时间。</p><ul><li>java.lang.Integer#valueOf(int)</li><li>java.lang.Boolean#valueOf(boolean)</li><li>java.lang.Byte#valueOf(byte)</li><li>java.lang.Character#valueOf(char)</li></ul><h2 id="7-代理（Proxy）"><a href="#7-代理（Proxy）" class="headerlink" title="7. 代理（Proxy）"></a>7. 代理（Proxy）</h2><h3 id="Intent-24"><a href="#Intent-24" class="headerlink" title="Intent"></a>Intent</h3><p>控制对其它对象的访问。</p><h3 id="Class-Diagram-24"><a href="#Class-Diagram-24" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>代理有以下四类：</p><ul><li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li><li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li><li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li><li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li></ul><p><img src="https://www.xuxueli.com/blog/static/images/img_153.png" alt="img"></p><h3 id="Implementation-24"><a href="#Implementation-24" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">showImage</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HighResolutionImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">private</span> URL imageURL;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> startTime;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> height;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> width;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> height;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> width;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HighResolutionImage</span><span class="hljs-params">(URL imageURL)</span> &#123;        <span class="hljs-built_in">this</span>.imageURL = imageURL;        <span class="hljs-built_in">this</span>.startTime = System.currentTimeMillis();        <span class="hljs-built_in">this</span>.width = <span class="hljs-number">600</span>;        <span class="hljs-built_in">this</span>.height = <span class="hljs-number">600</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLoad</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 模拟图片加载，延迟 3s 加载完成</span>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">return</span> endTime - startTime &gt; <span class="hljs-number">3000</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showImage</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Real Image: &quot;</span> + imageURL);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">private</span> HighResolutionImage highResolutionImage;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ImageProxy</span><span class="hljs-params">(HighResolutionImage highResolutionImage)</span> &#123;        <span class="hljs-built_in">this</span>.highResolutionImage = highResolutionImage;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showImage</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">while</span> (!highResolutionImage.isLoad()) &#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(<span class="hljs-string">&quot;Temp Image: &quot;</span> + highResolutionImage.getWidth() + <span class="hljs-string">&quot; &quot;</span> + highResolutionImage.getHeight());                Thread.sleep(<span class="hljs-number">100</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        highResolutionImage.showImage();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageViewer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://image.jpg&quot;</span>;        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(image);        <span class="hljs-type">HighResolutionImage</span> <span class="hljs-variable">highResolutionImage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HighResolutionImage</span>(url);        <span class="hljs-type">ImageProxy</span> <span class="hljs-variable">imageProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageProxy</span>(highResolutionImage);        imageProxy.showImage();    &#125;&#125;</code></pre></div><h3 id="JDK-20"><a href="#JDK-20" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.lang.reflect.Proxy</li><li>RMI</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li>Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.</li><li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li><li><a href="http://www.oodesign.com/">Design Patterns</a></li><li><a href="http://java-design-patterns.com/">Design patterns implemented in Java</a></li><li><a href="http://www.programering.com/a/MTNxAzMwATY.html">The breakdown of design patterns in JDK</a></li></ul><p>转载：</p><p><a href="https://www.xuxueli.com/blog/?blog=./notebook/2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#JDK">设计模式 (xuxueli.com)</a></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2022/06/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/06/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、常用的基本命令"><a href="#一、常用的基本命令" class="headerlink" title="一、常用的基本命令"></a>一、常用的基本命令</h2><h3 id="1-目录管理"><a href="#1-目录管理" class="headerlink" title="1.目录管理"></a>1.目录管理</h3><ul><li><p>ls:   #列出目录</p><p>​    -a:   #参数: all ,查看全部的文件,包括隐藏文件</p><p>​    -l:   #参数 列出所有的文件,包含文件的属性和权限,没有隐藏文件</p><p>cd：  #切换目录</p><p>&#x2F;cd   #当前目录</p><p>cd .. #返回上一级目录</p><p>cd &#x2F;…&#x2F;… #切换绝对路径</p><p>cd …&#x2F;…. #切换相对路径</p><p>pwd       #显示用户所在的目录</p><p>mkdir     #创建一个新的目录</p><p>mkdir -p  #创建多层目录</p><p>rmdir：   #删除一个空的目录</p><p>rmdir -p  #删除多层空的目录</p><p>cp:       #复制文件或目录 在文件所在目录执行 cp 要复制的文件 目标路径&#x2F;</p><p>rm:       #移除文件或目录</p><p>​    rm -f   #忽略不存在的文件，不会出现警告，强制删除！</p><p>​    rm -r    #递归删除</p><p>​    rm -i   #互动</p><p>​    rm -rf  #相当于删库跑路</p><p>mv:         #移动文件与目录，或修改文件与目录的名称 在文件所在目录执行 mv 要移动的文件 目标路径&#x2F;</p><p>​    mv -f     #强制v</p><p>​    mv -u     #只替换更新后的文件</p><p>hostname name      #修改主机名</p><p>tar -zxvf tar.gz   #解压命令</p></li></ul><h3 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h3><p>1.在linux中，每一个程序都有一个自己的进程，每一个进程都有一个id号</p><p>2.每一个进程，都会有一个父进程</p><p>3.进程可以有两种存在方式：前台，后台</p><p>4.一般服务都是后台运行的，基本的程序都是前台运行的</p><blockquote><p>查看进程</p></blockquote><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">ps</span>     <span class="hljs-comment">#看当前系统中正在执行的各种进程信息：</span><span class="hljs-attr">ps-xx:</span>  <span class="hljs-string">-a</span>   <span class="hljs-comment">#显示当期终端运行的所有的进行信息（当前的进程）</span>  <span class="hljs-string">-u</span>   <span class="hljs-comment">#以用户的信息显示进程</span>  <span class="hljs-string">-x</span>    <span class="hljs-comment">#显示后台运行进程的参数 比如jar包 java-jar xxxx.jar</span><span class="hljs-string">ps</span> <span class="hljs-string">-aux</span> <span class="hljs-string">|</span>     <span class="hljs-comment">#查看所有进程</span><span class="hljs-string">ps</span> <span class="hljs-string">-aux</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span>  <span class="hljs-string">mysql</span>    <span class="hljs-comment">#查看mysql的进程</span>    <span class="hljs-comment"># | 管道符  A|B</span>    <span class="hljs-comment">#grep   查看文件中符合条件中的字符串</span>    <span class="hljs-comment">#查看父进程的信息</span><span class="hljs-attr">ps -ef:</span>   <span class="hljs-comment">#可以看到父进程的信息</span><span class="hljs-comment">#进程树</span><span class="hljs-string">pstree</span> <span class="hljs-string">-pu</span>      <span class="hljs-string">-p</span>   <span class="hljs-comment">#显示父级 id</span>    <span class="hljs-string">-u</span>   <span class="hljs-comment">#显示子集 id</span></code></pre></div><blockquote><p>结束进程</p></blockquote><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9   <span class="hljs-comment">#强制杀死进程</span></code></pre></div><h3 id="3-修改文件属性"><a href="#3-修改文件属性" class="headerlink" title="3.修改文件属性"></a>3.修改文件属性</h3><p><strong>3.1、chgrp：更改文件属组</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">chgrp</span> [-R] 属组名 文件名</code></pre></div><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p><strong>3.2、chown：更改文件属主，也可以同时更改文件属组</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [–R] 属主名 文件名<span class="hljs-built_in">chown</span> [-R] 属主名：属组名 文件名</code></pre></div><p><strong>3.3、chmod：更改文件9个属性</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录</code></pre></div><p>Linux文件属性有两种设置方法，一种是数字（常用的是数据），一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner&#x2F;group&#x2F;others三种身份各有自己的read&#x2F;write&#x2F;execute权限。</p><p>文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">r:4     w:2         x:1</span>可读可写可执行    rwx  7可读可写不可执行  rw-  6</code></pre></div><h3 id="4-文件内容查看"><a href="#4-文件内容查看" class="headerlink" title="4.文件内容查看"></a>4.文件内容查看</h3><blockquote><p>概述</p></blockquote><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li><p>cat    #由第一行开始显示文件内容</p><p>tac    #从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</p><p>nl     #显示的时候，顺道输出行号！</p><p>more   #一页一页的显示文件内容 空格代表翻页，回车代表向下看一行，：f 显示行号。</p><p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ 上下键可以实现上下翻页</p><p>空白键 ：向下翻动一页；</p><p>[pagedown]：向下翻动一页；</p><p>[pageup] ：向上翻动一页；</p><p>&#x2F;字串 ：向下搜寻『字串』的功能；</p><p>?字串 ：向上搜寻『字串』的功能；</p><p>n ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</p><p>N ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</p><p>q ：离开 less 这个程序</p><p>head 只看头几行 -n 后面接数字，代表显示几行的意思！</p><p>tail 只看尾巴几行</p></li></ul><h3 id="5-安装软件"><a href="#5-安装软件" class="headerlink" title="5.安装软件"></a>5.安装软件</h3><p>软件安装一般有三种方式：</p><ul><li>rpm</li><li>解压缩</li><li>yum在线安装</li></ul><p>5.1.jdk安装（rpm安装）</p><p>1、rpm下载地址[Java Downloads | Oracle](<a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a>)</p><p>2、如果有安装openjdk 则卸载</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#查看jdk版本    java -versionjava version </span><span class="hljs-comment">#检查              rpm -qa|grep jdk </span><span class="hljs-comment">#卸载              -e --nodeps </span><span class="hljs-comment">#强制删除       rpm -e --nodeps jdk对应的信息</span></code></pre></div><p>3、安装JDK</p><div class="code-wrapper"><pre><code class="hljs ruby"><span class="hljs-comment"># 安装                    rpm -ivh jdk-8u221-linux-x64.rpm</span><span class="hljs-comment"># 安装完成后配置环境变量 文件： 打开 vim /etc/profile </span>    <span class="hljs-variable constant_">JAVA_HOME</span>=<span class="hljs-regexp">/usr/java</span><span class="hljs-regexp">/jdk1.8.0_221amd64   (注意java安装路径)</span><span class="hljs-regexp">    CLASSPATH=%JAVA_HOME%/lib</span><span class="hljs-symbol">:%JAVA_HOME<span class="hljs-string">%/jre/</span>libPATH=</span><span class="hljs-variable">$PATH</span><span class="hljs-symbol">:</span><span class="hljs-variable">$</span><span class="hljs-variable"></span>    <span class="hljs-variable constant_">JAVA_HOME</span>/<span class="hljs-symbol">bin:</span><span class="hljs-variable">$JAVA_HOME</span>/jre/bin    export <span class="hljs-variable constant_">PATH</span> <span class="hljs-variable constant_">CLASSPATH</span> <span class="hljs-variable constant_">JAVA_HOME</span><span class="hljs-comment"># </span><span class="hljs-comment"># 让新增的环境变量生效！     source /etc/profile</span><span class="hljs-comment"># 测试                    java -version</span></code></pre></div><p>5.2.Tomcat安装（解压缩安装）</p><p>1、将文件移动到&#x2F;usr&#x2F;tomcat&#x2F;下，并解压！</p><div class="code-wrapper"><pre><code class="hljs bash">tar -zxvf 文件名.tar.gz   <span class="hljs-comment"># 解压</span></code></pre></div><p>2、运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的(.sh win下是bat)</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行:  ./startup.sh     --&gt;启动tomcats</span><span class="hljs-meta prompt_"># </span><span class="language-bash">停止:  ./shutdown.sh    --&gt;关闭tomcats</span></code></pre></div><p>3、确保Linux的防火墙端口是开启的</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 查看firewall服务状态</span>systemctl status firewalld<span class="hljs-comment"># 开启、重启、关闭、firewalld.service服务</span>service firewalld start     <span class="hljs-comment"># 开启</span>service firewalld restart   <span class="hljs-comment"># 重启</span>service firewalld stop      <span class="hljs-comment"># 关闭</span><span class="hljs-comment"># 查看防火墙规则</span>firewall-cmd --list-all     <span class="hljs-comment"># 查看全部信息</span>firewall-cmd --list-ports   <span class="hljs-comment"># 只看端口信息</span><span class="hljs-comment"># 开启端口</span><span class="hljs-comment">#开端口命令：</span>firewall-cmd <span class="hljs-attr">--zone</span>=public --add-port=<span class="hljs-number">80</span>/tcp --permanent   <span class="hljs-comment">#打开80端口</span><span class="hljs-comment">#重启防火墙：</span>systemctl restart firewalld.service命令含义：--zone              <span class="hljs-comment">#作用域</span><span class="hljs-attr">--add-port</span>=<span class="hljs-number">80</span>/tcp   <span class="hljs-comment">#添加端口，格式为：端口/通讯协议</span>--permanent         <span class="hljs-comment">#永久生效，没有此参数重启后失效</span></code></pre></div><p>5.3.安装Docker（yum安装）</p><blockquote><p>基于 CentOS 7 安装</p></blockquote><ol><li><p>官网安装</p></li><li><p>确定你是CentOS7及以上版本</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/redhat-release</code></pre></div></li><li><p>yum安装gcc相关（需要确保 虚拟机可以上外网 ）</p><div class="code-wrapper"><pre><code class="hljs shell">yum -y install gcc   #yum -y install 包名  -y 所有的提示都为 yyum -y install gcc-c++</code></pre></div></li><li><p>卸载旧版本</p><div class="code-wrapper"><pre><code class="hljs shell">yum -y remove docker docker-common docker-selinux docker-engine # 官网版本yum remove docker \              docker-client \              docker-client-latest \              docker-common \              docker-latest \              docker-latest-logrotate \              docker-logrotate \              docker-engine</code></pre></div></li><li><p>安装需要的软件包</p><div class="code-wrapper"><pre><code class="hljs shell">yum install -y yum-utils\device-mapper-persistent-data \lvm2</code></pre></div></li><li><p>安装</p><div class="code-wrapper"><pre><code class="hljs shell">sudo yum install -y yum-utilssudo yum-config-manager \   --add-repo \   https://download.docker.com/linux/centos/docker-ce.repo</code></pre></div></li><li><p>更新yum软件包索引</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span></code></pre></div></li><li><p>安装Docker CE</p><div class="code-wrapper"><pre><code class="hljs shell">yum -y install docker-ce docker-ce-cli containerd.io</code></pre></div></li><li><p>启动docker</p><div class="code-wrapper"><pre><code class="hljs shell">systemctl start docker</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre><code class="hljs shell">docker versiondocker run hello-worlddocker images</code></pre></div></li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58f6747bc3c04e8e8956fbc8b9709aba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="6-Vim编辑器"><a href="#6-Vim编辑器" class="headerlink" title="6.Vim编辑器"></a>6.Vim编辑器</h3><blockquote><p>三种使用模式</p></blockquote><p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong> ，<strong>输入模式（Insert mode）</strong> 和<strong>底线命令模式（Last line mode）</strong> 。这三种模式的作用分别是：</p><p><strong>命令模式：</strong></p><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><ul><li><p>i 切换到输入模式，以输入字符。</p><p>x 删除当前光标所在处的字符。</p><p>: 切换到底线命令模式，以在最底一行输入命令。如果是编辑模式，需要先退出编辑模式</p></li></ul><p><strong>输入模式：</strong></p><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li><li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li><li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><p><strong>底线命令模式</strong></p><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>vim 文件名 如果文件存在进入命令模式， 不存在就新建文件</p><p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p><table><thead><tr><th>移动光标的方法</th><th></th></tr></thead><tbody><tr><td>h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td>[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td>[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td>[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td>[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td>+</td><td>光标移动到非空格符的下一行</td></tr><tr><td>-</td><td>光标移动到非空格符的上一行</td></tr><tr><td>n&lt; space&gt;</td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td></tr><tr><td>0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td>$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td>H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td>M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td>L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td>G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td>nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td>gg</td><td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td></tr><tr><td>n&lt; Enter&gt;</td><td>n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><table><thead><tr><th>搜索替换</th><th></th></tr></thead><tbody><tr><td>&#x2F;word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！(常用)</td></tr><tr><td>?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td>n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td>N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr></tbody></table><table><thead><tr><th>删除、复制与粘贴</th><th></th></tr></thead><tbody><tr><td>x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td>nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td>dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td>ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td>d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td>dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td>d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td>d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td>yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td>nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td>y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td>yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td>y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td>y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td>p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td></tr><tr><td>J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td>c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td>u</td><td>复原前一个动作。(常用) 相当有Win下面的ctrl+z</td></tr><tr><td>[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr></tbody></table><p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p><table><thead><tr><th>进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td>i, I</td><td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td></tr><tr><td>a, A</td><td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td>o, O</td><td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td>r, R</td><td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td>[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p><table><thead><tr><th>指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td>:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td>:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td>:q</td><td>离开 vi (常用)</td></tr><tr><td>:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td>:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td>ZZ</td><td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td>:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td>:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td>:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td>:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中看 &#x2F;home 底下以 ls 输出的档案信息！</td></tr><tr><td>:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td>:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><h3 id="7-基本属性"><a href="#7-基本属性" class="headerlink" title="7.基本属性"></a>7.基本属性</h3><p>十个字母</p><p><img src="/../images/linux1.jpg" alt="img"></p><p>第一个root属主 谁创建的</p><p>第二个root属组 用户组，谁有权限</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p><p><img src="/../images/linux2.jpg" alt="img"></p><h3 id="8-账号管理"><a href="#8-账号管理" class="headerlink" title="8.账号管理"></a>8.账号管理</h3><blockquote><p>简介</p></blockquote><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>8.1.添加账号</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">useradd</span> 选项 用户名</code></pre></div><p>参数说明：</p><ul><li>选项 :<ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-m　使用者目录如不存在则自动建立。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul></li><li>用户名 :<ul><li>指定新账号的登录名。</li></ul></li></ul><p>查看用户 cat &#x2F;etc&#x2F;passwd</p><p>8.2.切换用户</p><p>1.切换用户的命令为：su username 【username是你的用户名哦】</p><p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p><p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p><p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p><p>$表示普通用户</p><p>#表示超级用户，也就是root用户</p><p>8.3.删除账户</p><p>删除用户账号就是要将&#x2F;etc&#x2F;passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">userdel</span> 选项 用户名</code></pre></div><p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p><p>8.4.修改帐号</p><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><p>修改已有用户的信息使用usermod命令，其格式如下：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">usermod</span> 选项 用户名</code></pre></div><p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p><p>8.5.口令的管理</p><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p><p>passwd 用户名 为账户添加密码</p><p>命令的格式为：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">passwd</span> 选项 用户名</code></pre></div><p>可使用的选项：</p><ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁，解锁账号</li><li>-d 使账号无口令。 此命令将用户 kuangshen的口令删除 ， 系统就不再允许该用户登录了</li><li>-f 强迫用户下次登录时修改口令。</li></ul><h3 id="9-用户组管理"><a href="#9-用户组管理" class="headerlink" title="9.用户组管理"></a>9.用户组管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新。</p><p>9.1.添加用户组</p><ul><li>groupadd 选项 用户组<ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul></li></ul><p>创建组 groupadd wdh</p><p>创建组之后可以查看组ID cat &#x2F;etc&#x2F;group</p><p><img src="/../images/linux3.jpg" alt="img"></p><p>9.2.删除用户组</p><p>groupdel 用户组</p><p>9.3.修改属性</p><p>groupmod 选项 用户组</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p>9.4.切换组</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">newgrp root</span></code></pre></div><p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p><p>9.5.&#x2F;etc&#x2F;passwd</p><p>&#x2F;etc&#x2F;passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span></code></pre></div><p>1）”用户名”是代表用户账号的字符串。</p><p>2）“口令”一些系统中，存放着加密后的用户口令字。</p><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><p>4）“组标识号”字段记录的是用户所属的用户组。</p><p>它对应着&#x2F;etc&#x2F;group文件中的一条记录。</p><p>5)“注释性描述”字段记录着用户的一些个人情况。</p><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p><p>6)“主目录”，也就是用户的起始工作目录。</p><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p><p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。</p><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><p>8)系统中有一类用户称为伪用户（pseudo users）。</p><p>这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p><p>常见的伪用户如下所示：</p><p>伪 用 户 含 义bin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用</p><p>9.6&#x2F;etc&#x2F;shadow</p><p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p><p>由于&#x2F;etc&#x2F;passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p><p><strong>2、&#x2F;etc&#x2F;shadow中的记录行与&#x2F;etc&#x2F;passwd中的一一对应，它由pwconv命令根据&#x2F;etc&#x2F;passwd中的数据自动产生</strong></p><p>它的文件格式与&#x2F;etc&#x2F;passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span></code></pre></div><ol><li>“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号</li><li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li><li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li><li>“最大时间间隔”指的是口令保持有效的最大天数。</li><li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ol><p>9.7&#x2F;etc&#x2F;group</p><p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。</p><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p><p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p><p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">组名:口令:组标识号:组内用户列表</span></code></pre></div><ol><li>“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。</li><li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li><li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>“组内用户列表”是属于这个组的所有用户的列表&#x2F;b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ol><h3 id="10-磁盘管理"><a href="#10-磁盘管理" class="headerlink" title="10.磁盘管理"></a>10.磁盘管理</h3><blockquote><p>概述</p></blockquote><p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p><p>Linux磁盘管理常用命令为 df、du。</p><ul><li>df ：列出文件系统的整体磁盘使用量</li><li>du：检查磁盘空间使用量</li></ul><blockquote><p>df</p></blockquote><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs shell">df [-ahikHTm] [目录或文件名]</code></pre></div><p>选项与参数：</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li><li>-k ：以 KBytes 的容量显示各文件系统；</li><li>-m ：以 MBytes 的容量显示各文件系统；</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li><li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><blockquote><p>du</p></blockquote><p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> [-ahskm] 文件或目录名称</code></pre></div><p>选项与参数：</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><h2 id="二、Linux-目录结构"><a href="#二、Linux-目录结构" class="headerlink" title="二、Linux 目录结构"></a>二、Linux 目录结构</h2><p><img src="/../images/linux4.jpg" alt="img"></p><p>&#x2F;bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p><p>&#x2F;boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><p>&#x2F;dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p><p><strong>&#x2F;etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><p>&#x2F;home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p><p>&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</p><p>&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><p>&#x2F;media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p><p>&#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</p><p>&#x2F;opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p><p>&#x2F;proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p><p>&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。 &#x2F;sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p><p>&#x2F;srv：该目录存放一些服务启动之后需要提取的数据。</p><p>&#x2F;sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p><p>&#x2F;tmp：这个目录是用来存放一些临时文件的。 用完即丢的文件可以放在这个目录下，用完就丢掉的文件，可以放安装包</p><p>&#x2F;usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 &#x2F;usr&#x2F;bin： 系统用户使用的应用程序。</p><p>&#x2F;usr&#x2F;sbin： 超级用户使用的比较高级的管理程序和系统守护程序。</p><p>&#x2F;usr&#x2F;src： 内核源代码默认的放置目录。</p><p>&#x2F;var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 &#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</p><p>&#x2F;www：存放服务器网站相关的资源，环境，网站的项目</p><p>Linux中一切皆文件</p>]]></content>
    
    
    <categories>
      
      <category>通用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js基础学习笔记</title>
    <link href="/2022/05/10/js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/10/js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 <code>script</code> 标签将 JavaScript 代码引入到 HTML 中，有两种方式：</p><h4 id="内部方式"><a href="#内部方式" class="headerlink" title="内部方式"></a>内部方式</h4><p>通过 <code>script</code> 标签包裹 JavaScript 代码</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 内联形式：通过 script 标签包裹 JavaScript 代码 --&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello,world!&#x27;</span>)</span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h4 id="外部形式"><a href="#外部形式" class="headerlink" title="外部形式"></a>外部形式</h4><p>一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 <code>script</code> 标签的 <code>src</code> 属性引入</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// demo.js</span><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hello,world!&#x27;</span>)js复制代码&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p>如果 script 标签使用 src 属性引入了某 .js 文件，那么 标签的代码会被忽略！如下代码所示：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.js&quot;</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 此处写的代码会被忽略掉！！！！</span></span></span><span class="language-javascript"><span class="language-xml">    </span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h3 id="注释和结束符"><a href="#注释和结束符" class="headerlink" title="注释和结束符"></a>注释和结束符</h3><p>通过注释可以屏蔽代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法：</p><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><p>使用 <code>//</code> 注释单行代码： 快捷键：ctrl+&#x2F;</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 注释<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 这种是单行注释的语法</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 一次只能注释一行</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 可以重复注释</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;嗨，欢迎来传智播学习前端技术！&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><p>使用 <code>/* */</code> 注释多行代码</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 注释<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">/* 这种的是多行注释的语法 */</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">/*</span></span></span><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">    更常见的多行注释是这种写法</span></span></span><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">    在些可以任意换行</span></span></span><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">    多少行都可以</span></span></span><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">      */</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hello,world!&#x27;</span>);</span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h3 id="结束符"><a href="#结束符" class="headerlink" title="结束符"></a>结束符</h3><p>在 JavaScript 中 <code>;</code> 代表一段代码的结束，多数情况下可以省略 <code>;</code> 使用回车（enter）替代。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 结束符<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> </span><span class="language-xml">    alert(1);</span><span class="language-xml">    alert(2);</span><span class="language-xml">    alert(1)</span><span class="language-xml">    alert(2)</span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。</p><p>举例说明：如按键盘上的方向键，向上&#x2F;下键可以滚动页面，按向上&#x2F;下键这个动作叫作输入，页面发生了滚动了这便叫输出。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>JavaScript 可以接收用户的输入，然后再将输入的结果输出：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">alert</span><span class="hljs-params">()</span></span>`、`document<span class="hljs-selector-class">.wirte</span>()</code></pre></div><p>以数字为例，向 <code>alert()</code> 或 <code>document.write()</code>输入任意数字，他都会以弹窗形式展示（输出）给用户。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>向 <code>prompt()</code> 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 输入输出<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><span class="language-javascript">    <span class="hljs-comment">// 1. 输入的任意数字，都会以弹窗形式展示</span></span><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;要输出的内容&#x27;</span>)</span><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;要输出的内容&#x27;</span>);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号</span></span><span class="language-javascript">    <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入您的姓名:&#x27;</span>)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>理解变量是计算机存储数据的“容器”，掌握变量的声明方式</p></blockquote><p>变量是计算机中用来存储数据的“容器”，它可以让计算机变得有记忆，通俗的理解变量就是使用【某个符号】来代表【某个具体的数值】（数据）</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;  <span class="hljs-comment">// x 符号代表了 5 这个数值</span>  x = <span class="hljs-number">5</span>  <span class="hljs-comment">// y 符号代表了 6 这个数值</span>  y = <span class="hljs-number">6</span>      <span class="hljs-comment">//举例： 在 JavaScript 中使用变量可以将某个数据（数值）记录下来！</span>  <span class="hljs-comment">// 将用户输入的内容保存在 num 这个变量（容器）中</span>  num = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入一数字!&#x27;</span>)  <span class="hljs-comment">// 通过 num 变量（容器）将用户输入的内容输出出来</span>  <span class="hljs-title function_">alert</span>(num)  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(num)&lt;/script&gt;</code></pre></div><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明(定义)变量有两部分构成：声明关键字、变量名（标识） <code>let</code> 和 <code>var</code> 都是 JavaScript 中的声明变量的关键字，推荐使用 <code>let</code> 声明变量！！！</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 声明和赋值<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// let 变量名</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 声明(定义)变量有两部分构成：声明关键字、变量名（标识）</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// age 即变量的名称，也叫标识符</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> age</span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p>关键字是 JavaScript 中内置的一些英文词汇（单词或缩写），它们代表某些特定的含义，如 <code>let</code> 的含义是声明变量的，看到 <code>let</code> 后就可想到这行代码的意思是在声明变量，如 <code>let age;</code></p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 声明和赋值<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 声明(定义)变量有两部分构成：声明关键字、变量名（标识）</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// age 即变量的名称，也叫标识符</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> age</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 赋值，将 18 这个数据存入了 age 这个“容器”中</span></span></span><span class="language-javascript"><span class="language-xml">    age = <span class="hljs-number">18</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 这样 age 的值就成了 18</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(age)</span></span><span class="language-javascript"><span class="language-xml">    </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 也可以声明和赋值同时进行</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world!&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(str);</span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>JavaScript 使用专门的关键字 <code>let</code> 和 <code>var</code> 来声明（定义）变量，在使用时需要注意一些细节：</p><p>以下是使用 <code>let</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>不允许重复声明</li><li>允许同时声明多个变量并赋值</li><li>JavaScript 中内置的一些关键字不能被当做变量名</li></ol><p>以下是使用 <code>var</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>允许重复声明</li><li>允许同时声明多个变量并赋值</li></ol><p>大部分情况使用 <code>let</code> 和 <code>var</code> 区别不大，但是 <code>let</code> 相较 <code>var</code> 更严谨，因此推荐使用 <code>let</code>，后期会更进一步介绍二者间的区别。</p><h3 id="变量名命名规则"><a href="#变量名命名规则" class="headerlink" title="变量名命名规则"></a>变量名命名规则</h3><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p><ol><li>只能是字母、数字、下划线、$，且不能能以数字开头</li><li>字母区分大小写，如 Age 和 age 是不同的变量</li><li>JavaScript 内部已占用于单词（关键字或保留字）不允许使用</li><li>尽量保证变量词能达意</li></ol><p>注：所谓关键字是指 JavaScript 内部使用的词语，如 <code>let</code> 和<code>var</code>，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 变量名命名规则<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span> <span class="hljs-comment">// 正确</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> age1 = <span class="hljs-number">18</span> <span class="hljs-comment">// 正确</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> _age = <span class="hljs-number">18</span> <span class="hljs-comment">// 正确</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// let 1age = 18; // 错误，不可以数字开头</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> $age = <span class="hljs-number">18</span> <span class="hljs-comment">// 正确</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Age</span> = <span class="hljs-number">24</span> <span class="hljs-comment">// 正确，它与小写的 age 是不同的变量</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// let let = 18; // 错误，let 是关键字</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> int = <span class="hljs-number">123</span> <span class="hljs-comment">// 不推荐，int 是保留字</span></span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>概念：使用 const 声明的变量称为“常量”。</p><p>使用场景：当某个变量永远不会改变的时候，就可以使用 const 来声明，而不是let。</p><p>命名规范：和变量一致</p><div class="code-wrapper"><pre><code class="hljs ini">const <span class="hljs-attr">PI</span> = <span class="hljs-number">3.14</span></code></pre></div><blockquote><p>注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>计算机世界中的万事成物都是数据。</p></blockquote><p>计算机程序可以处理大量的数据，为了方便数据的管理，将数据分成了不同的类型：</p><p>注：通过 typeof 关键字检测数据类型</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 数据类型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 检测 1 是什么类型数据，结果为 number</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>)</span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>即我们数学中学习到的数字，可以是整数、小数、正数、负数</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 数据类型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> score = <span class="hljs-number">100</span> <span class="hljs-comment">// 正整数</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> price = <span class="hljs-number">12.345</span> <span class="hljs-comment">// 小数</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> temperature = -<span class="hljs-number">40</span> <span class="hljs-comment">// 负数</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> score) <span class="hljs-comment">// 结果为 number</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> price) <span class="hljs-comment">// 结果为 number</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> temperature) <span class="hljs-comment">// 结果为 number</span></span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p>JavaScript 中的数值类型与数学中的数字是一样的，分为正数、负数、小数等。</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>通过单引号（ <code>&#39;&#39;</code>） 、双引号（ <code>&quot;&quot;</code>）或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。</p><p>注意事项：</p><ol><li>无论单引号或是双引号必须成对使用</li><li>单引号&#x2F;双引号可以互相嵌套，但是不以自已嵌套自已</li><li>必要时可以使用转义符 &#96;&#96;，输出单引号或双引号</li></ol><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 数据类型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> user_name = <span class="hljs-string">&#x27;小明&#x27;</span> <span class="hljs-comment">// 使用单引号</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> gender = <span class="hljs-string">&quot;男&quot;</span> <span class="hljs-comment">// 使用双引号</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">// 看上去是数字，但是用引号包裹了就成了字符串了</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 这种情况叫空字符串</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">    documeent.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> user_name) <span class="hljs-comment">// 结果为 string</span></span></span><span class="language-javascript"><span class="language-xml">    documeent.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> gender) <span class="hljs-comment">// 结果为 string</span></span></span><span class="language-javascript"><span class="language-xml">    documeent.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> str) <span class="hljs-comment">// 结果为 string</span></span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>表示肯定或否定时在计算机中对应的是布尔类型数据，它有两个固定的值 <code>true</code> 和 <code>false</code>，表示肯定的数据用 <code>true</code>，表示否定的数据用 <code>false</code>。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 数据类型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//  pink老师帅不帅？回答 是 或 否</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> isCool = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是的，摔死了！</span></span></span><span class="language-javascript"><span class="language-xml">    isCool = <span class="hljs-literal">false</span> <span class="hljs-comment">// 不，套马杆的汉子！</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> isCool) <span class="hljs-comment">// 结果为 boolean</span></span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 数据类型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 只声明了变量，并末赋值</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> tmp;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> tmp) <span class="hljs-comment">// 结果为 undefined</span></span></span><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p><strong>注：JavaScript 中变量的值决定了变量的数据类型。</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git笔记</title>
    <link href="/2022/05/06/Git%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/06/Git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h1><ul><li>官方话：Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。</li><li>简单来说就是用来管理团队开发的代码</li></ul><h1 id="为什么要学习Git"><a href="#为什么要学习Git" class="headerlink" title="为什么要学习Git"></a>为什么要学习Git</h1><ul><li>一句话说，你写代码要保存，就得用Git</li></ul><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><p><strong>这块是重要步骤，也是平时用的最多的命令。</strong></p><p><strong>一、本地仓库关联远程仓库（新建仓库）</strong></p><div class="code-wrapper"><pre><code class="hljs bash">git init <span class="hljs-comment"># 初始化 git 仓库</span>git remote add origin 远程仓库链接地址 <span class="hljs-comment"># 将本地仓库和远程仓库关联</span>git push -u origin master <span class="hljs-comment">#本地编辑代码后提交至远程分支</span>PS: 第一次使用加上了 -u 参数，是推送内容并关联分支，之后推送直接使用git push即可，因为第一次已经将当前本地master分支和远程origin的master分支关联了git push -u origin master 等同于git push origin master //将当前分支提交到远程origin的master分支加上git branch --set-upstream-to=origin/master master//将远程仓库origin的master分支与本地仓库master分支关联</code></pre></div><p><strong>二、拉取远程分支到本地（已有远程仓库）</strong></p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 远程仓库地址 <span class="hljs-comment"># 在本地下载远程仓库代码</span>git fetch origin 远程分支名 <span class="hljs-comment"># 将远程分支拉到本地</span>git checkout -b 本地分支名称 origin/远程分支名称 <span class="hljs-comment"># 本地关联远程分支，本地分支名可随意写</span>git pull origin <span class="hljs-comment"># 拉取远程分支代码</span></code></pre></div><blockquote><p>平时开发的话结合 IDEA 中的 Git 操作即可简单地完成提交（commit）和推送（push）操作。</p></blockquote><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>![img](C:\Users\86159\Documents\WeChat Files\wxid_1zzmt9geesyt22\FileStorage\File\2023-08\Git 笔记\16b9d385970c7b6ctplv-t2oaga2asx-zoom-in-crop-mark4536000.image)</p><ul><li>本地仓库是对于远程仓库而言的。</li><li>本地仓库 &#x3D; 工作区 + 版本区</li><li>工作区即磁盘上的文件集合。</li><li>版本区(版本库)即<code>.git</code>文件</li><li>版本库 &#x3D; 暂存区(stage) + 分支(master) + 指针Head<ul><li>以我使用最频繁的git命令为例，即提交到github为例。</li><li><code>git init</code> 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，<code>git init</code>一下，表示在本地区域创建了一个<code>.git</code>文件,版本区建立。</li><li><code>git add .</code> 表示把工作区的所有文件全部提交到版本区里面的<strong>暂存区</strong></li><li>当然你也可以通过 <code>git add ./xxx/</code> 一条一条分批添加到暂存区。</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的<strong>所有</strong>文件提交到仓库区，暂存区空空荡荡。</li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来。</li><li><code>git push -u origin master</code> 把仓库区的文件提交到远程仓库里。</li><li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。会有这样的信息<code>nothing to commit, working tree clean</code></li></ul></li></ul><h1 id="版本的回溯与前进"><a href="#版本的回溯与前进" class="headerlink" title="版本的回溯与前进"></a>版本的回溯与前进</h1><p>提交一个文件，有时候我们会提交很多次，在提交历史中，这样就产生了不同的版本。每次提交，Git会把他们串成一条时间线。如何回溯到我们提交的上一个版本，用<code>git reset --hard + 版本号</code>即可。 版本号可以用<code>git log</code>来查看，每一次的版本都会产生不一样的版本号。回溯之后，<code>git log</code>查看一下发现离我们最近的那个版本已经不见了。但是我还想要前进到最近的版本应该如何？只要<code>git reset --hard + 版本号</code>就行。退一步来讲，虽然我们可以通过<code>git reset --hard + 版本号</code>,靠记住版本号来可以在不同的版本之间来回穿梭。<strong>但是</strong>,有时候把版本号弄丢了怎么办？<code>git reflog</code>帮你记录了每一次的命令，这样就可以找到版本号了，这样你又可以通过<code>git reset</code>来版本穿梭了。</p><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><ul><li>场景1：在工作区时，你修改了一个东西，你想撤销修改，<code>git checkout -- file</code>。廖雪峰老师指出撤销修改就回到和版本库一模一样的状态，即用版本库里的版本替换工作区的版本。</li><li>场景2：你修改了一个内容，并且已经<code>git add</code>到暂存区了。想撤销怎么办？回溯版本，<code>git reset --hard + 版本号</code>,再<code>git checkout -- file</code>,替换工作区的版本。</li><li>场景3：你修改了一个内容，并且已经<code>git commit</code>到了<code>master</code>。跟场景2一样，版本回溯，再进行撤销。</li></ul><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul><li>如果你<code>git add</code>一个文件到暂存区，然后在工作区又把文件删除了，Git会知道你删除了文件。如果你要把版本库里的文件删除，<code>git rm</code> 并且<code>git commit -m &quot;xxx&quot;</code>.</li><li>如果你误删了工作区的文件，怎么办？使用撤销命令，<code>git checkout --&lt;file&gt;</code>就可以。<strong>这再次证明了撤销命令其实就是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong></li></ul><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>分支，就像平行宇宙，廖雪峰老师如是说。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>![img](C:\Users\86159\Documents\WeChat Files\wxid_1zzmt9geesyt22\FileStorage\File\2023-08\Git 笔记\16b9e012079c4724tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)</p><p>在没有其他分支插进来时，只有一个master主分支。每次你<code>git push -u origin master</code> 提交就是增加一条时间轴，master也会跟着移动。</p><p>![img](C:\Users\86159\Documents\WeChat Files\wxid_1zzmt9geesyt22\FileStorage\File\2023-08\Git 笔记\16b9e11b1115072btplv-t2oaga2asx-zoom-in-crop-mark4536000.image)</p><p>创建一个other的分支，通过other提交，虽然时间轴向前走了，但是主分支master还在原来的位置。</p><p>![img](C:\Users\86159\Documents\WeChat Files\wxid_1zzmt9geesyt22\FileStorage\File\2023-08\Git 笔记\16b9e1ce1d3c3b03tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)</p><p>理论分析完，看一下命令怎么写。</p><ul><li>创建分支<code>other</code>,切换到<code>other</code>分支。</li></ul><div class="code-wrapper"><pre><code class="hljs gml">复制代码git branch <span class="hljs-symbol">other</span>git checkout <span class="hljs-symbol">other</span></code></pre></div><ul><li>查看当前所有分支</li></ul><div class="code-wrapper"><pre><code class="hljs crmsh">复制代码git branchmarkdown复制代码* other  <span class="hljs-literal">master</span></code></pre></div><p>当前的分支会有一个<code>*</code></p><ul><li>用<code>other</code>提交</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span>复制代码git <span class="hljs-keyword">add</span> .<span class="hljs-operator">/</span>xxx<span class="hljs-operator">/</span>git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;xxx&quot;</code></pre></div><ul><li><code>other</code>分支完成，切换回<code>master</code></li></ul><div class="code-wrapper"><pre><code class="hljs crmsh">复制代码git checkout <span class="hljs-literal">master</span></code></pre></div><ul><li>此时，master分支上并没有<code>other</code>的文件，因为分支还没有合并。</li><li><strong>合并分支</strong></li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span>复制代码git <span class="hljs-keyword">merge</span> other</code></pre></div><ul><li>合并完成之后，就可以在master分支上查看到文件了。</li><li>删除<code>other</code>分支。</li></ul><div class="code-wrapper"><pre><code class="hljs gml">复制代码git branch -d <span class="hljs-symbol">other</span></code></pre></div><ul><li>我由此想到，在以后工作中，应该是一个开放小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人去开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，可以由组长合并一下完成了的分支。哦，完美！</li></ul><h2 id="解决合并分支问题"><a href="#解决合并分支问题" class="headerlink" title="解决合并分支问题"></a>解决合并分支问题</h2><p>![img](C:\Users\86159\Documents\WeChat Files\wxid_1zzmt9geesyt22\FileStorage\File\2023-08\Git 笔记\16ba102bd434afc6tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)</p><p>假如有这样一种情况，分支<code>other</code>已经<code>commit</code>了，<strong>但是</strong>此时指针指回<code>master</code>时，并且<code>master</code>没有合并，而是<code>git add / commit</code> 提交了。这样，就产生了冲突，主分支<code>master</code>文件内容与<code>other</code>分支的内容不一样。合并不起来！所以，</p><ul><li><p>修改文件的内容，让其保持一致。</p></li><li><p><code>git add</code> <code>git commit</code> 提交。</p></li><li><p>分支合并了。</p><p>![img](C:\Users\86159\Documents\WeChat Files\wxid_1zzmt9geesyt22\FileStorage\File\2023-08\Git 笔记\16ba11a0ba73803dtplv-t2oaga2asx-zoom-in-crop-mark4536000.image)</p></li><li><p><code>git log --graph</code> 查看分支合并图</p></li><li><p><code>git branch -d other</code> 删除分支，任务结束。</p></li></ul><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><ul><li><code>git merge --no-ff other</code> 禁用<code>Fast forward</code>模式，因为使用<code>Fast forward</code>模式，删除分支后，分支历史信息会丢失。</li></ul><h2 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h2><blockquote><p>廖雪峰老师提到，工作中每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。但如果你手上有分支在工作中，你的上级要你改另外的分支的BUG。你要把现在正在工作的分支保存下来，<code>git stash</code>,把当前工作现场“存储”起来，等以后恢复后继续工作。当你解决BUG后，<code>git checkout other</code>回到自己的分支。用<code>git stash list</code>查看你刚刚“存放”起来的工作去哪里了。此时你要恢复工作：</p></blockquote><ul><li><code>git stash apply</code>恢复却不删除<code>stash</code>内容，<code>git stash drop</code>删除<code>stash</code>内容。</li><li><code>git stash pop</code>恢复的同时把stash内容也删了.</li><li>此时，用<code>git stash list</code>查看，看不到任何<code>stash</code> 内容。<br><strong>总结：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场</strong></li></ul><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ul><li><code>git branch -d + 分支</code>有可能会删除失败，因为Git会保护没有被合并的分支。</li><li><code>git branch -D + 分支</code> 强行删除，丢弃没被合并的分支。</li></ul><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><ul><li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li><li><code>git remote -v</code>显示更详细的信息</li><li><code>git push -u origin master</code>推送<code>master</code>分支到<code>origin</code>远程仓库。</li><li><code>git push -u origin other</code> 推送<code>other</code>到<code>origin</code>远程仓库。</li></ul><h2 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h2><p>![img](C:\Users\86159\Documents\WeChat Files\wxid_1zzmt9geesyt22\FileStorage\File\2023-08\Git 笔记\16ba20c43f386f7ctplv-t2oaga2asx-zoom-in-crop-mark4536000.image)</p><p>产生上图的冲突时，</p><ul><li><p><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并，解决冲突。在进行<code>git pull</code></p></li><li><p>如果</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span></code></pre></div><p> 也失败了，还要指定分支之间的链接，这一步Git会提醒你怎么做。然后再</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span></code></pre></div><p>。</p><blockquote><p><strong>廖雪峰老师的总结：多人协作的工作模式通常是这样：</strong></p></blockquote><ul><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code> 推送就能成功！</li><li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li></ul><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2></li><li><p><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观.缺点是本地的分叉提交已经被修改过了。</p></li><li><p>最后在进行<code>git push -u origin master</code></p></li><li><p><code>rebase</code>的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p></li></ul><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><blockquote><p>比如一个APP要上线，通常在版本库中打一个标签(tag), 这样，就确定了打标签的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。<br><code>tag</code>其实就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。比如<code>tag v2.1</code>就是把历史上的一个版本的东西叫做<code>v2.1</code></p></blockquote><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>步骤：</p><ul><li><code>git branch</code>查看当前分支,<code>git checkout master</code>切换到<code>master</code>分支。</li><li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li><li>默认标签是打在最新提交的<code>commit</code>上的。如果想要打标签在以前的<code>commit</code>上，要<code>git log</code>找到历史提交的<code>commit</code> id.</li><li>如果一个<code>commt id</code>是<code>du2n2d9</code>,执行<code>git tag v1.0 du2n2d9</code>就把这个版本打上了<code>v1.0</code>的标签了。</li><li><code>git tag</code> 查看所有标签，可以知道历史版本的<code>tag</code></li><li>标签不是按时间顺序列出，而是按字母排序的。</li><li><code>git show &lt;tagname&gt;</code> 查看标签信息。</li><li><code>git tag -a &lt;标签名&gt; -m &quot;&lt;说明&gt;&quot;</code>,创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字。用<code>show</code>可以查看说明。</li></ul><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><ul><li><code>git tag -d v1.0</code> 删除标签。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</li><li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li><li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li><li>如果标签推送到远程。<code>git tag -d v1.0</code> 先删除本地标签v1.0。<code>git push origin :refs/tags/v1.0</code>删除远程标签v1.0</li></ul><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><ul><li><p><code>git config --global color.ui true</code>让Git显示颜色，会让命令输出看起来更醒目</p></li><li><p>忽略特殊文件 创建一个<code>.gitignore</code>文件，把需要忽略的文件名填进去。Git就会自动忽略这些文件。我也在学习中遇到过这样的问题，比如<code>node_modules</code>文件就可以忽略。</p></li><li><blockquote><p>忽略文件原则：忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p></blockquote></li><li><p>强制提交已忽略的的文件。<code>git add -f &lt;file&gt;</code></p></li><li><p><code>git check-ignore -v &lt;file&gt;</code>检查为什么Git会忽略该文件。</p></li><li><p><strong>给Git命令配别名</strong>,这个有点骚，就是你以后想输入<code>git rebase</code>时,你给它一个“外号”，就叫它<code>git nb</code>。以后你可以通过<code>git nb</code>来代替<code>git rebase</code>。具体怎么转换可以去<a href="https://link.juejin.cn/?target=https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424">廖雪峰老师的网站</a>看。因为水平有限，我觉得先把正常的Git命令搞清楚来就很不错了。</p></li></ul><h1 id="常用Git命令总结"><a href="#常用Git命令总结" class="headerlink" title="常用Git命令总结"></a>常用Git命令总结</h1><ul><li><code>git config --global user.name &quot;你的名字&quot;</code> 让你全部的<code>Git</code>仓库绑定你的名字</li><li><code>git config --global user.email &quot;你的邮箱&quot;</code> 让你全部的<code>Git</code>仓库绑定你的邮箱</li><li><code>git init</code> 初始化你的仓库</li><li><code>git add .</code> 把工作区的文件全部提交到暂存区</li><li><code>git add ./&lt;file&gt;/</code> 把工作区的<code>&lt;file&gt;</code>文件提交到暂存区</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的所有文件提交到仓库区，<strong>暂存区空空荡荡</strong></li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来</li><li><code>git push -u origin master</code> 把仓库区的主分支<code>master</code>提交到远程仓库里</li><li><code>git push -u origin &lt;其他分支&gt;</code> 把其他分支提交到远程仓库</li><li><code>git status</code>查看当前仓库的状态</li><li><code>git diff</code> 查看文件修改的具体内容</li><li><code>git log</code> 显示从最近到最远的提交历史</li><li><code>git clone + 仓库地址</code>下载克隆文件</li><li><code>git reset --hard + 版本号</code> 回溯版本，版本号在<code>commit</code>的时候与<code>master</code>跟随在一起</li><li><code>git reflog</code> 显示命令历史</li><li><code>git checkout -- &lt;file&gt;</code> 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是<code>Git</code>世界的<code>ctrl + z</code></li><li><code>git rm</code> 删除版本库的文件</li><li><code>git branch</code> 查看当前所有分支</li><li><code>git branch &lt;分支名字&gt;</code> 创建分支</li><li><code>git checkout &lt;分支名字&gt;</code> 切换到分支</li><li><code>git merge &lt;分支名字&gt;</code> 合并分支</li><li><code>git branch -d &lt;分支名字&gt;</code> 删除分支,有可能会删除失败，因为<code>Git</code>会保护没有被合并的分支</li><li><code>git branch -D + &lt;分支名字&gt;</code> 强行删除，丢弃没被合并的分支</li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git merge --no-ff &lt;分支名字&gt;</code> 合并分支的时候禁用<code>Fast forward</code>模式,因为这个模式会丢失分支历史信息</li><li><code>git stash</code> 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作</li><li><code>git stash list</code> 查看你刚刚“存放”起来的工作去哪里了</li><li><code>git stash apply</code> 恢复却不删除<code>stash</code>内容</li><li><code>git stash drop</code> 删除<code>stash</code>内容</li><li><code>git stash pop</code> 恢复的同时把stash内容也删了</li><li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li><li><code>git remote -v</code> 显示更详细的信息</li><li><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并,和<code>git push</code>相反</li><li><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观</li><li><code>git tag</code> 查看所有标签，可以知道历史版本的tag</li><li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li><li><code>git tag &lt;tagName&gt; &lt;版本号&gt;</code> 把版本号打上标签，版本号就是<code>commit</code>时，跟在旁边的一串字母数字</li><li><code>git show &lt;tagName&gt;</code> 查看标签信息</li><li><code>git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot;</code> 创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字</li><li><code>git tag -d &lt;tagName&gt;</code> 删除标签</li><li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li><li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除远程标签<code>&lt;tagname&gt;</code></li><li><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目</li><li><code>git add -f &lt;file&gt;</code> 强制提交已忽略的的文件</li><li><code>git check-ignore -v &lt;file&gt;</code> 检查为什么Git会忽略该文件</li></ul><p>参考：<a href="https://juejin.cn/post/6844903877138087950">Git 笔记 - 程序员都要掌握的 Git</a></p>]]></content>
    
    
    <categories>
      
      <category>通用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css基础笔记</title>
    <link href="/2022/04/29/css%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/29/css%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS是什么？"><a href="#CSS是什么？" class="headerlink" title="CSS是什么？"></a>CSS是什么？</h2><ul><li>Cascading Style Sheets【层叠样式表】</li><li>是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。主要用来设计网页的样式，美化网页，静态或动态的修饰页面元素的样式</li></ul><h2 id="CSS的引入方式"><a href="#CSS的引入方式" class="headerlink" title="CSS的引入方式"></a>CSS的引入方式</h2><h4 id="【行内样式】"><a href="#【行内样式】" class="headerlink" title="【行内样式】"></a>【行内样式】</h4><ul><li>优先级最高，可以覆盖同意元素的其他引入的样式</li><li>作为标签的属性存在</li><li>代码量大，分离度较低，维护困难，冗余度高</li></ul><h4 id="【内嵌】"><a href="#【内嵌】" class="headerlink" title="【内嵌】"></a>【内嵌】</h4><ul><li>写在本HTML当中的head中的style标签当中</li><li>读取速度相较于两种导入比较快，同步的</li></ul><h4 id="【外链导入】"><a href="#【外链导入】" class="headerlink" title="【外链导入】"></a>【外链导入】</h4><ul><li>外部单独创建一个css样式表，通过link标签引入</li><li>异步加载的，而且是等到同步任务完成后，再去渲染加载回来的外链样式文件</li></ul><h4 id="【导入式】"><a href="#【导入式】" class="headerlink" title="【导入式】"></a>【导入式】</h4><ul><li>在style标签内 使用<code>@import 文件路径</code>来引入</li><li>还可在外联样式表<code>.css文件</code>中在引入样式表，不过需要放在整个代码的最上面，不然会被后来的重复样式覆盖</li></ul><hr><h2 id="CSS的常用单位"><a href="#CSS的常用单位" class="headerlink" title="CSS的常用单位"></a>CSS的常用单位</h2><h4 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h4><ul><li><code>px</code> 像素</li></ul><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><ul><li><p>em</p><ul><li>在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小</li></ul></li><li><p>rem</p><p> 根元素【html】的字体大小</p><ul><li>多用于移动端适配</li></ul></li><li><p><code>vw</code> 视窗宽度的1%</p></li><li><p><code>vh</code> 视窗高度的1%</p></li></ul><hr><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>在页面结构中，元数据部分有一条viewport，这一条就是为了在移动端浏览页面的时候，页面能够跟随设备的缩小而缩小。</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使页面的宽度=设备屏幕的宽度 --&gt;</span>   <span class="hljs-comment">&lt;!-- 初始缩放值为1.0 --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></code></pre></div><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li><code>width=device-width</code> 页面宽度等于设备宽度</li><li><code>user-scalable=no</code> 禁止缩放</li><li><code>initial-scale=1.0</code> 初始缩放值为1.0</li><li><code>maximum-scale=1.0</code> 最大缩放值为1.0</li><li><code>minimum-scale=1.0</code> 最小缩放值为1.0</li></ul><hr><h2 id="CSS的语法"><a href="#CSS的语法" class="headerlink" title="CSS的语法"></a>CSS的语法</h2><h4 id="元素的划分"><a href="#元素的划分" class="headerlink" title="元素的划分"></a>元素的划分</h4><ul><li><h6 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h6><ul><li>写宽高可以起作用</li><li>独占一行<ul><li><strong>【此特点决定了】</strong> 排列方式：<strong>上下排列</strong></li></ul></li></ul></li><li><h6 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h6><ul><li><p>写宽高不起作用，其大小由其内部内容撑开并决定。</p></li><li><p>共占一行</p><ul><li><strong>【此特点决定了】</strong> 排列方式：<strong>左右排列</strong></li></ul></li><li><p>【特殊行内元素】</p><p>行内块元素</p><ul><li>写宽高可以起作用</li><li>共占一行</li><li>排列方式：左右</li></ul></li><li><h6 id="【判断方式】"><a href="#【判断方式】" class="headerlink" title="【判断方式】"></a>【判断方式】</h6><ul><li>与行内元素放在一起，若测试的元素没有和行内元素共占一行，则一定是块级元素</li><li>若在一行，则通过改变测试元素宽高，来判断是【不变：行内元素】 还是 【变了：行内块元素】</li></ul></li></ul></li><li><h6 id="元素标签的总结"><a href="#元素标签的总结" class="headerlink" title="元素标签的总结"></a>元素标签的总结</h6><ul><li><h6 id="行内元素："><a href="#行内元素：" class="headerlink" title="行内元素："></a>行内元素：</h6><ul><li>span、a、b、strong、i、em、s、del、u、ins</li></ul></li><li><h6 id="块级元素："><a href="#块级元素：" class="headerlink" title="块级元素："></a>块级元素：</h6><ul><li>div、h1 - h6、p、ul、li、ol、dl、dt、dd</li></ul></li><li><h6 id="行内块："><a href="#行内块：" class="headerlink" title="行内块："></a>行内块：</h6><ul><li>img、video、audio</li></ul></li></ul></li></ul><h4 id="元素特性的转换display"><a href="#元素特性的转换display" class="headerlink" title="元素特性的转换display"></a>元素特性的转换display</h4><ol><li><h6 id="转换为块级元素"><a href="#转换为块级元素" class="headerlink" title="转换为块级元素"></a>转换为块级元素</h6><ul><li><code>display:block</code></li><li>【特性】<ol><li>不设置宽度就会充满其父元素</li><li>不设置高度，就由内容能撑开多少决定</li></ol></li></ul></li><li><h6 id="转换为行内元素【基本不使用】"><a href="#转换为行内元素【基本不使用】" class="headerlink" title="转换为行内元素【基本不使用】"></a>转换为行内元素【基本不使用】</h6><ul><li><code>display:inline</code></li></ul></li><li><h6 id="转换为行内块元素"><a href="#转换为行内块元素" class="headerlink" title="转换为行内块元素"></a>转换为行内块元素</h6><ul><li><code>display:inline-block</code></li></ul></li><li><h6 id="隐藏该元素"><a href="#隐藏该元素" class="headerlink" title="隐藏该元素"></a>隐藏该元素</h6><ol><li><p>display:none</p><ul><li>【彻底消失，不占位置】</li></ul></li><li><p>visibility:hidden</p><p>【可视程度】</p><ul><li>【元素还在，占着位置，只不过看不见】</li></ul></li><li><p>opacity:%</p><p>【透明度】</p><ul><li>【元素还在，占着位置，只不过看不见】</li></ul></li><li><p>z-index</p><p>【定位的元素可以以此控制层级】</p><ul><li>margin【控制无内容容器离开视口（无内容适用）】</li></ul></li></ol><ul><li>宽高【减为0（无内容适用）】</li></ul></li></ol><hr><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><h4 id="清除默认样式"><a href="#清除默认样式" class="headerlink" title="清除默认样式"></a>清除默认样式</h4><ul><li><h6 id="清除全局元素的margin和padding"><a href="#清除全局元素的margin和padding" class="headerlink" title="清除全局元素的margin和padding"></a>清除全局元素的margin和padding</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        *&#123;</span><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li><h6 id="清除列表的默认样式"><a href="#清除列表的默认样式" class="headerlink" title="清除列表的默认样式"></a>清除列表的默认样式</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">li</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">list-style</span>:none;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li><h6 id="清除a标签的默认样式"><a href="#清除a标签的默认样式" class="headerlink" title="清除a标签的默认样式"></a>清除a标签的默认样式</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-xml"></span><span class="language-xml">        a&#123;</span><span class="language-xml">            <span class="hljs-comment">&lt;!-- 删除下划线 --&gt;</span></span><span class="language-xml">            text-decoration:none;</span><span class="language-xml">            <span class="hljs-comment">&lt;!-- 修改字体大小 --&gt;</span></span><span class="language-xml">            font-size:100px;</span><span class="language-xml">            <span class="hljs-comment">&lt;!-- 清除默认字体颜色 --&gt;</span></span><span class="language-xml">            color:#333;</span><span class="language-xml">        &#125;</span><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul><hr><h4 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h4><ul><li><h6 id="宽高"><a href="#宽高" class="headerlink" title="宽高"></a>宽高</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            *&#123;</span><span class="language-css">                <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">                <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li><h6 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            *&#123;</span><span class="language-css">                <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#fff</span>;</span><span class="language-css">                <span class="hljs-comment">/*  复合样式 */</span></span><span class="language-css">                <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;</span><span class="language-css">                <span class="hljs-comment">/* 背景图片 */</span></span><span class="language-css">                <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul><hr><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><ul><li><h6 id="字体font-family"><a href="#字体font-family" class="headerlink" title="字体font-family"></a>字体font-family</h6><ul><li><p>可设置多种字体，用逗号间隔，如果没有字库就顺延使用，都没有就使用默认</p></li><li><p>字体名若由多个单词组成，则用引号括住</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        *&#123;</span><span class="language-css">            <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;微软雅黑&quot;</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="字号font-size"><a href="#字号font-size" class="headerlink" title="字号font-size"></a>字号font-size</h6><ul><li><p>可以先总体设置大部分字字号，然后再去单独设置不同字号的字</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">       *&#123;</span><span class="language-css">           <span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>;</span><span class="language-css">       &#125;</span><span class="language-css">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="颜色color"><a href="#颜色color" class="headerlink" title="颜色color"></a>颜色color</h6><ul><li><p>设置字体颜色</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            *&#123;</span><span class="language-css">                <span class="hljs-attribute">color</span>:black;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="粗细font-weight"><a href="#粗细font-weight" class="headerlink" title="粗细font-weight"></a>粗细font-weight</h6><ul><li><p>400-&gt;normal</p></li><li><p>700-&gt;bold</p></li><li><p>900-&gt;bolder</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        *&#123;</span><span class="language-css">            <span class="hljs-comment">/* 正常 */</span></span><span class="language-css">            <span class="hljs-attribute">font-weight</span>:<span class="hljs-number">400</span>;</span><span class="language-css">            <span class="hljs-attribute">font-weight</span>:normal;</span><span class="language-css">            <span class="hljs-comment">/* 加粗 */</span></span><span class="language-css">            <span class="hljs-attribute">font-weight</span>:<span class="hljs-number">700</span>;</span><span class="language-css">            <span class="hljs-attribute">font-weight</span>:bold;</span><span class="language-css">            <span class="hljs-comment">/* 更粗 */</span></span><span class="language-css">            <span class="hljs-attribute">font-weight</span>:<span class="hljs-number">900</span>;</span><span class="language-css">            <span class="hljs-attribute">font-weight</span>:bolder;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="倾斜-正常font-style"><a href="#倾斜-正常font-style" class="headerlink" title="倾斜&amp;正常font-style"></a>倾斜&amp;正常font-style</h6><ul><li><p>倾斜 italic</p></li><li><p>正常 normal</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            *&#123;</span><span class="language-css">            <span class="hljs-attribute">font-style</span>:italic;</span><span class="language-css">            <span class="hljs-attribute">font-style</span>:normal;</span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="块级元素快速水平居中"><a href="#块级元素快速水平居中" class="headerlink" title="块级元素快速水平居中"></a>块级元素快速水平居中</h6><ul><li><p>margin:0 auto;</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;</span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="行高line-height"><a href="#行高line-height" class="headerlink" title="行高line-height"></a>行高line-height</h6><ul><li><p>三部分组成：上间距，元素，下间距</p><ul><li><strong>上下间距是相等的,元素处于中间</strong></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">line-height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="高度height"><a href="#高度height" class="headerlink" title="高度height"></a>高度height</h6><ul><li><p>高度就是容器的高度</p></li><li><p>配合行高可以实现元素的垂直居中</p><ul><li>让<code>行高</code>等于<code>容器</code>的高度</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="文字对齐text-align"><a href="#文字对齐text-align" class="headerlink" title="文字对齐text-align"></a>文字对齐text-align</h6><ul><li><p>left，center，right居左，居中，居右</p></li><li><p>不管是对什么元素使用，都是对其中的文字元素起作用</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">text-align</span>:center;</span><span class="language-css">            &#125;</span></code></pre></div></li></ul></li><li><h6 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h6><ul><li><p>会对文本块中首行文本的缩进。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-xml"></span><span class="language-xml">            p&#123;</span><span class="language-xml">                <span class="hljs-comment">&lt;!-- 首行缩进，em单位自动适应 --&gt;</span></span><span class="language-xml">                text-indent:2em;</span><span class="language-xml">            &#125;</span><span class="language-xml">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>                这是一段文字            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">body</span>&#123;</span><span class="language-css">                &lt;!-- 可设置多种字体，用逗号间隔，如果没有字库就顺延使用，都没有就使用默认 --&gt;</span><span class="language-css">                <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;Times New Roman&quot;</span>,Times,serif;</span><span class="language-css">                <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;宋体&quot;</span>,<span class="hljs-string">&quot;楷书&quot;</span>,<span class="hljs-string">&quot;微软雅黑&quot;</span>;</span><span class="language-css"></span><span class="language-css">                <span class="hljs-attribute">font-size</span>:<span class="hljs-number">10px</span>;</span><span class="language-css"></span><span class="language-css">                //正常</span><span class="language-css">                //<span class="hljs-attribute">font-weight</span>:<span class="hljs-number">400px</span>;</span><span class="language-css">                <span class="hljs-attribute">font-weight</span>:normal;</span><span class="language-css">                //加粗</span><span class="language-css">                //<span class="hljs-attribute">font-weight</span>:<span class="hljs-number">700px</span>;</span><span class="language-css">                <span class="hljs-attribute">font-weight</span>:bold;</span><span class="language-css">                //更粗</span><span class="language-css">                //<span class="hljs-attribute">font-weight</span>:<span class="hljs-number">900px</span>;</span><span class="language-css">                <span class="hljs-attribute">font-weight</span>:bolder;</span><span class="language-css"></span><span class="language-css">                //倾斜&amp;恢复正常</span><span class="language-css">                <span class="hljs-attribute">font-style</span>:italic;<span class="hljs-attribute">font-style</span>:normal;</span><span class="language-css">                <span class="hljs-attribute">color</span>:<span class="hljs-number">#eee</span>;</span><span class="language-css">            &#125;</span><span class="language-css">            <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">                &lt;!-- 快速水平居中 --&gt;</span><span class="language-css">                <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;</span><span class="language-css"></span><span class="language-css">            &#125;</span><span class="language-css">            <span class="hljs-selector-id">#jvzhong</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;</span><span class="language-css">                <span class="hljs-attribute">line-height</span>:<span class="hljs-number">300px</span>;</span><span class="language-css"></span><span class="language-css">            &#125;</span><span class="language-css">            <span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">line-height</span>:<span class="hljs-number">10px</span>;</span><span class="language-css">                <span class="hljs-attribute">text-align</span>:center;</span><span class="language-css">                // <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:left</span>;</span><span class="language-css">                // <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:right</span>;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>                这是一段文字            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>块元素水平居中<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jvzhong&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>                    垂直居中                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul><hr><h4 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h4><ul><li><p>border:宽度 样式 颜色;</p><ul><li><p>还可以单独控制</p><ul><li><p><code>border-width</code>【单独控制宽度】</p></li><li><p><code>border-left-width</code>【单独控制每条边宽度】</p></li><li><p><code>border-style</code></p><p> 【单独控制样式】</p><ul><li>solid 实线</li><li>dashed 虚线</li></ul></li><li><p><code>border-color</code> 【单独控制颜色】</p></li></ul></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">div</span>&#123;    </span><span class="language-css">                <span class="hljs-attribute">border</span>:<span class="hljs-number">2px</span> solid black;</span><span class="language-css">                <span class="hljs-attribute">border-width</span>:<span class="hljs-number">10px</span>;</span><span class="language-css">                <span class="hljs-attribute">border-left-width</span>:<span class="hljs-number">10px</span>;</span><span class="language-css">                <span class="hljs-attribute">border-style</span>:dotted;</span><span class="language-css">                <span class="hljs-attribute">border-color</span>:pink;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><hr><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><ul><li><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><ul><li>当内容溢出元素框时发生的事情</li></ul></li><li><h6 id="overflow-hidden"><a href="#overflow-hidden" class="headerlink" title="overflow:hidden"></a><code>overflow:hidden</code></h6><ul><li><p>内容超出后隐藏</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-class">.text</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100px;&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是文本段我是文本段我是文本段<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="overflow-auto"><a href="#overflow-auto" class="headerlink" title="overflow:auto"></a><code>overflow:auto</code></h6><ul><li>设置内容超出后自动出现滚动条，如果没超出，就不会出现滚动条</li></ul></li><li><h6 id="overflow-scroll"><a href="#overflow-scroll" class="headerlink" title="overflow:scroll"></a><code>overflow:scroll</code></h6><ul><li><p><code>overflow:scroll</code></p><p> 控制水平和垂直的滚动条</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-class">.text</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-attribute">overflow</span>: scroll;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100px;&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是文本段我是文本段我是文本段<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><p><code>overflow-y:scroll</code></p><p> 控制垂直方向上的滚动条</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.text</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    </span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    </span><span class="language-css">            <span class="hljs-comment">/* 垂直方向滚动条 */</span></span><span class="language-css">            <span class="hljs-attribute">overflow-y</span>: scroll;           </span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100px;&quot;</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是文本段我是文本段我是文本段<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><p><code>overflow-x:scroll</code></p><p> 控制水平方向上的滚动条</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-class">.text</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-comment">/* 水平方向滚动条 */</span></span><span class="language-css">            <span class="hljs-attribute">overflow-x</span>: scroll;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100px;&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是文本段我是文本段我是文本段<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul></li></ul><hr><h4 id="background"><a href="#background" class="headerlink" title="background"></a>background</h4><ul><li><h5 id="background-color-背景颜色"><a href="#background-color-背景颜色" class="headerlink" title="background-color 背景颜色"></a>background-color 背景颜色</h5><ul><li><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><ul><li><code>background-color:颜色;</code></li></ul></li><li><h6 id="样式值"><a href="#样式值" class="headerlink" title="样式值"></a>样式值</h6><ul><li><h6 id="颜色名称"><a href="#颜色名称" class="headerlink" title="颜色名称"></a>颜色名称</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:pink;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li><h6 id="颜色十六进制值"><a href="#颜色十六进制值" class="headerlink" title="颜色十六进制值"></a>颜色十六进制值</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css"></span><span class="language-css">                <span class="hljs-comment">/* background-color:#9e9e9e; */</span></span><span class="language-css">                <span class="hljs-comment">/* 如果六个值都相同可以简写为三个 */</span></span><span class="language-css">                <span class="hljs-comment">/* background-color:#333333; */</span></span><span class="language-css">                <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#333</span>;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li><h6 id="rgba值"><a href="#rgba值" class="headerlink" title="rgba值"></a>rgba值</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">                <span class="hljs-comment">/* 前三个是色值，最后一个代表透明度 */</span></span><span class="language-css">                <span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">128</span>,<span class="hljs-number">148</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0.8</span>);</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li></ul></li><li><h5 id="background-image-背景图片"><a href="#background-image-背景图片" class="headerlink" title="background-image 背景图片"></a>background-image 背景图片</h5><ul><li>用法 <code>background-image:url(&quot;路径&quot;);</code></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h5 id="background-size-背景图片大小"><a href="#background-size-背景图片大小" class="headerlink" title="background-size 背景图片大小"></a>background-size 背景图片大小</h5><ul><li><h6 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h6><ul><li><h6 id="background-size-宽-高"><a href="#background-size-宽-高" class="headerlink" title="background-size:宽 高;"></a><code>background-size:宽 高;</code></h6></li></ul></li><li><h6 id="样式值-1"><a href="#样式值-1" class="headerlink" title="样式值"></a>样式值</h6><ol><li><h6 id="background-size-第一个值px-第二个值px-像素值"><a href="#background-size-第一个值px-第二个值px-像素值" class="headerlink" title="background-size:第一个值px 第二个值px 像素值"></a><code>background-size:第一个值px 第二个值px</code> 像素值</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            <span class="hljs-attribute">background-size</span>:<span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h6 id="background-size-第一个值-第二个值-父元素的百分比"><a href="#background-size-第一个值-第二个值-父元素的百分比" class="headerlink" title="background-size:第一个值% 第二个值% 父元素的百分比"></a><code>background-size:第一个值% 第二个值%</code> 父元素的百分比</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            <span class="hljs-attribute">background-size</span>:<span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h6 id="background-size-contain"><a href="#background-size-contain" class="headerlink" title="background-size:contain"></a><code>background-size:contain</code></h6><ul><li>背景图在缩放的过程中，只要任一边著碰到父元素的宽或高，就不再继续缩放</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            <span class="hljs-comment">/* background-size:contain; */</span></span><span class="language-css">            <span class="hljs-comment">/* 背景图在缩放的过程中，只要任一边著碰到父元素的宽或高，就不再继续缩放 */</span></span><span class="language-css">            <span class="hljs-attribute">background-size</span>:contain;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h6 id="background-size-cover"><a href="#background-size-cover" class="headerlink" title="background-size:cover"></a><code>background-size:cover</code></h6><ul><li>背景图在缩放的过程中，必须同时充满父元素的宽和高，但如果图片比例和盒子的比例不一致，就会造成部分图片显示不全</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            <span class="hljs-comment">/* background-size:cover; */</span></span><span class="language-css">            <span class="hljs-comment">/* 背景图在缩放的过程中，必须同时充满父元素的宽和高，</span></span><span class="hljs-comment"><span class="language-css">            但如果图片比例和盒子的比例不一致，就会造成部分图片显示不全 */</span></span><span class="language-css">            <span class="hljs-attribute">background-size</span>:cover;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ol></li></ul></li><li><h5 id="background-position：背景图片的位置"><a href="#background-position：背景图片的位置" class="headerlink" title="background-position：背景图片的位置"></a>background-position：背景图片的位置</h5><ul><li><h6 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h6><ul><li><code>background-position:水平方向 垂直方向;</code></li></ul></li><li><h6 id="水平方向【第一个值】"><a href="#水平方向【第一个值】" class="headerlink" title="水平方向【第一个值】"></a>水平方向【第一个值】</h6><ul><li><code>left </code> 左侧</li><li><code>center </code> 中间</li><li><code>right </code> 右侧</li><li><code>background-position:第一个值px 第二个值px</code> 像素值</li><li><code>background-position:第一个值% 第二个值%</code> 父元素的百分比</li></ul></li><li><h6 id="垂直方向【第二个值】"><a href="#垂直方向【第二个值】" class="headerlink" title="垂直方向【第二个值】"></a>垂直方向【第二个值】</h6><ul><li><code>top</code> 顶部</li><li><code>center</code> 中间</li><li><code>bottom</code> 底部</li><li><code>background-position:第一个值px 第二个值px</code> 像素</li><li><code>background-position:第一个值% 第二个值%</code> 父元素的百分比</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            <span class="hljs-comment">/* 像素值 */</span></span><span class="language-css">            <span class="hljs-comment">/* background-position:100px 100px; */</span></span><span class="language-css">            <span class="hljs-comment">/* 语义化 */</span></span><span class="language-css">            <span class="hljs-comment">/* background-position:center center; */</span></span><span class="language-css">            <span class="hljs-comment">/* 百分比 */</span></span><span class="language-css">            <span class="hljs-attribute">background-position</span>:<span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul></li><li><h5 id="background-repeat-控制图片平铺"><a href="#background-repeat-控制图片平铺" class="headerlink" title="background-repeat 控制图片平铺"></a><code>background-repeat</code> 控制图片平铺</h5><ul><li><p><code>no-repeat</code>：不平铺</p></li><li><p><code>repeat-x</code> ：沿着水平方向平铺</p></li><li><p><code>repeat-y</code></p><p> ：沿着垂直方向平铺</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            <span class="hljs-attribute">background-repeat</span>:no-repeat;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul></li><li><h5 id="background-attachment-控制背景是否跟着滚动条滚动"><a href="#background-attachment-控制背景是否跟着滚动条滚动" class="headerlink" title="background-attachment 控制背景是否跟着滚动条滚动"></a><code>background-attachment</code> 控制背景是否跟着滚动条滚动</h5><ul><li><p>设置背景图像是否 <code>固定</code> 或者 <code>随着页面的其余部分滚动</code></p></li><li><p><code>fixed</code> ：背景图像始终固定，不随滚动条滚动而滚动</p></li><li><p><code>scorll</code></p><p> ：背景图像随滚动条滚动而滚动</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>);</span><span class="language-css">            <span class="hljs-comment">/* 像素值 */</span></span><span class="language-css">            <span class="hljs-comment">/* background-position:100px 100px; */</span></span><span class="language-css">            <span class="hljs-comment">/* 语义化 */</span></span><span class="language-css">            <span class="hljs-comment">/* background-position:center center; */</span></span><span class="language-css">            <span class="hljs-comment">/* 百分比 */</span></span><span class="language-css">            <span class="hljs-attribute">background-position</span>:<span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul></li><li><h5 id="background-复合属性"><a href="#background-复合属性" class="headerlink" title="background 复合属性"></a><code>background</code> 复合属性</h5><ul><li><p>用法 </p><p><code>background</code>:颜色 背景图 背景位置&#x2F;图片尺寸【斜杠紧接着位置，无空格】 是否平铺;</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- background:颜色 背景图 背景位置/图片尺寸【斜杠紧接着位置，无空格】 是否平铺; --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* 粉色 背景图 中间顶部对齐 父元素50%大小 不平铺 */</span></span><span class="language-css">            <span class="hljs-attribute">background</span>:pink <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;路径&quot;</span>) center top/<span class="hljs-number">50%</span> <span class="hljs-number">50%</span> no-repeat;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul></li></ul><hr><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><ol><li>同权重，看执行顺序</li><li>权重不同看权重</li><li>组合选择器权重是按照多个基础的权重相加<ul><li><code>div&gt;span</code>权重<code>2</code></li><li><code>.class&gt;span</code>权重<code>11</code></li><li><code>div&gt;span</code>,<code>div&gt;span</code>若想选择两个同级的子代，就是这样两个独立的整体使用【权重为4】</li></ul></li></ol><h4 id="通配符选择器-【所有元素】"><a href="#通配符选择器-【所有元素】" class="headerlink" title="通配符选择器  *【所有元素】"></a>通配符选择器 <code> *</code>【所有元素】</h4><ul><li>权重为 <code>0 </code></li><li>范围最广，使用最少，通常用于清除全局默认样式</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        *&#123;</span><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h4 id="标签选择器-【指定的标签】"><a href="#标签选择器-【指定的标签】" class="headerlink" title="标签选择器 【指定的标签】"></a>标签选择器 【指定的标签】</h4><ul><li>权重为 <code>1 </code></li><li>范围为 <code>选中的一类标签</code></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-comment">&lt;!-- 比如这里就是选择页面中所有的ul标签 --&gt;</span></span><span class="language-xml">        ul&#123;</span><span class="language-xml">            list-style:none;</span><span class="language-xml">        &#125;</span><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h4 id="类选择器-【指定的类】"><a href="#类选择器-【指定的类】" class="headerlink" title="类选择器 .【指定的类】"></a>类选择器 <code>.</code>【指定的类】</h4><ul><li>权重为 <code>10</code></li><li>范围为 <code>选中class相同的所有标签</code></li><li><strong>同一个标签可以有多个类名，但是中间要用空格隔开</strong></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.class</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class class1 class2&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="属性选择器-【指定的含有某属性的元素】"><a href="#属性选择器-【指定的含有某属性的元素】" class="headerlink" title="属性选择器 []【指定的含有某属性的元素】"></a>属性选择器 <code>[]</code>【指定的含有某属性的元素】</h4><ul><li><p>权重为 <code>10 </code></p></li><li><p>范围为</p><ol><li><code>选中所有含有此属性的元素</code></li><li><code>选中所有含有此【属性名&amp;属性值】的元素</code></li><li><code>选中所有含有此【属性名&amp;属性值中以某个字母开头的】的元素</code></li><li><code>选中所有含有此【属性名&amp;属性值中以某个字母结尾的】的元素</code></li></ol><ul><li>在多个类名时，以某个字母开头去匹配的就是<code>第一个类名的开头</code>，以某个字母结尾去匹配的就是<code>最后一个类名的结尾</code></li></ul><ol><li><code>选中所有含有此【属性名&amp;属性值中包含某个字母的】的元素</code></li></ol><ul><li><strong>此方法在元素有多个类名时，无法选中该元素</strong></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-comment">/* 选中所有含有此属性的元素 */</span></span><span class="language-css">        <span class="hljs-selector-attr">[index]</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:red;</span><span class="language-css"></span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 选中所有含有此【属性名&amp;属性值】的元素 */</span></span><span class="language-css">        <span class="hljs-selector-attr">[index=index1]</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:blue;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 选中所有含有此【属性名&amp;属性值中以某个字母开头的】的元素 */</span></span><span class="language-css">        <span class="hljs-selector-attr">[class^=a]</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:green;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 选中所有含有此【属性名&amp;属性值中以某个字母结尾的】的元素 */</span></span><span class="language-css">        <span class="hljs-selector-attr">[class$=a]</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:orange;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 选中所有含有此【属性名&amp;属性值中包含某个字母的】的元素 */</span></span><span class="language-css">        <span class="hljs-selector-attr">[class*=pin]</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:pink;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 选中所有含有此【属性名&amp;属性值中包含某个字母的】的元素【】 */</span></span><span class="language-css">        <span class="hljs-selector-attr">[class*=a]</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:black;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#x27;index1&#x27;</span>&gt;</span>index1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;apple&#x27;</span>&gt;</span>apple<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;banana&#x27;</span>&gt;</span>banana<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;pineapple&#x27;</span>&gt;</span>pineapple<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 在多类名情况时使用属性选择器【首字母或尾字母】 --&gt;</span>        <span class="hljs-comment">&lt;!-- ↓↓ --&gt;</span>        <span class="hljs-comment">&lt;!-- 第一个类名首字母为o时此条会被选中 --&gt;</span>        <span class="hljs-comment">&lt;!-- 最后一个类名尾字母为c时此条会被选中 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;orange a b c&#x27;</span>&gt;</span>orange<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="id选择器-【指定的id】"><a href="#id选择器-【指定的id】" class="headerlink" title="id选择器 #【指定的id】"></a>id选择器 <code>#</code>【指定的id】</h4><ul><li>权重为 <code>100 </code></li><li>范围为 <code>选中同一种id的标签</code></li><li><strong>id是唯一的，同一个HTML页面中不允许重名</strong></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-id">#id</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="子选择器-【指定的子代元素】"><a href="#子选择器-【指定的子代元素】" class="headerlink" title="子选择器 &gt;【指定的子代元素】"></a>子选择器 <code>&gt;</code>【指定的子代元素】</h4><ul><li><p>权重为 <code>没权重，根据不同的基础选择器的搭配不同 </code></p></li><li><p>范围为 <code>选中符合我们所需父子关系的所有元素</code></p></li><li><blockquote><p>两边所有基础选择器自选使用</p></blockquote><ul><li><code>div&gt;span</code>权重<code>2</code></li><li><code>.class&gt;span</code>权重<code>11</code></li><li><code>div&gt;span</code>,<code>div&gt;span</code>若想选择两个同级的子代，就是这样两个独立的整体使用</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-id">#id</span>&gt;<span class="hljs-selector-tag">span</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>;&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="后代选择器-空格【指定的所有后代元素】"><a href="#后代选择器-空格【指定的所有后代元素】" class="headerlink" title="后代选择器 空格【指定的所有后代元素】"></a>后代选择器 <code>空格</code>【指定的所有后代元素】</h4><ul><li>权重为 <code>没权重，根据不同的基础选择器的搭配不同 </code></li><li>范围为 <code>选中父元素中所有符合我们所需的所有后代元素【子、孙、曾孙】</code></li><li><code>空格</code> 两边所有基础选择器自选使用</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-id">#id</span> <span class="hljs-selector-tag">span</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>;&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器,"></a>分组选择器<code>,</code></h4><ul><li><p>权重为 </p><p>每个基础元素各自的权重【各是各的不影响】</p><p>, </p><p>以逗号做分割，去计算某个元素权重之和</p><ul><li><code>.div1,.div2</code>权重为<code>10</code>【按照.div单独的权重】</li><li><code>.main&gt;.box1,.main&gt;box2</code>权重为<code>20</code>【按照.main&gt;.box1单独的权重】</li></ul></li><li><p>范围为 <code>选择多个我们所需的元素</code></p></li><li><p>可以将 <code>公用的样式</code>提取出来，降低代码冗余，精简代码</p></li><li><p>示例</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">span</span>&#123;</span><span class="language-css">        ....</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.main</span>&gt;<span class="hljs-selector-class">.box1</span>,<span class="hljs-selector-class">.main</span>&gt;box2&#123;</span><span class="language-css"></span><span class="language-css">    &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h4 id="交集选择器-没符号链接"><a href="#交集选择器-没符号链接" class="headerlink" title="交集选择器 没符号链接"></a>交集选择器 <code>没符号链接</code></h4><ul><li>权重为 <code>没权重，选择器组合之和 </code></li><li>范围为 <code>选中同时具有多个名字元素</code></li><li>选择器和选择器紧紧相连，如<code>div#id</code> <code>span.span</code> <code>.p.content</code></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span><span class="hljs-selector-id">#id</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.span</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-selector-class">.p</span><span class="hljs-selector-class">.content</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css"></span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;span&#x27;</span>&gt;</span>span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;p content&#x27;</span>&gt;</span> p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器 +"></a>相邻兄弟选择器 <code>+</code></h4><ul><li>权重为 <code>没权重，选择器组合之和 </code></li><li>范围为 <code>选中页面中所有与【某个标签（坐标标签）】相邻的【某个标签（目标标签）】，不向上找</code></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">h4</span>+<span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> p0<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器 ~"></a>通用兄弟选择器 <code>~</code></h4><ul><li>权重为 <code>没权重，选择器组合之和 </code></li><li>范围为 <code>选中页面中所有是【某个标签（坐标标签）】的所有【某种兄弟标签（目标标签）】，不论是否相邻，也不向上找</code></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">h4</span>~<span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> p0<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 被改 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器 :"></a>伪类选择器 <code>:</code></h4><ul><li><p>伪元素用于设置元素指定部分的样式</p></li><li><h6 id="a-link-a-visited-a-hover-a-active-常用伪类选择器"><a href="#a-link-a-visited-a-hover-a-active-常用伪类选择器" class="headerlink" title="a:link a:visited a:hover a:active 常用伪类选择器"></a><code>a:link</code> <code>a:visited</code> <code>a:hover</code> <code>a:active</code> 常用伪类选择器</h6><ul><li>是按照特定顺序使用的【爱恨原则lv(love) ha(hate)】<code>a:link</code> <code>a:visited</code> <code>a:hover</code> <code>a:active</code></li><li>权重为 <code>伪类本身10，组合权重相加 </code></li><li>范围为<code>我们指定的元素</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-comment">/* 默认状态 */</span></span><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:red;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 访问过后状态 */</span></span><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:pink;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 鼠标滑上状态 【重点】 */</span></span><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:orange;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 点击此链接状态 */</span></span><span class="language-css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>:black;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="not-排除选择器"><a href="#not-排除选择器" class="headerlink" title=":not() 排除选择器"></a>:not() 排除选择器</h6><ul><li>权重为 <code>伪类本身10，组合权重相加 </code></li><li>范围为 <code>选中页面中所有【除了要排除的元素】之外的元素</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span> <span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-tag">p</span>)&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="only-child-‘独生子’选择器"><a href="#only-child-‘独生子’选择器" class="headerlink" title=":only-child ‘独生子’选择器"></a>:only-child ‘独生子’选择器</h6><ul><li>权重为 <code>伪类本身10，组合权重相加 </code></li><li>范围为 <code>选中页面中所有【只有一个子元素】的元素</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:only-child</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="nth-child-‘特定行’选择器"><a href="#nth-child-‘特定行’选择器" class="headerlink" title=":nth-child() ‘特定行’选择器"></a>:nth-child() ‘特定行’选择器</h6><ul><li><p>权重为 <code>伪类本身10，组合权重相加 </code></p></li><li><p>范围为 </p><p>选中页面中【我们指定的元素行的元素】</p><ul><li><p>数字</p></li><li><p><code>odd</code> 所有奇数行 或 <code>2n+1</code></p></li><li><p><code>even</code> 所有偶数行 或 <code>2n</code></p></li><li><p><code>？n</code> 用一些方程、倍数等选中特定行</p></li><li><h6 id="合并用法"><a href="#合并用法" class="headerlink" title="合并用法"></a>合并用法</h6><ul><li><code>其他选择器:nth-child(第一个)</code> 父元素中的符合第一个选择器又符合行数的那个元素，如果不是那就选不中。</li></ul></li></ul></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.id</span> <span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>n+<span class="hljs-number">1</span>)&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>  <span class="hljs-attr">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="first-child-‘快速选中第一个子元素’选择器"><a href="#first-child-‘快速选中第一个子元素’选择器" class="headerlink" title=":first-child() ‘快速选中第一个子元素’选择器"></a>:first-child() ‘快速选中第一个子元素’选择器</h6><ul><li>权重为 <code>伪类本身10，组合权重相加 </code></li><li>范围为 <code>选中页面中【我们指定的元素的第一个子元素】</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.id</span> <span class="hljs-selector-pseudo">:first</span>-child()&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="last-child-‘快速选中最后一个子元素’选择器"><a href="#last-child-‘快速选中最后一个子元素’选择器" class="headerlink" title=":last-child() ‘快速选中最后一个子元素’选择器"></a>:last-child() ‘快速选中最后一个子元素’选择器</h6><ul><li>权重为 <code>伪类本身10，组合权重相加 </code></li><li>范围为 <code>选中页面中【我们指定的元素的最后一个子元素】</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.id</span> <span class="hljs-selector-pseudo">:last-child</span>()&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="nth-last-child-‘倒序’选择器"><a href="#nth-last-child-‘倒序’选择器" class="headerlink" title=":nth-last-child() ‘倒序’选择器"></a>:nth-last-child() ‘倒序’选择器</h6><ul><li>权重为 <code>伪类本身10，组合权重相加 </code></li><li>范围为 <code>选中页面中【我们指定的元素的最后一个子元素】</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.id</span> <span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">3</span>)&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="nth-of-type-‘特定类型’选择器"><a href="#nth-of-type-‘特定类型’选择器" class="headerlink" title=":nth-of-type() ‘特定类型’选择器"></a>:nth-of-type() ‘特定类型’选择器</h6></li><li><p>权重为 <code>伪类本身10，组合权重相加 </code></p></li><li><p>范围为 </p><p>选中页面某父元素中【我们指定类型的元素的第几个】</p><ul><li><h6 id="合并用法-1"><a href="#合并用法-1" class="headerlink" title="合并用法"></a>合并用法</h6><ul><li><code>其他选择器:nth-last-of-type(第几个)</code> 父元素中的倒序第几个符合类型的那个元素。【first正序】</li><li><code>其他选择器:first-of-type</code> 父元素中的第一个符合类型的那个元素。</li><li><code>其他选择器:last-of-type</code> 父元素中的最后一个符合类型的那个元素。</li></ul></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.id</span> <span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>n+<span class="hljs-number">1</span>)&#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &gt;</span> p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>  <span class="hljs-attr">h4</span> &gt;</span>h4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 不会被选中 --&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- 会被选中 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><hr><h2 id="CSS的三大特性"><a href="#CSS的三大特性" class="headerlink" title="CSS的三大特性"></a>CSS的三大特性</h2><h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><ul><li>某些元素并没有设置某些属性，但是可以继承他祖先元素的属性</li></ul><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><ul><li><p>对同一个元素同一个属性设置了不同的属性值，css处理这种冲突的能力，就叫做重叠性</p></li><li><h6 id="【处理方式】"><a href="#【处理方式】" class="headerlink" title="【处理方式】"></a>【处理方式】</h6><ol><li>首先看权重<ul><li>权重不同，看谁的权重大就听谁的</li><li>权重相同，则按照代码执行顺序来定</li></ul></li></ol></li></ul><h4 id="优先级【权重】"><a href="#优先级【权重】" class="headerlink" title="优先级【权重】"></a>优先级【权重】</h4><ul><li><h6 id="权重等级"><a href="#权重等级" class="headerlink" title="权重等级"></a>权重等级</h6><ul><li>!important&gt;内联样式&gt;id&gt;类&gt;标签&gt;通配符&gt;继承&gt;浏览器默认</li><li><strong>注意</strong> 尽量少用<code>！important </code> 和 <code>内联样式</code>【因为优先级太高了，修改的时候不好改动】</li></ul></li><li><h6 id="important强制使用此样式"><a href="#important强制使用此样式" class="headerlink" title="!important强制使用此样式"></a><code>!important</code>强制使用此样式</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* !important的优先级最高，所以覆盖了行内【内联】样式 */</span></span><span class="language-css">            <span class="hljs-attribute">background-color</span>:pink <span class="hljs-meta">!important</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:black;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h6 id="内联【行内】样式"><a href="#内联【行内】样式" class="headerlink" title="内联【行内】样式"></a>内联【行内】样式</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>            <span class="hljs-comment">&lt;!--内联样式优先级比内嵌样式高，所以覆盖了内嵌等权重较低选择器--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:black;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul><hr><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><h4 id="盒模型的组成部分"><a href="#盒模型的组成部分" class="headerlink" title="盒模型的组成部分"></a>盒模型的组成部分</h4><ul><li><code>content</code>：主要内容区域</li><li><code>padding</code>：元素盒子与内容直接的内填充</li><li><code>border</code>：元素盒子的边框</li><li><code>margin</code>：元素与元素之间的距离 <img src="/../images/css1.jpg" alt="盒模型.png"></li></ul><h4 id="计算盒子的总大小"><a href="#计算盒子的总大小" class="headerlink" title="计算盒子的总大小"></a>计算盒子的总大小</h4><ul><li><code>总盒子的宽度</code>&#x3D;<code>content的width</code>+ 2*<code>padding</code>+2*<code>border</code></li><li><code>总盒子的高度</code>&#x3D;<code>content的height</code>+ 2*<code>padding</code>+2*<code>border</code></li></ul><h4 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h4><ul><li>标准盒模型： <code>box-sizing：content-box；</code></li><li><strong>在标准盒模型中，宽和高指的是<code>content</code>的宽和高</strong> <img src="/../images/css2.jpg" alt="标准盒模型.png"></li></ul><h4 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h4><ul><li>IE盒模型： <code>box-sizing： border-box;</code></li><li><strong>在IE盒模型中，宽和高指的是<code>content+padding+border</code>总盒子的宽和高</strong> <img src="/../images/css3.jpg" alt="IE盒模型.png"></li></ul><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><ul><li><h6 id="width-宽度"><a href="#width-宽度" class="headerlink" title="width 宽度"></a><code>width</code> 宽度</h6><ul><li><code>max-width</code> 最大宽度</li><li><code>min-width</code> 最小宽度</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* 最小宽度 */</span></span><span class="language-css">            <span class="hljs-attribute">min-width</span>:<span class="hljs-number">120px</span>;</span><span class="language-css">            <span class="hljs-comment">/* 最大宽度 */</span></span><span class="language-css">            <span class="hljs-comment">/* max-width:1200px; */</span></span><span class="language-css"></span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容我是内容我是内容我是内容我是内容我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="height-高度"><a href="#height-高度" class="headerlink" title="height 高度"></a><code>height</code> 高度</h6><ul><li><code>max-height</code> 最大高度</li><li><code>min-height</code> 最小高度</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* 最小高度 */</span></span><span class="language-css">            <span class="hljs-attribute">min-height</span>:<span class="hljs-number">120px</span>;</span><span class="language-css">            <span class="hljs-comment">/* 最大高度 */</span></span><span class="language-css">            <span class="hljs-comment">/* max-height:1200px; */</span></span><span class="language-css"></span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容我是内容我是内容我是内容我是内容我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><ul><li><h6 id="border-边框"><a href="#border-边框" class="headerlink" title="border 边框"></a><code>border</code> 边框</h6><ul><li><p><strong>除了使用复合样式外，单独方向的样式都可以单独设置，也可以单个值，两个值，三个值，四个值来控制，规律与padding一致。</strong></p></li><li><p>border-style</p><p> 边框样式</p><ul><li><code>border-方向-style</code> 单独设置边框样式</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* 边框样式 */</span></span><span class="language-css">            <span class="hljs-comment">/* 可以单独设置，也可以单个值，两个值，三个值，四个值来控制 */</span></span><span class="language-css">            <span class="hljs-attribute">border-style</span>: groove;</span><span class="language-css">            <span class="hljs-attribute">border-top-style</span>: dashed;</span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs">border-color<pre><code class="hljs maxima">   边框颜色- `<span class="hljs-built_in">border</span>-方向-<span class="hljs-built_in">color</span>` 单独设置边框颜色```html&lt;<span class="hljs-built_in">style</span>&gt;        .main&#123;            <span class="hljs-comment">/* 边框颜色 */</span>            <span class="hljs-comment">/* 可以单独设置，也可以单个值，两个值，三个值，四个值来控制 */</span>            <span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: teal;            <span class="hljs-built_in">border</span>-right-<span class="hljs-built_in">color</span>:tomato ;            &#125;    &lt;/<span class="hljs-built_in">style</span>&gt;</code></pre></div></code></pre></li><li><p>border-width</p><p> 边框粗细</p><ul><li><code>border-方向-width</code> 单独设置边框粗细</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* 边框粗细 */</span></span><span class="language-css">            <span class="hljs-comment">/* 可以单独设置，也可以单个值，两个值，三个值，四个值来控制 */</span></span><span class="language-css">            <span class="hljs-attribute">border-width</span>: <span class="hljs-number">10px</span>;</span><span class="language-css">            <span class="hljs-attribute">border-top-width</span>: <span class="hljs-number">20px</span>;</span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li><p>border</p><p> 边框复合样式</p><ul><li><code>border</code>复合设置边框属性</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* 边框复合样式 */</span></span><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">30px</span> dashed forestgreen;</span><span class="language-css">            &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li><li><h6 id="padding、margin-内边距、外边距"><a href="#padding、margin-内边距、外边距" class="headerlink" title="padding、margin 内边距、外边距"></a><code>padding、margin</code> 内边距、外边距</h6><ul><li><p>规律顺序</p><ul><li><code>四个值</code>时分别为：<code>上、右、下、左</code></li><li><code>三个值</code>时分别为：<code>上、左右、下</code></li><li><code>两个值</code>时分别为：<code>上下、左右</code></li><li><code>一个值</code>时为：<code>上下左右全部</code></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">span</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">background</span>:green;</span><span class="language-css">        <span class="hljs-comment">/* 四个值时 */</span></span><span class="language-css">            <span class="hljs-comment">/*  上、右、下、左 顺时针方向 */</span></span><span class="language-css">            <span class="hljs-comment">/* padding:10px 50px 100px 200px; */</span></span><span class="language-css">            <span class="hljs-comment">/* margin:10px 50px 100px 200px; */</span></span><span class="language-css"></span><span class="language-css">        <span class="hljs-comment">/* 三个值时 */</span></span><span class="language-css">            <span class="hljs-comment">/* 上、左右、下 */</span></span><span class="language-css">            <span class="hljs-comment">/* padding:10px 50px 100px; */</span></span><span class="language-css">            <span class="hljs-comment">/* margin:10px 50px 100px; */</span></span><span class="language-css"></span><span class="language-css">        <span class="hljs-comment">/* 两个值时 */</span></span><span class="language-css">            <span class="hljs-comment">/* 上下、左右 */</span></span><span class="language-css">            <span class="hljs-comment">/* padding:10px 50px; */</span></span><span class="language-css">            <span class="hljs-comment">/* margin:10px 50px; */</span></span><span class="language-css"></span><span class="language-css">        <span class="hljs-comment">/* 一个值时 */</span></span><span class="language-css">            <span class="hljs-comment">/* 四个方向 */</span></span><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">50px</span>;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-attribute">display</span>:inline-block;</span><span class="language-css">            <span class="hljs-attribute">border</span>:<span class="hljs-number">5px</span> solid gold;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li></ul></li></ul><hr><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul><li>可用于所有元素</li></ul><h4 id="float-浮动值"><a href="#float-浮动值" class="headerlink" title="float 浮动值"></a><code>float</code> 浮动值</h4><ul><li><p>float:left;</p><p> 左浮动</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.contain</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;<span class="hljs-comment">/* 避免高度塌陷 */</span></span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-selector-class">.contain</span>&gt;<span class="hljs-selector-class">.last</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">            <span class="hljs-attribute">float</span>: left;<span class="hljs-comment">/* 左浮动 */</span></span><span class="language-css">            <span class="hljs-attribute">float</span>: right;<span class="hljs-comment">/* 右浮动 */</span></span><span class="language-css">            <span class="hljs-attribute">float</span>: none;<span class="hljs-comment">/* 不浮动 */</span>      </span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span>aaaa<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><p><code>float:right;</code> 右浮动</p></li><li><p><code>float:none;</code> 不浮动，【默认值】元素不浮动，并会显示在其在文本中出现的位置。</p></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>脱离文档流</strong>，“ 不占位置 ”，浮动以后元素会一直向父元素的最上方移动，直到遇到父元素的边框或者其他的浮动元素，会停止移动。</li><li>一般会配合一个父级元素，使用<strong>浮动位置是相对于父级元素</strong>的</li><li>在正常文档流中，块级元素不设置宽高，默认会撑满父级元素；<strong>但一旦设置浮动脱离文档流，就<code>失去了所继承的宽高,转而由自身内容所决定</code></strong></li><li>行内元素不可设置宽高，由自身内容决定；<strong>但一旦设置浮动，则可以设置宽高，会起作用。</strong></li><li>使用浮动，可以实现文字环绕，除了图文混排，不建议使用浮动</li><li><strong>一浮全浮</strong>，多个元素，如果要在一行显示，就把这些元素都设置为浮动</li></ol><h4 id="可能会造成的问题"><a href="#可能会造成的问题" class="headerlink" title="可能会造成的问题"></a>可能会造成的问题</h4><ul><li><h6 id="元素浮动导致的父元素高度塌陷的问题："><a href="#元素浮动导致的父元素高度塌陷的问题：" class="headerlink" title="元素浮动导致的父元素高度塌陷的问题："></a>元素浮动导致的父元素高度塌陷的问题：</h6><ul><li><h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><ul><li>父元素在文档流中高度默认是被子元素撑开的，当子元素脱离文档流以后，将无法撑起父元素的高度，也就会导致父元素的高度塌陷。父元素的高度一旦塌陷, 所有标准流中元素的位置将会上移，导致整个页面的布局混乱</li></ul></li><li><h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><ol><li><h6 id="给浮动元素的父元素设置高度"><a href="#给浮动元素的父元素设置高度" class="headerlink" title="给浮动元素的父元素设置高度"></a>给浮动元素的父元素设置高度</h6><ul><li><code>弊端</code>：高度被固定了</li></ul></li><li><h6 id="给浮动元素的父元素加overflow-hidden样式"><a href="#给浮动元素的父元素加overflow-hidden样式" class="headerlink" title="给浮动元素的父元素加overflow:hidden样式"></a>给浮动元素的父元素加<code>overflow:hidden</code>样式</h6><ul><li>此样式为<code>溢出隐藏</code></li><li><code>弊端</code>：超出范围的内容会被隐藏</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.contain</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        &#125;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.contain</span>&gt;<span class="hljs-selector-class">.last</span>,<span class="hljs-selector-class">.contain</span>&gt;<span class="hljs-selector-class">.box1</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span>aaaa<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;last&quot;</span>&gt;</span>bbbbb<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h6 id="添加块级元素并设置clear样式"><a href="#添加块级元素并设置clear样式" class="headerlink" title="添加块级元素并设置clear样式"></a>添加块级元素并设置clear样式</h6><ul><li>在浮动元素的父元素中，给浮动元素的后面加一个<code>块级元素</code>,然后给这个块级元素设置一个<code>clear</code>样式，此样式的作用为：<code>消除&quot;左浮动元素&quot;、&quot;右浮动元素&quot;或&quot;两个浮动元素一起&quot;的由于使用浮动所造成的影响</code></li><li><code>弊端</code>：需要添加多余的结构以及样式</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">       <span class="hljs-selector-class">.last</span>&#123;</span><span class="language-css">           <span class="hljs-attribute">clear</span>: both;</span><span class="language-css">       &#125;</span><span class="language-css">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;last&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h6 id="快捷固定样式"><a href="#快捷固定样式" class="headerlink" title="快捷固定样式"></a>快捷固定样式</h6><ul><li>有一个固定的几条样式，给浮动元素的父级元素加一个类名，专门用来使用这几条样式，就可以消除浮动造成的不良影响。<strong>【此方式相当于使用 <code>伪元素</code> ，给浮动元素后面添加了一个具有可以请除浮动样式的块级元素，而不是在结构中真的加一个块级元素。【是更加完善的第三种方法】】</strong></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;</span><span class="language-css">            <span class="hljs-comment">/* 实际上就是用伪元素给浮动元素的后面加了一个块级元素，然后使用clear清除了浮动的影响 */</span></span><span class="language-css">            <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;</span><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><span class="language-css">            <span class="hljs-attribute">border-top-style</span>: dashed;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><span class="language-css">            <span class="hljs-attribute">visibility</span>: hidden;</span><span class="language-css">            <span class="hljs-attribute">clear</span>: both;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-comment">/* 这个是用来兼容IE678的，可以不用考虑 */</span></span><span class="language-css">        <span class="hljs-selector-class">.clearfix</span>&#123;</span><span class="language-css">            *zoom:<span class="hljs-number">1</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    ```</code></pre></div></li></ol></li></ul></li></ul><hr><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h4 id="static-静态定位"><a href="#static-静态定位" class="headerlink" title="static 静态定位"></a>static 静态定位</h4><ul><li>默认值，即没有定位，元素出现在正常的文档流中。</li><li>top, bottom, left, right,z-index 声明不生效</li></ul><h4 id="relative-相对定位"><a href="#relative-相对定位" class="headerlink" title="relative 相对定位"></a>relative 相对定位</h4><ul><li><p><strong>生成相对定位的元素，相对于其正常位置进行定位。【参照物是自身原本的位置】</strong></p></li><li><p>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。<strong>设置时是对自己本身的某方向增减距离</strong></p></li><li><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><ol><li><strong>没有脱离文档流，位置还在</strong></li><li>定位的元素有层级关系，层级高于普通文档流</li><li>通常用于给绝对定位作参照物</li><li>相对自身原本位置定位</li></ol><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.div1</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-selector-class">.div2</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>:pink;</span><span class="language-css">            <span class="hljs-comment">/* 相对定位 ：参照物是自身原本位置*/</span></span><span class="language-css">            <span class="hljs-attribute">position</span>:relative;</span><span class="language-css">            <span class="hljs-attribute">left</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">            <span class="hljs-attribute">top</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;div1&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>            div1            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;div2&#x27;</span>&gt;</span>                div2            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul><h4 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute 绝对定位"></a>absolute 绝对定位</h4><ul><li><p><strong>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位</strong></p></li><li><p>元素位置通过<code>&quot;left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot;</code> 以及 <code>&quot;bottom&quot;</code> 属性进行规定</p></li><li><p>元素层级通过<code>&quot;z-index&quot;</code>属性进行规定</p></li><li><p><strong>参照物是<code>position：relative</code> 或者 <code>position:absolute</code>、<code>position:fixed</code> ,只要是三者之一即可,都可以作为绝对定位的参照物。【但通常 “<code>最外层</code>” 是以相对定位的元素为参照物的】</strong></p></li><li><h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><ol><li><strong>脱离文档流</strong></li><li>层级高于普通文档流</li><li>参照物必须是 <strong>“祖先级”元素【该元素必须作为其后代存在】</strong></li><li>浏览器在设置参照物的时候，<strong>是按照“就近原则”</strong>，一直向上找，找到为止，如果都没有，就以body作为参照物</li><li><strong>当向上找的时候，除了<code>position:relative;</code> 发现某个祖先级元素设置了<code>position：fixed</code>或<code>position：absolute</code>时，此元素就会以这个元素作为参照物，不会再去向上找设置了<code>position:relative;</code>的元素了。</strong></li><li><strong>块级元素</strong>设置浮动、定位后，宽就不再继承父元素，而是内容决定。</li><li><strong>行内元素</strong>，定位之后，宽、高也可以起作用。</li><li>如果<strong>用百分比设置绝对定位元素的宽度</strong>时，是<strong>相对该元素的参照物</strong>来说的，而不是父级。</li></ol><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-class">.div1</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;</span><span class="language-css">                <span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;</span><span class="language-css">                <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">                <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid black;</span><span class="language-css">                <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;</span><span class="language-css">                <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">20px</span>;</span><span class="language-css">                <span class="hljs-comment">/* 相对定位：作为参照物 */</span></span><span class="language-css">                <span class="hljs-attribute">position</span>:relative;</span><span class="language-css">            &#125;</span><span class="language-css">            </span><span class="language-css">            <span class="hljs-selector-class">.div5</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">width</span>:<span class="hljs-number">120px</span>;</span><span class="language-css">                <span class="hljs-attribute">height</span>:<span class="hljs-number">120px</span>;</span><span class="language-css">                <span class="hljs-attribute">background-color</span>:tomato;</span><span class="language-css">                <span class="hljs-comment">/* 绝对定位 */</span></span><span class="language-css">                <span class="hljs-attribute">position</span>:absolute;</span><span class="language-css">                <span class="hljs-attribute">right</span>:<span class="hljs-number">100px</span>;</span><span class="language-css">                <span class="hljs-attribute">bottom</span>:<span class="hljs-number">200px</span>;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;div1&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>div1                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;div5&#x27;</span>&gt;</span>div5                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li></ul><h4 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed 固定定位"></a>fixed 固定定位</h4><ul><li><p>生成绝对定位的元素，相对于浏览器窗口进行定位。<strong>参照物是body</strong></p></li><li><p>元素位置通过<code>&quot;left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot;</code> 以及 <code>&quot;bottom&quot;</code> 属性进行规定</p></li><li><p>元素层级通过</p><p><code>&quot;z-index&quot;</code></p><p>属性进行规定</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-class">.div1</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;</span><span class="language-css">                <span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;</span><span class="language-css">                <span class="hljs-attribute">background-color</span>:porple;</span><span class="language-css">                <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid black;</span><span class="language-css">                <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;</span><span class="language-css">                <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;</span><span class="language-css">                <span class="hljs-comment">/* 绝对定位:固定在页面左上角 */</span></span><span class="language-css">                <span class="hljs-attribute">position</span>:fixed;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;div1&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;class&#x27;</span>&gt;</span>                div1            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li></ul><h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><ul><li><code>z-index</code><ul><li>调整脱离文档流的元素的层级，数值越大，层级越高</li></ul></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><h6 id="如何让一个元素在整个屏幕或者是一个盒子中水平垂直居中"><a href="#如何让一个元素在整个屏幕或者是一个盒子中水平垂直居中" class="headerlink" title="如何让一个元素在整个屏幕或者是一个盒子中水平垂直居中"></a>如何让一个元素在整个屏幕或者是一个盒子中水平垂直居中</h6><ul><li>给元素添加定位 <code>position:absolute;</code></li><li><code>left:50%;</code></li><li><code>top:50%;</code></li><li><code>margin-left:负的盒子宽的一半;</code></li><li><code>margin-top:负的盒子高度的一半;</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">            <span class="hljs-selector-tag">body</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;</span><span class="language-css">            &#125;</span><span class="language-css">            <span class="hljs-selector-class">.outer</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">                <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">                <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">            &#125;</span><span class="language-css">            <span class="hljs-selector-class">.center</span>&#123;</span><span class="language-css">                <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">                <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">                <span class="hljs-attribute">background-color</span>: tomato;</span><span class="language-css">                <span class="hljs-attribute">position</span>: absolute;</span><span class="language-css">                <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><span class="language-css">                <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><span class="language-css">                <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;</span><span class="language-css">                <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;</span><span class="language-css">            &#125;</span><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>                div            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><hr><h2 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h2><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul><li>pc端IE10及以上放心使用，移动端直接用。 <img src="/../images/css4.jpg" alt="flex兼容性.png"></li></ul><h4 id="传统布局"><a href="#传统布局" class="headerlink" title="传统布局"></a>传统布局</h4><ul><li>传统布局基于盒模型，通过position定位+float浮动+display属性进行调整。这样实际上不是很方便，比如垂直居中就不是很方便</li></ul><h4 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h4><ul><li><p>弹性布局可以为盒状模型提供最大的灵活性</p></li><li><p><code>display:flex;</code> 代表的是块级</p></li><li><p><code>display:inline-flex;</code> 代表的是行内块</p></li><li><p><strong>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效！</strong></p></li><li><p><strong>容器和项目：</strong> 一旦给某个元素设置了flex布局，该元素就变成了 <code>flex容器</code>，容器的所有子元素，都自动成为容器的成员，被称为 <code>项目</code></p></li><li><p>两根轴：</p><p>默认为水平的主轴，和垂直的交叉轴【侧轴】</p><ul><li>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；</li><li>交叉轴的开始位置叫做cross start，结束位置叫做cross end。 <img src="/../images/css5.jpg" alt="flex布局.png"></li></ul></li></ul><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ul><li>一旦给某个元素设置了flex布局，该元素就变成了 <code>flex容器</code></li></ul><h5 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h5><ul><li><h5 id="控制主轴方向-flex-direction"><a href="#控制主轴方向-flex-direction" class="headerlink" title="控制主轴方向 flex-direction"></a>控制主轴方向 <code>flex-direction</code></h5><ul><li>设置后，项目会按照指定的容器主轴方向排列</li><li>默认为横向【从左到右】 <img src="/../images/css6.jpg" alt="主轴方向.png"></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><span class="language-css">            <span class="hljs-comment">/* 设置水平轴为主轴【从左到右】  */</span></span><span class="language-css">            <span class="hljs-attribute">flex-direction</span>:row;</span><span class="language-css">            <span class="hljs-comment">/* 设置垂直轴为主轴【从上到下】 */</span></span><span class="language-css">            <span class="hljs-comment">/* flex-direction:column; */</span></span><span class="language-css">            <span class="hljs-comment">/* 设置反向水平轴为主轴 */</span></span><span class="language-css">            <span class="hljs-comment">/* flex-direction:row-reverse; */</span></span><span class="language-css">            <span class="hljs-comment">/* 设置反向垂直轴为主轴 */</span></span><span class="language-css">            <span class="hljs-comment">/* flex-direction:column-reverse; */</span></span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h5 id="换行-flex-wrap"><a href="#换行-flex-wrap" class="headerlink" title="换行 flex-wrap"></a>换行 <code>flex-wrap</code></h5><ul><li>设置后，项目会在沿主轴方向充满容器后换行 </li><li>默认为不换行</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.list</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><span class="language-css">            <span class="hljs-comment">/* 设置水平轴为主轴【默认】 */</span></span><span class="language-css">            <span class="hljs-attribute">flex-direction</span>:row;</span><span class="language-css">            <span class="hljs-comment">/* 设置垂直轴为主轴 */</span></span><span class="language-css">            <span class="hljs-comment">/* flex-direction:column; */</span></span><span class="language-css">            <span class="hljs-comment">/* 设置反向水平轴为主轴 */</span></span><span class="language-css">            <span class="hljs-comment">/* flex-direction:row-reverse; */</span></span><span class="language-css">            <span class="hljs-comment">/* 设置反向垂直轴为主轴 */</span></span><span class="language-css">            <span class="hljs-comment">/* flex-direction:column-reverse; */</span></span><span class="language-css">            <span class="hljs-comment">/* 换行 */</span></span><span class="language-css">            <span class="hljs-attribute">flex-wrap</span>:wrap;</span><span class="language-css">            <span class="hljs-comment">/* 不换行【默认】 */</span></span><span class="language-css">            <span class="hljs-comment">/* flex-wrap:nowrap; */</span></span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h5 id="主轴-换行-flex-flow【复合属性】"><a href="#主轴-换行-flex-flow【复合属性】" class="headerlink" title="主轴&amp;换行 flex-flow【复合属性】"></a>主轴&amp;换行 <code>flex-flow</code>【复合属性】</h5><ul><li>第一个值代表设置主轴方向</li><li>第二个值代表设置是否换行</li><li>两个值空格隔开</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.list</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><span class="language-css">            <span class="hljs-attribute">flex-flow</span>:column wrap;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h5 id="控制项目在主轴方向的对齐方式-justify-content【常用】"><a href="#控制项目在主轴方向的对齐方式-justify-content【常用】" class="headerlink" title="控制项目在主轴方向的对齐方式 justify-content【常用】"></a>控制项目在主轴方向的对齐方式 <code>justify-content</code>【常用】</h5><ul><li><code>center</code> 在主轴居中</li><li><code>flex-start</code>对齐主轴起始端</li><li><code>flex-end</code>对齐主轴结束端</li><li><code>space-between</code>项目在容器主轴方向两端对齐</li><li><code>space-around</code>在主轴上，每个项目间的间距是项目距离容器边框的距离的二倍 </li><li><code>space-evenly</code>在主轴上，每个项目间的间距与项目距离容器边框的距离相等</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.list</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><span class="language-css">            <span class="hljs-attribute">justify-content</span>:space-between;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h5 id="控制项目在交叉轴方向的对齐方式-align-items【常用】"><a href="#控制项目在交叉轴方向的对齐方式-align-items【常用】" class="headerlink" title="控制项目在交叉轴方向的对齐方式 align-items【常用】"></a>控制项目在交叉轴方向的对齐方式 <code>align-items</code>【常用】</h5><ul><li><p><code>center</code> 在交叉轴居中</p></li><li><p><code>flex-start</code>对齐交叉轴起始端</p></li><li><p><code>flex-end</code>对齐交叉轴结束端</p></li><li><p><code>stretch</code></p><p>项目充满整个交叉轴【不常用】</p><ul><li><strong>【若项目在交叉轴上所占的比例不写，或设为auto，则它将占满整个交叉轴】</strong></li></ul></li><li><p><code>baseline</code> 项目的第一行文字的基线对齐</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.list</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><span class="language-css">            <span class="hljs-attribute">flex-wrap</span>:nowrap;</span><span class="language-css">            <span class="hljs-comment">/* 水平垂直居中 */</span></span><span class="language-css">            <span class="hljs-attribute">justify-content</span>:center;</span><span class="language-css">            <span class="hljs-attribute">align-items</span>:center;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li><li><h5 id="控制项目在交叉轴方向的对齐方式-align-content【换行导致多根轴线前提下】"><a href="#控制项目在交叉轴方向的对齐方式-align-content【换行导致多根轴线前提下】" class="headerlink" title="控制项目在交叉轴方向的对齐方式 align-content【换行导致多根轴线前提下】"></a>控制项目在交叉轴方向的对齐方式 <code>align-content</code><strong>【换行导致多根轴线前提下】</strong></h5><ul><li><p><code>center</code> 在交叉轴居中</p></li><li><p><code>flex-start</code>对齐交叉轴起始端</p></li><li><p><code>flex-end</code>对齐交叉轴结束端</p></li><li><p><code>space-between</code>多个主轴项目在容器交叉轴方向两端对齐</p></li><li><p><code>space-around</code>在交叉轴上，【两个主轴项目】间的【交叉轴间距】是【其中一个主轴项目】在【交叉轴上】距离容器边框的距离的二倍</p></li><li><p><code>stretch</code></p><p>项目充满整个交叉轴【不常用】</p><ul><li><strong>【若项目在交叉轴上所占的比例不写，或设为auto，则它将占满整个交叉轴】</strong></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-class">.list</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><span class="language-css">            <span class="hljs-comment">/* 必须是在换行的前提下，因为换行会导致多跟轴线 */</span></span><span class="language-css">            <span class="hljs-attribute">flex-wrap</span>:wrap;</span><span class="language-css">            <span class="hljs-attribute">justify-content</span>:space-between;</span><span class="language-css">            <span class="hljs-attribute">align-content</span>:space-between;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html基础笔记</title>
    <link href="/2022/04/23/html%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/23/html%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML-概念"><a href="#HTML-概念" class="headerlink" title="HTML 概念"></a>HTML 概念</h2><blockquote><p><strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage 超文本标记语言。</p></blockquote><h2 id="HTML-作用"><a href="#HTML-作用" class="headerlink" title="HTML 作用"></a>HTML 作用</h2><blockquote><p>HTML 就是负责描述页面的语义</p></blockquote><h2 id="认识-html"><a href="#认识-html" class="headerlink" title="认识 html"></a>认识 html</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>页面标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td><code>**&lt;!DOCTYPE html&gt;**</code></td><td>声明为 HTML5 文档</td></tr><tr><td><code>**&lt;html&gt;**</code></td><td>元素是 HTML 页面的根元素</td></tr><tr><td><code>**&lt;head&gt;**</code></td><td>元素包含了文档的元（meta）数据，如 &lt;<code>meta charset=&quot;utf-8&quot;&gt;</code> 定义网页编码格式为 <code>**utf-8**</code>。</td></tr><tr><td><code>**&lt;title&gt;**</code></td><td>元素描述了文档的标题，浏览器标签名</td></tr><tr><td><code>**&lt;body&gt;**</code></td><td>元素包含了可见的页面内容</td></tr><tr><td><code>**&lt;h1&gt;**</code></td><td>元素定义一个大标题</td></tr><tr><td><code>**&lt;p&gt;**</code></td><td>元素定义一个段落</td></tr><tr><td><code>**&lt;!-- 内容 --&gt;**</code></td><td>注释内容</td></tr></tbody></table><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><table><thead><tr><th>字符集</th><th>说明</th></tr></thead><tbody><tr><td>UTF-8</td><td>字多，有各种国家的语言，但是保存尺寸大，文件臃肿；</td></tr><tr><td>gb2312</td><td>字少，只用中文和少数外语和符号，但是尺寸小，文件小巧</td></tr></tbody></table><h2 id="关键字和描述"><a href="#关键字和描述" class="headerlink" title="关键字和描述"></a>关键字和描述</h2><h3 id="head-和-meta"><a href="#head-和-meta" class="headerlink" title="head 和 meta"></a>head 和 meta</h3><table><thead><tr><th>head meta</th><th>说明</th></tr></thead><tbody><tr><td>meta name&#x3D;”Description”</td><td>定义 html 页面描述有助于 seo 优化</td></tr><tr><td>meta name&#x3D;”Keywords”</td><td>定义关键，告诉搜索引擎网页的内容</td></tr></tbody></table><h3 id="head-和-title"><a href="#head-和-title" class="headerlink" title="head 和 title"></a>head 和 title</h3><table><thead><tr><th>名字</th><th>说明</th></tr></thead><tbody><tr><td>title</td><td>是网页的标题，也是有助于 SEO 搜索引擎优化的。</td></tr></tbody></table><h2 id="HTML-基本语法特点"><a href="#HTML-基本语法特点" class="headerlink" title="HTML 基本语法特点"></a>HTML 基本语法特点</h2><h3 id="不敏感形式"><a href="#不敏感形式" class="headerlink" title="不敏感形式"></a>不敏感形式</h3><ul><li>换行不敏感</li><li>tab 不敏感</li></ul><h3 id="html-标签种类"><a href="#html-标签种类" class="headerlink" title="html 标签种类"></a>html 标签种类</h3><ul><li>容器级别（能容纳任何 html 元素）</li><li>文本级别（能容纳文字、图片、表单元素）</li></ul><h2 id="html-表现形式"><a href="#html-表现形式" class="headerlink" title="html 表现形式"></a>html 表现形式</h2><ul><li>双标签 <code>&lt;div&gt;&lt;/div&gt;</code></li><li>单标签 <code>&lt;img /&gt;</code></li><li>标签中的元素属性 <code>&lt;div id=&quot;ab&quot;&gt;&lt;/div&gt;</code></li></ul><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>更多的全局属性查看 MDN 总结的 全局属性</p><h2 id="html-语义化标签"><a href="#html-语义化标签" class="headerlink" title="html 语义化标签"></a>html 语义化标签</h2><h3 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h3><p>1.<strong>概念</strong></p><p>HTML5 的语义化指的是<code>合理正确的使用语义化的标签来创建页面结构</code>。【正确的标签做正确的事】</p><ol><li><strong>语义化的优点</strong>:</li></ol><ul><li>更好的展示展示效果</li><li>代码结构清晰，易于阅读与维护，</li><li>有利于搜索引擎优化（SEO）</li></ul><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><ul><li>audio：音频</li><li>video 视频</li><li>form: 表单</li><li>progress： 进度条</li><li>meter 度量器</li></ul><h2 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--注释的内容--&gt;</span></code></pre></div><h2 id="HTML-字符实体"><a href="#HTML-字符实体" class="headerlink" title="HTML 字符实体"></a>HTML 字符实体</h2><p><strong>HTML 中的预留字符必须被替换为字符实体。</strong></p><p>字符实体</p><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>实体编号</th></tr></thead><tbody><tr><td></td><td>空格</td><td>&#96;&#96;</td><td>&#96;&#96;</td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&lt;</code></td><td><code>&lt;</code></td></tr><tr><td>大于号</td><td><code>&gt;</code></td><td><code>&gt;</code></td><td></td></tr><tr><td>&amp;</td><td>和号</td><td><code>&amp;</code></td><td><code>&amp;</code></td></tr><tr><td>“</td><td>引号</td><td><code>&quot;</code></td><td><code>&quot;</code></td></tr><tr><td>‘</td><td>撇号</td><td><code>&#39;</code> (IE 不支持)</td><td><code>&#39;</code></td></tr><tr><td>￠</td><td>分（cent）</td><td><code>¢</code></td><td><code>¢</code></td></tr><tr><td>£</td><td>镑（pound）</td><td><code>£</code></td><td><code>£</code></td></tr><tr><td>¥</td><td>元（yen）</td><td><code>¥</code></td><td><code>¥</code></td></tr><tr><td>€</td><td>欧元（euro）</td><td><code>€</code></td><td><code>€</code></td></tr><tr><td>§</td><td>小节</td><td><code>§</code></td><td><code>§</code></td></tr><tr><td>©</td><td>版权（copyright）</td><td><code>©</code></td><td><code>©</code></td></tr><tr><td>®</td><td>注册商标</td><td><code>®</code></td><td><code>®</code></td></tr><tr><td>™</td><td>商标</td><td><code>™</code></td><td><code>™</code></td></tr><tr><td>×</td><td>乘号</td><td><code>×</code></td><td><code>×</code></td></tr><tr><td>÷</td><td>除号</td><td><code>÷</code></td><td><code>÷</code></td></tr></tbody></table><h2 id="html-图片"><a href="#html-图片" class="headerlink" title="html 图片"></a>html 图片</h2><p>插入图片的方法：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> **<span class="hljs-attr">src</span>=<span class="hljs-string">&quot;baby.jpg&quot;</span> ** <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;提示&quot;</span> /&gt;</span></code></pre></div><table><thead><tr><th>img 属性</th><th>属性说明</th></tr></thead><tbody><tr><td>src</td><td>地址属性名</td></tr><tr><td>alt</td><td>不能正常显示的备用显示文字</td></tr></tbody></table><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;1.html&quot;</span>&gt;</span>结婚照<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><table><thead><tr><th>a 属性</th><th>属性说明</th></tr></thead><tbody><tr><td>href</td><td>表示 a 指向的链接</td></tr><tr><td>title</td><td>悬停显示文本</td></tr><tr><td>target</td><td><code>_blank</code>新建一个窗口，另外还支持：<code>_self/_parent/_top</code></td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h3><p>有序列表使用 <code>ol &gt; li</code> 方式进行书写，注意 li<code>(容器标签)</code> 元素不能单独存在。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>A Cat<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>A Dog<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><h3 id="无序"><a href="#无序" class="headerlink" title="无序"></a>无序</h3><p>无序列表使用 <code>ul &gt; li</code> 方式进行书写，注意 li<code>(容器标签)</code> 元素不能单独存在。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>A Cat<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>A Dog<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>dl</td><td>定义列表</td></tr><tr><td>dt</td><td>定义标题（容器标签）</td></tr><tr><td>dd</td><td>定义描述（容器标签）</td></tr></tbody></table><p>使用什么标签根据语义来做是做好，这样最大程度的满足了机器和人的阅读。</p><h2 id="div"><a href="#div" class="headerlink" title="div"></a>div</h2><p>使用广泛的元素（本意是 division），如上面元素所示，是一个容器元素任何元素都能用。</p><h2 id="span-的却别"><a href="#span-的却别" class="headerlink" title="span 的却别"></a>span 的却别</h2><p>与 div 有很多的相似之后， span 表示一个区域标签，一般用于放置文本。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>表格相关元素</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>包裹元素</td></tr><tr><td>th</td><td>定义表格的表头</td></tr><tr><td>tr</td><td>定义表格的行</td></tr><tr><td>td</td><td>定义表格单元</td></tr></tbody></table><p>几个核心元素</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1122<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2211<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>form 元素</p><h3 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h3><ul><li>input type&#x3D;text</li></ul><h3 id="密码框"><a href="#密码框" class="headerlink" title="密码框"></a>密码框</h3><ul><li>input type&#x3D;password</li></ul><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><ul><li>input type&#x3D;radio</li></ul><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><ul><li>input type&#x3D;checkbox</li></ul><h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>E<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>F<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>G<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h3 id="多行文本框（文本域）"><a href="#多行文本框（文本域）" class="headerlink" title="多行文本框（文本域）"></a>多行文本框（文本域）</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></code></pre></div><p>常见属性：</p><ul><li>cols 属性列</li><li>rows 属性行</li></ul><h3 id="三种按钮"><a href="#三种按钮" class="headerlink" title="三种按钮"></a>三种按钮</h3><p>1）普通按钮：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;**button**&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;I&#x27;m a button&quot;</span> /&gt;</span></code></pre></div><p>2）提交按钮：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;**submit**&quot;</span> /&gt;</span></code></pre></div><p>3）重置按钮：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;**reset**&quot;</span> /&gt;</span></code></pre></div><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p><strong>块级（block）元素的特点：</strong></p><ul><li>总是在新行上开始；</li><li>高度，行高以及外边距和内边距都可控制；</li><li>宽度缺省是它的容器的 100%，除非设定一个宽度；</li><li>它可以容纳内联元素和其他块元素</li></ul><table><thead><tr><th>块元素</th><th>说明</th></tr></thead><tbody><tr><td>p</td><td>段落</td></tr><tr><td>table</td><td>表格</td></tr><tr><td>blockquote</td><td>引用</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>dir</td><td>目录列表</td></tr><tr><td>div</td><td>常用块级标签</td></tr><tr><td>form</td><td>表单</td></tr><tr><td>h1</td><td>标题（6 个级别）</td></tr><tr><td>hr</td><td>水平分割线</td></tr><tr><td>isindex</td><td>input prompt</td></tr><tr><td>menu</td><td>菜单列表</td></tr><tr><td>ol</td><td>排序列表</td></tr><tr><td>pre</td><td>格式化文本</td></tr><tr><td>ul</td><td>无序列表</td></tr></tbody></table><h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p><strong>内联（inline）元素的特点：</strong></p><ul><li>和其他元素都在一行上；</li><li>高，行高及外边距和内边距不可改变；</li><li>宽度就是它的文字或图片的宽度，不可改变；</li><li>内联元素只能容纳文本或者其他内联元素。</li></ul><table><thead><tr><th>块状元素</th><th>说明</th></tr></thead><tbody><tr><td>abbr</td><td>缩写</td></tr><tr><td>acronym</td><td>首字</td></tr><tr><td>b</td><td>粗体</td></tr><tr><td>big</td><td>大字体</td></tr><tr><td>br</td><td>换行</td></tr><tr><td>cite</td><td>引用</td></tr><tr><td>code</td><td>引用代码</td></tr><tr><td>dfn</td><td>定义字段</td></tr><tr><td>em</td><td>强调</td></tr><tr><td>i</td><td>斜体</td></tr><tr><td>img</td><td>图片</td></tr><tr><td>input</td><td>输入框</td></tr><tr><td>label</td><td>表格标签</td></tr><tr><td>q</td><td>行内引用</td></tr><tr><td>s</td><td>中划线</td></tr><tr><td>select</td><td>项目选择</td></tr><tr><td>small</td><td>小字体</td></tr><tr><td>span</td><td>常用内联容器，定义文本内区块</td></tr><tr><td>strike</td><td>中划线</td></tr><tr><td>strong</td><td>粗体强调</td></tr><tr><td>sub</td><td>下标</td></tr><tr><td>sup</td><td>上标</td></tr><tr><td>a</td><td>锚点</td></tr></tbody></table><h3 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h3><p>根据上下文确定块状元素和内联元素：</p><table><thead><tr><th>可变元素</th><th>说明</th></tr></thead><tbody><tr><td><code>applet</code></td><td>java applet</td></tr><tr><td><code>button</code></td><td>按钮</td></tr><tr><td><code>del</code></td><td>删除文本</td></tr><tr><td><code>frame</code></td><td>inline frame</td></tr><tr><td><code>ins</code></td><td>插入的文本</td></tr><tr><td><code>map</code></td><td>图片区块(map)</td></tr><tr><td><code>object</code></td><td>object 对象</td></tr><tr><td><code>script</code></td><td>客户端脚本</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaweb基础学习</title>
    <link href="/2022/03/12/javaweb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/12/javaweb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、WEB应用程序"><a href="#一、WEB应用程序" class="headerlink" title="一、WEB应用程序"></a>一、WEB应用程序</h1><p>B&#x2F;S ( browser&#x2F;server ，浏览器&#x2F;服务器）架构</p><p>基于HTTP传输协议（超文本传输协议，回忆HTML的名字：超文本标记语言）</p><p>WEB程序必须要运行在web容器上，如Tomcat &#x2F;Jboss&#x2F;WebLogic等</p><h1 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h1><p>HTTP使用TCP作为它的支撑运输层协议，默认的端口是80（缺省端口）。</p><p>超文本传输协议(Hypertext Transfer Protocol，简称HTTP)是应用层协议。HTTP 是一种请求&#x2F;响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求;服务器接到请求后，给予相应的响应信息。　</p><p>HTTP 请求报文HTTP 请求报文由请求行、请求头部、空行 和 请求包体 4 个部分组成</p><p>HTTP 请求报文由请求行、请求头部、空行 和 请求包体 4 个部分组成下面对请求报文格式进行简单的分析：</p><p>请求行：请求行由方法字段、URL 字段 和HTTP 协议版本字段 3 个部分组成，他们之间使用空格隔开。常用的 HTTP 请求方法有 GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT;</p><p>GET：当客户端要从服务器中读取某个资源时，使用GET 方法。GET 方法要求服务器将URL 定位的资源放在响应报文的数据部分，回送给客户端，即向服务器请求某个资源。使用GET 方法时，请求参数和对应的值附加在 URL 后面，利用一个问号(“?”)代表URL 的结尾与请求参数的开始，传递参数长度受限制。例如，&#x2F;index.jsp?id&#x3D;100&amp;op&#x3D;bind。</p><p>POST：当客户端给服务器提供信息较多时可以使用POST 方法，POST 方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。GET 一般用于获取&#x2F;查询资源信息，POST 会附带用户数据，一般用于更新资源信息。POST 方法将请求参数封装在HTTP 请求数据中，以名称&#x2F;值的形式出现，可以传输大量数据;请求头部：请求头部由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。</p><p>请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><p>User-Agent：产生请求的浏览器类型;</p><p>Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ <em>&#x2F;</em> ” 指示可接受全部类型，用“ type&#x2F;* ”指示可接受 type 类型的所有子类型;</p><p>Accept-Language：客户端可接受的自然语言;</p><p>Accept-Encoding：客户端可接受的编码压缩格式;</p><p>Accept-Charset：可接受的应答的字符集;</p><p>Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;</p><p>connection：连接方式(close 或 keepalive);</p><p>Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;</p><p>空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头;</p><p>请求包体：请求包体不在 GET 方法中使用，而是在POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求包体相关的最常使用的是包体类型 Content-Type 和包体长度 Content-Length。</p><p>HTTP 响应报文HTTP 响应报文由状态行、响应头部、空行 和 响应包体 4 个部分组成</p><p>下面对响应报文格式进行简单的分析：</p><p>状态行：状态行由 HTTP 协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开; 状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：</p><p>1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;</p><p>2xx：表示服务器已成功接收到请求并进行处理;</p><p>3xx：表示服务器要求客户端重定向;</p><p>4xx：表示客户端的请求有非法内容;　</p><p>5xx：表示服务器未能正常处理客户端的请求而出现意外错误;</p><p>状态码描述文本有如下取值：</p><p>200 OK：表示客户端请求成功;　</p><p>400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解;　</p><p>401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用;</p><p>403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因;　</p><p>404 Not Found：请求的资源不存在，例如，输入了错误的URL;　</p><p>500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求;　</p><p>503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常;</p><h1 id="三、Servlet"><a href="#三、Servlet" class="headerlink" title="三、Servlet"></a>三、Servlet</h1><p>Servlet是javaWEB的核心，简单的说就是用Java编写的服务器端程序。用户进行一个动态请求（静态请求就是直接请求HTML )时，实际上是请求—个servlet</p><p>WEB容器将Servlet加载到内存 通过init方法进行初始化</p><p>Service()方法根据请求方法调用对应的处理方法doPost()或doGet()，还有一些其他的请求方法doPut() doOptions()…但这些方法不常用，并且从安全的角度都是建议屏蔽的。</p><p>当Server不再需要Servlet时（一般当Server关闭时），Server调用 Servlet 的 destroy() 方法。</p><h1 id="四、JSP"><a href="#四、JSP" class="headerlink" title="四、JSP"></a>四、JSP</h1><p>Java Server Pages是一种静态编码町机和动态编码Java混合的技术， 也有说法就是将java代码镶嵌在HTML上，在JSP之前，Servlet作为主体，功能比较强大，设计也很先进，但瑜出 HTML页面却完全是Java的out.print()， 一行一句的输出，对于页面编写和修改来说非常不方便，这才促使SUN公司推出JSP。JSP和ASP、PHP类似都是镶嵌型语言。另外补充一下，WEB容器后动的时候，会将_JSP编译成Servlet，也有说法JSP是Servlet的升级版。</p><h1 id="五、Tomcat"><a href="#五、Tomcat" class="headerlink" title="五、Tomcat"></a>五、Tomcat</h1><p>Java WEB容器有很多，这里以Tomcat为例来说。前面说到，WEB程序必须运行在WEB容器上。Tomcat就是作为WEB容器来运行切Java WEB程序的。Tomcat是JAVA语言写的，需要JVM作为运行环境。</p><p>Tomcat的目录结构</p><p>bin………………………………可执行程序（脚本），启动停止调试Tomcat的一些bat.sh</p><p>conf…………………………….配置文件 webx.ml server.xml 等</p><p>lib……………………………….Tomcat运行需要的jar包</p><p>logs…………………………….曰志文件</p><p>temp…………………………….临时文件</p><p>webapps………………………WEB 程序(编译后的项目文件)</p><p>work…………………………….将jsp文件生成java文件在此目录进行</p><p>补充说明一下，Tomcat将jsp编译成Java文件并不是实时进行的，所以有时候修改了页面，并没有及时生效，这时候我们只需要删除一下work目录下对应的文件即可。</p><h1 id="六、Java-WEB项目结构"><a href="#六、Java-WEB项目结构" class="headerlink" title="六、Java WEB项目结构"></a>六、Java WEB项目结构</h1><p>一般来说，我们常说的Java项目基本上都是WEB项目（B&#x2F;S架构），不是说Java不能做C&#x2F;S程序，实际上Java的Swing就是画界面的，但是现在C#已经成为画界面最流行的语言，快速，简单，所以越来越少的人用Java来做C&#x2F;S程序开发了。我们主要来说Java WEB项目，下面是最基本的项目结构。</p><p>src…………………………….JAVA源码，java文件目录</p><p>webContent&#x2F;webRoot……………项目发布目录</p><p>WEB-INF</p><p>lib………………………………….项目需要的jar包</p><p>web.xml…………………………WEB 程序的入口</p><p>以上是Java WEB项目的核心结构，实际开发中，搭建项目会比这些复杂，特别是引用框架以后，配置文件的增加，会添加一些新的目录。</p><h1 id="七、开发框架"><a href="#七、开发框架" class="headerlink" title="七、开发框架"></a>七、开发框架</h1><p>前面提到客户端发起动态请求时，请求到Servlet进行处理，然后返回，整个请求处理的工作都是在Servlet中处理的，看起来比较简单，每当需要一个不同的请求就写一个Servlet，但实际开发的时候如果功能模块比较多，就需要写很多个Servlet，并且如果我们想修改一个请求的返回，也必须通过修改Java代码 (Servlet)的方式来实现。</p><p>这样对功能的扩展和维护来说，就比较麻烦了，所以也就推动了很多集成幵发框架的流行，比如Webwork，Struts，SpringMVC，Jfinal等都是主流的Java WEB开发框架。</p><p>使用框架有一个很笼统的优点概述，可以加快开发进程，在类似项目中重用代码将为开发者节省大量的时间和精力.框架为执行繁琐的代码任务提供预建模块。让使用者只关心核心业务的开发，框架帮你屏蔽原有技术跟业务开发无关的各类技术问题。但如果想要深入的了解一个框架，使用的更加熟练，还是需要了解底层的原理，找到其源头也就是Servlet。</p><p>以SpringMVC为例简单描述一下工作原理</p><p>SprfngMVC主要也是通过DispatcherServlet (Servlet调配器，在web_xml中配置）实现了Servlet这个接口，又叫前端控制器，来自前端的请求会先到达这里，它负责到后台去匹配合适的handler。DispatcherServlet的主要工作流程如下：</p><p>1、 客户端发出http请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet.</p><p>2、 DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器Controller (Handler)。</p><p>3、 DispatclierServlet 根据 HandlerMapping 找到对应的Handler，将处理权交给Handler ( Handler将具体的处理进行封装），再由具体的 HandlerAdapter对Handler进行具体的调用。</p><p>5、Handler对数据处理完成以后将返回一个ModeAndView对象给DispatcherServlet.</p><p>6、 Handler返回的ModelAndView只是一个逻辑视图并不是一个正式的视图，Di spatcherSevlet通过ViewResolver将邀辑视图转化为真正的视图view(这句话简单的就是返回一个要返回的页面的相对路径，通过试图解析器转换成具体那个页面)。</p><p>7、 Dispatcher通过model解析出ModeAndView中的参数进行解析最终展现出完整的view并返回给客户端。</p><h1 id="八、用SpringMVC编写功能模块"><a href="#八、用SpringMVC编写功能模块" class="headerlink" title="八、用SpringMVC编写功能模块"></a>八、用SpringMVC编写功能模块</h1><p>由于框架配置工作量比较大，也需要对各方面的技术有所了解，暂时不做描述。我们简单的说一下实际开发中，如何在现有的框架基础上完成一个功能模块，了解功能的基本流程，以登录为例：</p><p>1、首先要有登录入口（ JSP页面），在SpringMVC框架中我们不建议直接 访问JSP页面，所以我们登录页面的访问也是通过后台处理的；</p><p>2、编写丨ogin.jsp页面及登录返回页面index.jsp ;</p><p>3、编写LoginController，里面包含两个请求控制方法，一个preLogin()，一个doLogin() ，其中preLogin()负责处理请求登录页面的请求（返回到 login.jsp )， doLogin()处理登录请求返回到index.jsp。</p><p>\4. login.jsp中需要通过表单或者ajax进行登录请求。</p><p>请求&#x2F;preLogin业务逻辑处理返回到login.jsp à 输入用户名、密码…</p><p>请求&#x2F;doLogin业务逻辑处理，返回登录结果index.jsp。</p><h1 id="九、其他基础知识"><a href="#九、其他基础知识" class="headerlink" title="九、其他基础知识"></a>九、其他基础知识</h1><p>数据库操作，Jdbc&#x2F;Hibernate&#x2F;Mybatis</p><p>JSP标签，EL表达式，Struts标签，C标签等</p><p>基本的前端技术CSS&#x2F;JS&#x2F;jQuery&#x2F;Ajax</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL概念及数据库表的基本操作</title>
    <link href="/2022/02/21/SQL%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/21/SQL%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL概念及数据库表的基本操作"><a href="#SQL概念及数据库表的基本操作" class="headerlink" title="SQL概念及数据库表的基本操作"></a>SQL概念及数据库表的基本操作</h1><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><ul><li>数据库（Database，DB）：是一个有组织的、统一管理的数据集合。简单来说，就是用来存储数据的地方。</li><li>数据库管理系统（Database Management System，DBMS）：用来操纵和管理数据库的计算机软件，例如MySQL、Oracle、SqlServer等，都是数据库管理系统。</li></ul><p>一个数据库系统中可以包含很多数据库，每个数据库中又包含很多表，表的一列称为一个字段，一行称为一条记录。 例如，下面是一个名为<code>persons</code>的表：</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>gender</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>24</td><td>female</td><td>Beijing</td></tr><tr><td>2</td><td>Bob</td><td>25</td><td>male</td><td>Shanghai</td></tr><tr><td>3</td><td>Candy</td><td>26</td><td>female</td><td>Beijing</td></tr></tbody></table><p>表包含三条记录（每一条对应一个人）和五个列（id、姓名、年龄、性别和地址）。</p><p>掌握这些基础概念后，再来看下<code>SQL</code>。</p><h2 id="SQL-概要"><a href="#SQL-概要" class="headerlink" title="SQL 概要"></a>SQL 概要</h2><h3 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h3><p><code>SQL</code>全称Structured Query Language，表示结构化查询语言，是一种专门与数据库交互的语言，规定了各种关键字、语法等。</p><h3 id="SQL语句及其种类"><a href="#SQL语句及其种类" class="headerlink" title="SQL语句及其种类"></a>SQL语句及其种类</h3><p>使用关键字、表名和列名等以一定语法规则组合而成的语句称之为<code>SQL</code>语句，<code>SQL</code>语句可以对数据库赋予不同指令，根据指令的种类，SQL语句可以分为以下三类：</p><ul><li>DDL（Data Definition Language，数据定义语言）：用来创建、删除或修改数据库以及数据库中的表等对象。<ul><li>create：创建数据库和表等对象</li><li>drop：删除数据库和表等对象</li><li>alter：修改数据库和表等对象的结构</li></ul></li><li>DML（Data Manipulation Language，数据操纵语言）：用来查询或修改表中的记录。<ul><li>select：查询表中的数据</li><li>insert：向表中插入数据</li><li>update：更新表中的数据</li><li>delete：删除表中的数据</li></ul></li><li>DCL（Data Control Language，数据控制语言）：用来确认或取消对数据库中的数据变更的执行操作，以及对用户操作数据库中的对象的权限进行设定。<ul><li>commit：提交，即确认对数据库中的数据进行的变更</li><li>rollback：回滚，即取消对数据库中的数据进行的变更</li><li>grant：赋予用户的操作权限</li><li>revoke：取消用户的操作权限</li></ul></li></ul><h3 id="SQL的基本书写规则"><a href="#SQL的基本书写规则" class="headerlink" title="SQL的基本书写规则"></a>SQL的基本书写规则</h3><ul><li>SQL语句要以分号<code>;</code>结尾</li><li>SQL的关键字不区分大小写，但是表名、字段名、数据等是区分大小写的</li><li>字符串或者日期等类型需用单引号括起来，如’xyz’、’2021-10-29’</li><li>单词需要使用空格或者换行符进行分隔</li><li>数据库、表、字段的名称可以使用英文、数字以及下划线，一般情况下数据库名、表名和列名等小写</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>只列常用：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>int、bigint、tinyint等</td><td>整数数字类型</td></tr><tr><td>char</td><td>定长字符串类型</td></tr><tr><td>varchar</td><td>可变长度字符串类型</td></tr><tr><td>text</td><td>文本类型</td></tr><tr><td>datetime</td><td>日期和时间的组合类型，格式：YYYY-MM-DD HH:MM:SS</td></tr><tr><td>···</td><td>···</td></tr></tbody></table><h2 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h2><h3 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h3><ul><li>创建数据库</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE <span class="hljs-operator">&lt;</span>数据库名<span class="hljs-operator">&gt;</span>;</code></pre></div><ul><li>删除数据库</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE <span class="hljs-operator">&lt;</span>数据库名<span class="hljs-operator">&gt;</span>;</code></pre></div><ul><li>列出数据库</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;</code></pre></div><ul><li>切换数据库</li></ul><div class="code-wrapper"><pre><code class="hljs sql">USE <span class="hljs-operator">&lt;</span>数据库名<span class="hljs-operator">&gt;</span>;</code></pre></div><h3 id="数据表相关"><a href="#数据表相关" class="headerlink" title="数据表相关"></a>数据表相关</h3><ul><li>创建表</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (    <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>约束<span class="hljs-operator">&gt;</span>,    <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>约束<span class="hljs-operator">&gt;</span>,        ...        ...        ...    <span class="hljs-operator">&lt;</span>表的约束<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>,    <span class="hljs-operator">&lt;</span>表的约束<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>,    ....);</code></pre></div><ul><li>删除表</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;</code></pre></div><ul><li><p>更新表</p><ul><li><p>新增列</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>约束<span class="hljs-operator">&gt;</span>;</code></pre></div></li><li><p>删除列</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>;</code></pre></div></li><li><p>修改列</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> MODIFY <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>约束<span class="hljs-operator">&gt;</span>;</code></pre></div></li></ul></li><li><p>插入数据</p></li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....);</code></pre></div><p>指定所要插入数据的列:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>(列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....);</code></pre></div><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>创建数据库</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE test;</code></pre></div><ul><li>显示数据库</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;</code></pre></div><ul><li>切换数据库</li></ul><div class="code-wrapper"><pre><code class="hljs sql">use test;</code></pre></div><ul><li>创建数据表</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `persons` (  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,  `gender` <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;male&#x27;</span> COMMENT <span class="hljs-string">&#x27;性别&#x27;</span>,  `address` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) COMMENT <span class="hljs-string">&#x27;地址&#x27;</span>,  `create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;人员信息表&#x27;</span>;</code></pre></div><ul><li>新增列</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> persons <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> mobile <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) COMMENT <span class="hljs-string">&#x27;手机号&#x27;</span>;</code></pre></div><ul><li>删除列</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> persons <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> mobile;</code></pre></div><ul><li>修改列</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> persons MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>;</code></pre></div><ul><li>插入数据</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> persons <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Alice&#x27;</span>,<span class="hljs-number">24</span>,<span class="hljs-string">&#x27;female&#x27;</span>,<span class="hljs-string">&#x27;Beijing&#x27;</span>,<span class="hljs-string">&#x27;2021-10-29 12:00:00&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> persons(name,age,gender,address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-number">25</span>,<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;Shanghai&#x27;</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
